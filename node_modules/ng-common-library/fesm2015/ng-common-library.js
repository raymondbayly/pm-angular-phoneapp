import { Storage } from '@ionic/storage';
import { Injectable, defineInjectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, timer, Subject, of } from 'rxjs';
import { JwtHelperService } from '@auth0/angular-jwt';
import { switchMap, first, map, tap } from 'rxjs/operators';
import * as moment_ from 'moment-timezone';
import { JwtHelperService as JwtHelperService$1 } from '@auth0/angular-jwt/src/jwthelper.service';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class BrowserService {
    constructor() {
    }
    /**
     * Triggers a browser resize event - needed for the Highchart to resize properly - takes into account the browser type too
     * @return {?}
     */
    resize() {
        if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
            /** @type {?} */
            const evt = document.createEvent('UIEvents');
            evt.initUIEvent('resize', true, false, window, 0);
            window.dispatchEvent(evt);
        }
        else {
            window.dispatchEvent(new Event('resize'));
        }
    }
}
BrowserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BrowserService.ctorParameters = () => [];
/** @nocollapse */ BrowserService.ngInjectableDef = defineInjectable({ factory: function BrowserService_Factory() { return new BrowserService(); }, token: BrowserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
const MarkerColors = {
    Normal: 'black',
    IntensiveCare: '#F23A27',
    StepDown: 'blue',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const moment = moment_;
class DateService {
    /**
     * Formats the date to be displayed based on the parameters provided
     * @param {?} timeZone Each PeraGraph has one. Just pass it as a parameter.
     * @param {?} dateMil The date/time in milliseconds
     * @param {?} formatString A string param that defines the format in which the date needs to be displayed. e.g : MM/DD/YY HH:mm z
     * @return {?}
     */
    getDateFormat(timeZone, dateMil, formatString) {
        return moment(dateMil).utc().tz(timeZone).format(formatString);
    }
    /**
     * Translate a date from a UTC offset.
     *
     * @param {?} date The date to translate.
     * @param {?} timezone The timezone that the date was originally created in.
     * @return {?}
     */
    translateDate(date, timezone) {
        return date + ((3600000 / 60) * moment(date).tz(timezone).utcOffset());
    }
}
DateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DateService.ngInjectableDef = defineInjectable({ factory: function DateService_Factory() { return new DateService(); }, token: DateService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ChartService {
    /**
     * @param {?} dateService
     */
    constructor(dateService) {
        this.dateService = dateService;
    }
    /**
     * Create the line across the 0 axis for when RI scores go below zero in a graph.
     * @param {?} minRiScore Minimum RI score.
     * @return {?}
     */
    createZeroAxisLine(minRiScore) {
        return [
            {
                color: '#000000',
                width: minRiScore < 0 ? 1 : null,
                value: minRiScore < 0 ? 0 : null,
                zIndex: 3
            }
        ];
    }
    /**
     * Create an alert plot line for a graph.
     *
     * @param {?} graph
     * @return {?}
     */
    updateAlertPlotLine(graph) {
        /** @type {?} */
        const plotLines = [];
        if (graph && graph.activeWarning) {
            plotLines.push({
                color: '#CE2029',
                value: this.dateService.translateDate(graph.activeWarning.createdDate, graph.timeZone),
                width: 2,
                zIndex: 3
            });
        }
        return plotLines;
    }
    /**
     * @param {?} minRiScore
     * @return {?}
     */
    getMinYAxisTick(minRiScore) {
        return (minRiScore > 0) ? 0 : 20 * Math.floor(minRiScore / 20);
    }
    /**
     * Used in the graph to depict the unit type where a health score was recorded.
     * @param {?} unitType Type of unit to get the marker color for.
     * @return {?}
     */
    getMarkerColor(unitType) {
        /** @type {?} */
        let markerColor = MarkerColors.Normal;
        switch (unitType) {
            case 'N':
                markerColor = MarkerColors.IntensiveCare;
                break;
            case 'C':
                markerColor = MarkerColors.IntensiveCare;
                break;
            case 'P':
                markerColor = MarkerColors.StepDown;
                break;
        }
        return markerColor;
    }
}
ChartService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ChartService.ctorParameters = () => [
    { type: DateService }
];
/** @nocollapse */ ChartService.ngInjectableDef = defineInjectable({ factory: function ChartService_Factory() { return new ChartService(inject(DateService)); }, token: ChartService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WarningService {
    constructor() {
    }
    /**
     * Returns the correct warning color CSS class
     *
     * @param {?} warning Warning category
     * @return {?}
     */
    getWarningClass(warning) {
        /** @type {?} */
        let warningClass = null;
        switch (warning) {
            case 'V':
                warningClass = 'vh-warning';
                break;
            case 'H':
                warningClass = 'h-warning';
                break;
            case 'M':
                warningClass = 'm-warning';
                break;
            default:
                break;
        }
        return warningClass;
    }
}
WarningService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
WarningService.ctorParameters = () => [];
/** @nocollapse */ WarningService.ngInjectableDef = defineInjectable({ factory: function WarningService_Factory() { return new WarningService(); }, token: WarningService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FlowsheetsConfigService {
    constructor() {
        this.singlePeraGraphFlowSheetEndPoint = null;
        this.allPeragraphFlowSheetsEndPoint = null;
        this.detailedFlowSheetColumnEndpoint = null;
        this.latestRiScoresEndPoint = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setSinglePeraGraphFlowSheetEndPoint(value) {
        this.singlePeraGraphFlowSheetEndPoint = value;
    }
    /**
     * @return {?}
     */
    getSinglePeraGraphFlowSheetEndPoint() {
        if (!this.singlePeraGraphFlowSheetEndPoint) {
            console.warn('Single PeraGraph flowsheet endpoint is not set!');
        }
        return this.singlePeraGraphFlowSheetEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setAllPeragraphFlowSheetsEndPoint(value) {
        this.allPeragraphFlowSheetsEndPoint = value;
    }
    /**
     * @return {?}
     */
    getAllPeragraphFlowSheetsEndPoint() {
        if (!this.allPeragraphFlowSheetsEndPoint) {
            console.warn('All PeraGraph flowsheets endpoint is not set!');
        }
        return this.allPeragraphFlowSheetsEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDetailedFlowSheetColumnEndpoint(value) {
        this.detailedFlowSheetColumnEndpoint = value;
    }
    /**
     * @return {?}
     */
    getDetailedFlowSheetColumnEndpoint() {
        if (!this.detailedFlowSheetColumnEndpoint) {
            console.warn('Detailed flowsheet column endpoint is not set!');
        }
        return this.detailedFlowSheetColumnEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setLatestRiScoresEndPoint(value) {
        this.latestRiScoresEndPoint = value;
    }
    /**
     * @return {?}
     */
    getLatestRiScoresEndPoint() {
        if (!this.latestRiScoresEndPoint) {
            console.warn('Latest RI Scores endpoint is not set!');
        }
        return this.latestRiScoresEndPoint;
    }
}
FlowsheetsConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ FlowsheetsConfigService.ngInjectableDef = defineInjectable({ factory: function FlowsheetsConfigService_Factory() { return new FlowsheetsConfigService(); }, token: FlowsheetsConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FlowsheetsApiService {
    /**
     * @param {?} http
     * @param {?} flowsheetConfigService
     */
    constructor(http, flowsheetConfigService) {
        this.http = http;
        this.flowsheetConfigService = flowsheetConfigService;
        this.pollInstance$ = timer(0, 60000);
        this.flowSheetSubject = new BehaviorSubject(null);
        this.riScoresSubject = new BehaviorSubject(null);
    }
    /**
     * @return {?}
     */
    getFlowSheetSubject() {
        return this.flowSheetSubject;
    }
    /**
     * @return {?}
     */
    getFlowSheetSubjectValue() {
        return this.flowSheetSubject.value;
    }
    /**
     * @return {?}
     */
    getRiScoresSubject() {
        return this.riScoresSubject;
    }
    /**
     * @return {?}
     */
    getRiScoresSubjectValue() {
        return this.riScoresSubject.value;
    }
    /**
     * @return {?}
     */
    getSinglePeraGraphFlowSheet() {
        return this.http.get(this.flowsheetConfigService.getSinglePeraGraphFlowSheetEndPoint());
    }
    /**
     * @return {?}
     */
    getDetailedFlowsheetColumn() {
        return this.http.get(this.flowsheetConfigService.getDetailedFlowSheetColumnEndpoint());
    }
    /**
     * @return {?}
     */
    getAllPeraGraphFlowSheets() {
        return this.http.get(this.flowsheetConfigService.getAllPeragraphFlowSheetsEndPoint(), { observe: 'response' });
    }
    /**
     * @return {?}
     */
    getAllRiScores() {
        return this.http.get(this.flowsheetConfigService.getLatestRiScoresEndPoint(), { observe: 'response' });
    }
    /**
     * @return {?}
     */
    getFlowSheetInterval() {
        // Make an HTTP call on an interval
        return this.pollInstance$.pipe(switchMap(() => this.getAllPeraGraphFlowSheets()));
    }
    /**
     * @return {?}
     */
    getLatestRiScoresInterval() {
        // Make an HTTP call on an interval
        return this.pollInstance$.pipe(switchMap(() => this.getAllRiScores()));
    }
}
FlowsheetsApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FlowsheetsApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: FlowsheetsConfigService }
];
/** @nocollapse */ FlowsheetsApiService.ngInjectableDef = defineInjectable({ factory: function FlowsheetsApiService_Factory() { return new FlowsheetsApiService(inject(HttpClient), inject(FlowsheetsConfigService)); }, token: FlowsheetsApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PeragraphConfigService {
    constructor() {
        this.singlePeraGraphEndPoint = null;
        this.allPeraGraphsEndPoint = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setSinglePeraGraphEndPoint(value) {
        this.singlePeraGraphEndPoint = value;
    }
    /**
     * @return {?}
     */
    getSinglePeraGraphEndPoint() {
        if (!this.singlePeraGraphEndPoint) {
            console.warn('Single PeraGraph endpoint is not set!');
        }
        return this.singlePeraGraphEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setAllPeraGraphsEndPoint(value) {
        this.allPeraGraphsEndPoint = value;
    }
    /**
     * @return {?}
     */
    getAllPeraGraphsEndPoint() {
        if (!this.allPeraGraphsEndPoint) {
            console.warn('All PeraGraph endpoint is not set!');
        }
        return this.allPeraGraphsEndPoint;
    }
}
PeragraphConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PeragraphConfigService.ngInjectableDef = defineInjectable({ factory: function PeragraphConfigService_Factory() { return new PeragraphConfigService(); }, token: PeragraphConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PeragraphApiService {
    /**
     * @param {?} http
     * @param {?} peragraphConfigService
     */
    constructor(http, peragraphConfigService) {
        this.http = http;
        this.peragraphConfigService = peragraphConfigService;
        this.pollInstance$ = timer(0, 60000);
        this._peraGraphSubject = new BehaviorSubject([]);
    }
    /**
     * @return {?}
     */
    getPeraGraphSubject() {
        return this._peraGraphSubject;
    }
    /**
     * @return {?}
     */
    getSinglePeragraph() {
        return this.http.get(this.peragraphConfigService.getSinglePeraGraphEndPoint());
    }
    /**
     * @return {?}
     */
    getAllPeragraphs() {
        return this.http.get(this.peragraphConfigService.getAllPeraGraphsEndPoint());
    }
    /**
     * @return {?}
     */
    getPeraGraphInterval() {
        // Make an HTTP call on an interval
        return this.pollInstance$.pipe(switchMap(() => this.getAllPeragraphs()));
        /*
                 TODO Have a different method with the filtering criteria, using the same subject,
                 and call it when the filter changes. Then we push the change.
        
                 Do the same thing with sorting.
                 */
    }
}
PeragraphApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PeragraphApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: PeragraphConfigService }
];
/** @nocollapse */ PeragraphApiService.ngInjectableDef = defineInjectable({ factory: function PeragraphApiService_Factory() { return new PeragraphApiService(inject(HttpClient), inject(PeragraphConfigService)); }, token: PeragraphApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const moment$1 = moment_;
class PatientService {
    /**
     * @param {?} dateService
     */
    constructor(dateService) {
        this.dateService = dateService;
    }
    /**
     * Returns the patient age in years, months using the patient DOB
     * @param {?} graph
     * @return {?}
     */
    getPatientAge(graph) {
        if (graph && graph.patient && graph.patient.dob) {
            /** @type {?} */
            const daysOld = Math.floor(Math.round((this.dateService.translateDate(moment$1.utc().valueOf(), graph.timeZone) - graph.patient.dob) / 86400000));
            /** @type {?} */
            const d = 'd';
            /** @type {?} */
            const w = 'w';
            /** @type {?} */
            const m = 'm';
            /** @type {?} */
            const y = 'y';
            if (daysOld < 7) {
                return Math.floor(daysOld) + d;
            }
            else if (daysOld >= 7 && daysOld < 31) {
                return Math.floor(daysOld / 7) + w + Math.floor(daysOld % 7) + d;
            }
            else if (daysOld >= 31 && daysOld < 365) {
                return Math.floor(daysOld / 29.7) + m + Math.floor((daysOld % 29.7) / 7) + w;
            }
            else if (daysOld >= 365 && daysOld < 730) {
                return Math.floor(daysOld / 365) + y + Math.floor((daysOld % 365) / 29.7) + m;
            }
            else {
                return Math.floor(daysOld / 365) + y;
            }
        }
        else {
            return ' ';
        }
    }
}
PatientService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PatientService.ctorParameters = () => [
    { type: DateService }
];
/** @nocollapse */ PatientService.ngInjectableDef = defineInjectable({ factory: function PatientService_Factory() { return new PatientService(inject(DateService)); }, token: PatientService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CommonService {
    /**
     * Parse any primitive value (string, number, boolean, undefined or null) to a boolean true or false.
     * @param {?=} value Value to parse.
     * @return {?}
     */
    primitiveToBoolean(value) {
        if (value == null) {
            return false;
        }
        if (value === 'true' || value === 'True' || value === 'TRUE') {
            return true;
        }
        return typeof value === 'string'
            ? !!+value // we parse string to number first
            : !!value;
    }
}
CommonService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CommonService.ngInjectableDef = defineInjectable({ factory: function CommonService_Factory() { return new CommonService(); }, token: CommonService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TranslationsService {
    constructor() {
        this.translations = [];
        this.keyTranslations = {
            'ACTIVE': 'perahealth.translation.ACTIVE',
            'DATA_UPDATED': 'perahealth.translation.DATA_UPDATED',
            'ELAPSED': 'perahealth.translation.ELAPSED',
            'OVERRIDDEN': 'perahealth.translation.OVERRIDDEN',
            'RESUMED': 'perahealth.translation.RESUMED',
            'V': 'perahealth.translation.VH',
            'H': 'perahealth.translation.H',
            'M': 'perahealth.translation.M',
            'N': 'perahealth.translation.N'
        };
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getTranslation(key) {
        return (key) ? this.translations[key] : '';
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getKeyTranslation(key) {
        return (key) ? this.translations[this.keyTranslations[key]] : '';
    }
}
TranslationsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslationsService.ctorParameters = () => [];
/** @nocollapse */ TranslationsService.ngInjectableDef = defineInjectable({ factory: function TranslationsService_Factory() { return new TranslationsService(); }, token: TranslationsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TranslationsConfigService {
    constructor() {
        this.translationsEndPoint = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTranslationsEndPoint(value) {
        this.translationsEndPoint = value;
    }
    /**
     * @return {?}
     */
    getTranslationsEndpoint() {
        if (!this.translationsEndPoint) {
            console.warn('Translations endpoint is not set!');
        }
        return this.translationsEndPoint;
    }
}
TranslationsConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ TranslationsConfigService.ngInjectableDef = defineInjectable({ factory: function TranslationsConfigService_Factory() { return new TranslationsConfigService(); }, token: TranslationsConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TranslationsApiService {
    /**
     * @param {?} http
     * @param {?} translationsConfigService
     */
    constructor(http, translationsConfigService) {
        this.http = http;
        this.translationsConfigService = translationsConfigService;
    }
    /**
     * @return {?}
     */
    getAllTranslations() {
        return this.http.get(this.translationsConfigService.getTranslationsEndpoint());
    }
}
TranslationsApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslationsApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: TranslationsConfigService }
];
/** @nocollapse */ TranslationsApiService.ngInjectableDef = defineInjectable({ factory: function TranslationsApiService_Factory() { return new TranslationsApiService(inject(HttpClient), inject(TranslationsConfigService)); }, token: TranslationsApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DiagnosisConfigService {
    constructor() {
        this.primaryDiagnosesEndpoint = null;
    }
    /**
     * @return {?}
     */
    getPrimaryDiagnosesEndpoint() {
        if (!this.primaryDiagnosesEndpoint) {
            console.warn('Primary diagnoses endpoint is not set!');
        }
        return this.primaryDiagnosesEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setPrimaryDiagnosesEndpoint(value) {
        this.primaryDiagnosesEndpoint = value;
    }
}
DiagnosisConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DiagnosisConfigService.ngInjectableDef = defineInjectable({ factory: function DiagnosisConfigService_Factory() { return new DiagnosisConfigService(); }, token: DiagnosisConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DiagnosisApiService {
    /**
     * @param {?} http
     * @param {?} diagnosisConfigService
     */
    constructor(http, diagnosisConfigService) {
        this.http = http;
        this.diagnosisConfigService = diagnosisConfigService;
        this.pollInstance$ = timer(0, 60000);
        this.diagnosesSubject = new BehaviorSubject(null);
    }
    /**
     * @return {?}
     */
    getDiagnosesSubject() {
        return this.diagnosesSubject;
    }
    /**
     * @return {?}
     */
    getDiagnosesSubjectValue() {
        return this.diagnosesSubject.value;
    }
    /**
     * @return {?}
     */
    getAllDiagnoses() {
        return this.http.get(this.diagnosisConfigService.getPrimaryDiagnosesEndpoint(), { observe: 'response' });
    }
    /**
     * @return {?}
     */
    getPrimaryDiagnosesInterval() {
        // Make an HTTP call on an interval
        return this.pollInstance$.pipe(switchMap(() => this.getAllDiagnoses()));
    }
}
DiagnosisApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DiagnosisApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: DiagnosisConfigService }
];
/** @nocollapse */ DiagnosisApiService.ngInjectableDef = defineInjectable({ factory: function DiagnosisApiService_Factory() { return new DiagnosisApiService(inject(HttpClient), inject(DiagnosisConfigService)); }, token: DiagnosisApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TokenConfigService {
    constructor() {
        this.checkTokenEndPoint = null;
        this.refreshTokenEndPoint = null;
        this.getTokenEndPoint = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setCheckTokenEndPoint(value) {
        this.checkTokenEndPoint = value;
    }
    /**
     * @return {?}
     */
    getCheckTokenEndPoint() {
        if (!this.checkTokenEndPoint) {
            console.warn('Check token endpoint is not set!');
        }
        return this.checkTokenEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setRefreshTokenEndPoint(value) {
        this.refreshTokenEndPoint = value;
    }
    /**
     * @return {?}
     */
    getRefreshTokenEndPoint() {
        if (!this.refreshTokenEndPoint) {
            console.warn('Refresh token endpoint is not set!');
        }
        return this.refreshTokenEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setGetTokenEndPoint(value) {
        this.getTokenEndPoint = value;
    }
    /**
     * @return {?}
     */
    getGetTokenEndPoint() {
        if (!this.getTokenEndPoint) {
            console.warn('Get token endpoint is not set!');
        }
        return this.getTokenEndPoint;
    }
}
TokenConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ TokenConfigService.ngInjectableDef = defineInjectable({ factory: function TokenConfigService_Factory() { return new TokenConfigService(); }, token: TokenConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class User {
    constructor() {
        this.username = null;
        this.password = null;
        this.firstname = null;
        this.lastname = null;
        this.appid = null;
        this.roles = null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TokenApiService {
    /**
     * @param {?} http
     * @param {?} jwtHelper
     * @param {?} config
     * @param {?} storage
     */
    constructor(http, jwtHelper, config, storage) {
        this.http = http;
        this.jwtHelper = jwtHelper;
        this.config = config;
        this.storage = storage;
        this.jwtTokenName = 'jwt_token';
        this.appId = null;
        this.deviceToken = null;
        this.token$ = new Subject();
    }
    /**
     * Check the current token.
     * @return {?}
     */
    checkToken() {
        this.token$.pipe(first()).subscribe((token) => {
            /** @type {?} */
            const decodedToken = this.jwtHelper.decodeToken(token);
            if (decodedToken) {
                /** @type {?} */
                const user = new User();
                user.username = decodedToken['sub'];
                user.roles = decodedToken['roles'];
                user.firstname = decodedToken['firstname'];
                user.lastname = decodedToken['lastname'];
                user.appid = decodedToken['appid'];
                // console.log('Existing, valid client side token found. Checking the server.');
                this.http.post(this.config.getCheckTokenEndPoint(), user).pipe(first()).subscribe(() => {
                    // If we land in here, then the token interceptor on the server validated the token
                    this.appId = user.appid;
                    // console.log('Valid token!');
                    this.token$.next(token);
                }, (e) => {
                    this.appId = null;
                    // console.log('Invalid token!');
                    this.token$.next(null);
                });
            }
            else {
                // console.log('Removing invalid token from storage.');
                this.clearToken();
                this.token$.next(null);
            }
        });
        this.getExistingToken();
    }
    /**
     * Refresh the token for the given user.
     *
     * @param {?} user User for which to refresh token.
     * @return {?}
     */
    refreshToken(user) {
        if (!user || !user.username) ;
        else {
            setTimeout(() => {
                this.token$.pipe(first()).subscribe((token) => {
                    // Check whether or not the token is valid according to the server
                    this.http.post(this.config.getRefreshTokenEndPoint(), user, { responseType: 'text' }).pipe(first()).subscribe((token) => {
                        // console.log('Successfully retrieved updated token [' + token + ']');
                        this.storage.set(this.jwtTokenName, token);
                    }, () => {
                        // The server thinks the token is not valid (expired, the secret key changed, etc)
                        // console.log('Invalid token!');
                        this.clearToken();
                        this.token$.next(null);
                    });
                });
                this.getExistingToken();
            }, 100);
        }
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getToken(user) {
        // Check whether or not the token is valid according to the server
        this.http.post(this.config.getGetTokenEndPoint(), user, { responseType: 'text' }).pipe(first()).subscribe((token) => {
            // console.log('Successfully retrieved new token: [' + token + ']');
            this.appId = user.appid;
            this.storage.set(this.jwtTokenName, token)
                .then(() => {
                // console.log('New token added to storage. [' + token + ']')
                this.token$.next(token);
            }, () => {
                // console.log('Could not store new token!');
                this.token$.next(null);
            });
        }, (e) => {
            // The server thinks the token is not valid (expired, the secret key changed, etc)
            // console.log('Could not retrieve new token!');
            this.token$.next(null);
        });
    }
    /**
     * @return {?}
     */
    clearToken() {
        this.storage.remove(this.jwtTokenName)
            .then((jwt) => {
            // console.log('JWT removed from storage');
        }, (reason) => {
            // console.log('JWT could not be removed from storage. Reason = ' + reason);
        });
    }
    /**
     * @return {?}
     */
    getExistingToken() {
        this.storage.get(this.jwtTokenName)
            .then((token) => {
            this.token$.next(token);
        }, (error) => {
            this.token$.next(null);
        })
            .catch((error) => {
            this.token$.next(null);
        });
    }
    /**
     * @return {?}
     */
    getAppId() {
        return this.appId;
    }
}
TokenApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TokenApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: JwtHelperService },
    { type: TokenConfigService },
    { type: Storage }
];
/** @nocollapse */ TokenApiService.ngInjectableDef = defineInjectable({ factory: function TokenApiService_Factory() { return new TokenApiService(inject(HttpClient), inject(JwtHelperService$1), inject(TokenConfigService), inject(Storage)); }, token: TokenApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class LocationsConfigService {
    constructor() {
        this.activeFacilitiesEndpoint = null;
        this.activeUnitsEndpoint = null;
    }
    /**
     * @return {?}
     */
    getActiveFacilitiesEndpoint() {
        if (!this.activeFacilitiesEndpoint) {
            console.warn('Active facilities endpoint is not set!');
        }
        return this.activeFacilitiesEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setActiveFacilitiesEndpoint(value) {
        this.activeFacilitiesEndpoint = value;
    }
    /**
     * @return {?}
     */
    getActiveUnitsEndpoint() {
        if (!this.activeUnitsEndpoint) {
            console.warn('Active units endpoint is not set!');
        }
        return this.activeUnitsEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setActiveUnitsEndpoint(value) {
        this.activeUnitsEndpoint = value;
    }
}
LocationsConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ LocationsConfigService.ngInjectableDef = defineInjectable({ factory: function LocationsConfigService_Factory() { return new LocationsConfigService(); }, token: LocationsConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Locations {
    constructor() {
        this.facilities = [];
        this.units = [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class LocationsApiService {
    /**
     * @param {?} http
     * @param {?} locationsConfigService
     */
    constructor(http, locationsConfigService) {
        this.http = http;
        this.locationsConfigService = locationsConfigService;
        this.locations = new Locations();
        this.facilitiesAndUnit$ = new Subject();
    }
    /**
     * Updates facilities and units and calls the facilitiesAndUnitSubject when it completes.
     * Will use a cache if they were previously retrieved.
     * @return {?}
     */
    getFacilitiesAndUnits() {
        if (this.locations.facilities && this.locations.facilities.length > 0 && this.locations.units && this.locations.units.length > 0) {
            this.facilitiesAndUnit$.next(this.locations);
        }
        else {
            /** Receive all facilities and active units and set instance variables for caching */
            this.facilitySubscription = this.getActiveFacilities().pipe(map((f) => f.facilities)).subscribe((facilities) => {
                if (facilities && facilities.length > 0) {
                    /** @type {?} */
                    const facilityIds = [];
                    for (const facility of facilities) {
                        facilityIds.push(facility.facilityID);
                    }
                    this.unitSubscription = this.getActiveUnitsForFacilities(facilityIds).pipe((map((u) => u.units))).subscribe((units) => {
                        // filter out facilities with no active units
                        this.locations = new Locations();
                        for (const f of facilities) {
                            /** @type {?} */
                            let hasActiveUnits = false;
                            for (const u of units) {
                                if (u.key.facilityID === f.facilityID) {
                                    hasActiveUnits = true;
                                    break;
                                }
                            }
                            if (hasActiveUnits) {
                                this.locations.facilities.push(f);
                            }
                        }
                        this.locations.units = units;
                        this.facilitiesAndUnit$.next(this.locations);
                    }, (e) => {
                        console.log('Could not update units! Error = ' + e.message);
                    });
                }
            }, (e) => {
                console.log('Could not update facilities! Error = ' + e.message);
            });
        }
    }
    /**
     * @return {?}
     */
    getActiveFacilities() {
        console.log('Getting all facilities: ' + this.locationsConfigService.getActiveFacilitiesEndpoint());
        return this.http.get(this.locationsConfigService.getActiveFacilitiesEndpoint());
    }
    /**
     * @param {?} facilities
     * @return {?}
     */
    getActiveUnitsForFacilities(facilities) {
        console.log('Getting all active units: ' + this.locationsConfigService.getActiveUnitsEndpoint() + facilities);
        return this.http.get(this.locationsConfigService.getActiveUnitsEndpoint() + facilities);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.facilitySubscription && !this.facilitySubscription.closed) {
            this.facilitySubscription.unsubscribe();
        }
        if (this.unitSubscription && !this.unitSubscription.closed) {
            this.unitSubscription.unsubscribe();
        }
    }
}
LocationsApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LocationsApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: LocationsConfigService }
];
/** @nocollapse */ LocationsApiService.ngInjectableDef = defineInjectable({ factory: function LocationsApiService_Factory() { return new LocationsApiService(inject(HttpClient), inject(LocationsConfigService)); }, token: LocationsApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UsageConfigService {
    constructor() {
        this.usagePollingInterval = 5000;
    }
    /**
     * @param {?} value Endpoint for sending usage data.
     * @return {?}
     */
    setUsageDataEndPoint(value) {
        this.usageDataEndPoint = value;
    }
    /**
     * Endpoint for sending usage data.
     * @return {?}
     */
    getUsageDataEndPoint() {
        if (!this.usageDataEndPoint) {
            console.warn('usage data endpoint is not set!');
        }
        return this.usageDataEndPoint;
    }
    /**
     * Number of milliseconds between polling attempts.
     * @return {?}
     */
    getUsagePollingInterval() {
        return this.usagePollingInterval;
    }
    /**
     * @param {?} value Number of milliseconds between polling attempts.
     * @return {?}
     */
    setUsagePollingInterval(value) {
        this.usagePollingInterval = value;
    }
}
UsageConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ UsageConfigService.ngInjectableDef = defineInjectable({ factory: function UsageConfigService_Factory() { return new UsageConfigService(); }, token: UsageConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PatientAccess {
    /**
     * @param {?} viewedBy
     * @param {?} patient
     * @param {?} vipIndicator
     * @param {?} vnm
     * @param {?} mrn
     * @param {?} admitDate
     * @param {?} dischargeDate
     * @param {?} facilityId
     * @param {?} unitId
     * @param {?} provider
     * @param {?} utcCode
     * @param {?} usageCode
     * @param {?} viewDate
     */
    constructor(viewedBy, patient, vipIndicator, vnm, mrn, admitDate, dischargeDate, facilityId, unitId, provider, utcCode, usageCode, viewDate) {
        this.viewedBy = viewedBy;
        this.patient = patient;
        this.vipIndicator = vipIndicator;
        this.vnm = vnm;
        this.mrn = mrn;
        this.admitDate = admitDate;
        this.dischargeDate = dischargeDate;
        this.facilityId = facilityId;
        this.unitId = unitId;
        this.provider = provider;
        this.utcCode = utcCode;
        this.usageCode = usageCode;
        this.viewDate = viewDate;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
const UsageType = {
    Array: 'U',
    Graph: 'G',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const moment$2 = moment_;
class UsageApiService {
    /**
     * @param {?} http
     * @param {?} jwtHelper
     * @param {?} usageConfigService
     * @param {?} locationService
     * @param {?} tokenApiService
     */
    constructor(http, jwtHelper, usageConfigService, locationService, tokenApiService) {
        this.http = http;
        this.jwtHelper = jwtHelper;
        this.usageConfigService = usageConfigService;
        this.locationService = locationService;
        this.tokenApiService = tokenApiService;
        this.usageData = new Array();
        this.viewedVisits = [];
        this.initialized = false;
        this.locationsLoaded$ = new Subject();
        this.locationsLoaded = false;
        this.startedLoadingLocations = false;
        this.graphUpdated$ = new Subject();
        this.usageDataAdded$ = new Subject();
    }
    /**
     * @return {?}
     */
    init() {
        if (!this.initialized) {
            this.initialized = true;
        }
    }
    /**
     * @return {?}
     */
    startUsageReportingService() {
        this.pollInstance$ = timer(0, this.usageConfigService.getUsagePollingInterval());
        this.pollInstance$.subscribe(() => {
            if (this.usageData && this.usageData.length > 0) {
                this.submitUsageData();
            }
        });
        if (this.usageData && this.usageData.length > 0) {
            // Submit now in case the user closes the window before the timer fires
            this.submitUsageData();
        }
        // get all the locations when the service is initialized
        this.locationService.facilitiesAndUnit$.pipe(first()).subscribe((locations) => {
            this.locations = locations;
            this.locationsLoaded = true;
            this.locationsLoaded$.next(true);
        });
        this.locationService.getFacilitiesAndUnits();
    }
    /**
     * @return {?}
     */
    submitUsageData() {
        console.log('Submitting usage data for app ' + this.tokenApiService.getAppId() + ' Size = ' + this.usageData.length);
        /** @type {?} */
        const usageDataCopy = this.usageData.slice();
        this.usageData = [];
        this.http.post(this.usageConfigService.getUsageDataEndPoint(), usageDataCopy).pipe(first()).subscribe();
    }
    /**
     * When the user logs out of the system, we need to clear the cache
     * so that the graph views are sent if they log in again.
     * @return {?}
     */
    clearUsageCache() {
        this.viewedVisits = [];
    }
    /**
     * Add usage data.
     * @param {?} graphToLog The information that was viewed.
     * @param {?} usageType The context in which the information was viewed.
     * @return {?}
     */
    addUsageData(graphToLog, usageType) {
        // We have to replace the facility and unit IDs with the real deals
        this.updateFacilityAndUnitIdsForGraph(graphToLog).pipe(first(), tap((graph) => {
            this.tokenApiService.token$.pipe(first()).subscribe((token) => {
                if (usageType === UsageType.Array) {
                    // Only log 1 graph view per session when viewed in the array view
                    if (graph && this.viewedVisits.indexOf(graph.vnm) < 0) {
                        // We only log 1 visit view of a specific type per session
                        this.viewedVisits.push(graph.vnm);
                        this.addUsageDataFromToken(graph, usageType, token);
                    }
                }
                else {
                    // Always add graph views because the user clicked on a graph in the array view
                    this.addUsageDataFromToken(graph, usageType, token);
                }
            });
            this.tokenApiService.getExistingToken();
        })).subscribe();
        if (!this.locationsLoaded && !this.startedLoadingLocations) {
            this.startedLoadingLocations = true;
            this.locationService.getFacilitiesAndUnits();
        }
    }
    /**
     * lookup and insert the unit id and fac id of graph to log
     * @param {?} graph - graph to log
     * @return {?}
     */
    updateFacilityAndUnitIdsForGraph(graph) {
        /** @type {?} */
        const cloneGraph = JSON.parse(JSON.stringify(graph));
        if (this.locationsLoaded === true) {
            return of(UsageApiService.assignUnitAndFacIdToPeraGraph(cloneGraph, this.locations));
        }
        else {
            return this.locationsLoaded$.pipe(map(() => {
                return UsageApiService.assignUnitAndFacIdToPeraGraph(cloneGraph, this.locations);
            }));
        }
    }
    /**
     * helper method for looking up fac and unit ids
     * @param {?} graph - graph to replace unitId and facId of
     * @param {?} locations - all locations available to search
     * @return {?}
     */
    static assignUnitAndFacIdToPeraGraph(graph, locations) {
        for (const fac of locations.facilities) {
            if (graph.facilityId === fac.displayName) {
                graph.facilityId = fac.facilityID;
                break;
            }
        }
        for (const unit of locations.units) {
            if (graph.unitId === unit.displayName) {
                graph.unitId = unit.key.unitID;
                break;
            }
        }
        return graph;
    }
    /**
     * @param {?} graph
     * @param {?} usageType
     * @param {?} token
     * @return {?}
     */
    addUsageDataFromToken(graph, usageType, token) {
        /** @type {?} */
        const decodedToken = this.jwtHelper.decodeToken(token);
        if (decodedToken) {
            /** @type {?} */
            const pa = new PatientAccess(decodedToken['sub'], // The claims subject is the username
            // The claims subject is the username
            graph.patient.lname + ', ' + graph.patient.fname, graph.vipIndicator, graph.vnm, graph.patient.medicalRecordNumber, graph.admitDate, graph.dischargeDate, graph.facilityId, graph.unitId, graph.attendingProvider.lastName + ', ' + graph.attendingProvider.firstName, graph.visitUnitType, usageType, moment$2.valueOf());
            this.usageData.push(pa);
            // This can be used for testing and for the timing of individual calls to submitUsageData()
            this.usageDataAdded$.next(pa);
        }
    }
}
UsageApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UsageApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: JwtHelperService },
    { type: UsageConfigService },
    { type: LocationsApiService },
    { type: TokenApiService }
];
/** @nocollapse */ UsageApiService.ngInjectableDef = defineInjectable({ factory: function UsageApiService_Factory() { return new UsageApiService(inject(HttpClient), inject(JwtHelperService$1), inject(UsageConfigService), inject(LocationsApiService), inject(TokenApiService)); }, token: UsageApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Facility {
    /**
     * @param {?} active
     * @param {?} facilityID
     * @param {?} displayName
     * @param {?} displayOrder
     * @param {?} facilityTimezone
     * @param {?} fullName
     * @param {?} primaryType
     * @param {?} secondaryType
     */
    constructor(active, facilityID, displayName, displayOrder, facilityTimezone, fullName, primaryType, secondaryType) {
        this.active = active;
        this.facilityID = facilityID;
        this.displayName = displayName;
        this.displayOrder = displayOrder;
        this.facilityTimezone = facilityTimezone;
        this.fullName = fullName;
        this.primaryType = primaryType;
        this.secondaryType = secondaryType;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Unit {
    /**
     * @param {?} key
     * @param {?} displayName
     * @param {?} utcCode
     */
    constructor(key, displayName, utcCode) {
        this.key = key;
        this.displayName = displayName;
        this.utcCode = utcCode;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UnitKey {
    /**
     * @param {?} fid
     * @param {?} uid
     */
    constructor(fid, uid) {
        this.facilityID = fid;
        this.unitID = uid;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { BrowserService, ChartService, DateService, WarningService, FlowsheetsApiService, FlowsheetsConfigService, PeragraphApiService, PeragraphConfigService, PatientService, CommonService, TranslationsService, TranslationsApiService, TranslationsConfigService, DiagnosisApiService, DiagnosisConfigService, TokenConfigService, TokenApiService, LocationsApiService, LocationsConfigService, UsageConfigService, UsageApiService, User, Facility, Unit, PatientAccess, UsageType, UnitKey as Éµa };

//# sourceMappingURL=ng-common-library.js.map