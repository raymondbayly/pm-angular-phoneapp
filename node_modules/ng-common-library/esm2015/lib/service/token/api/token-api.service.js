/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { User } from '../../../model/User';
import { TokenConfigService } from '../config/token-config.service';
import { Storage } from '@ionic/storage';
import { first } from 'rxjs/operators';
import { JwtHelperService } from '@auth0/angular-jwt';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "@auth0/angular-jwt/src/jwthelper.service";
import * as i3 from "../config/token-config.service";
import * as i4 from "@ionic/storage";
export class TokenApiService {
    /**
     * @param {?} http
     * @param {?} jwtHelper
     * @param {?} config
     * @param {?} storage
     */
    constructor(http, jwtHelper, config, storage) {
        this.http = http;
        this.jwtHelper = jwtHelper;
        this.config = config;
        this.storage = storage;
        this.jwtTokenName = 'jwt_token';
        this.appId = null;
        this.deviceToken = null;
        this.token$ = new Subject();
    }
    /**
     * Check the current token.
     * @return {?}
     */
    checkToken() {
        this.token$.pipe(first()).subscribe((token) => {
            /** @type {?} */
            const decodedToken = this.jwtHelper.decodeToken(token);
            if (decodedToken) {
                /** @type {?} */
                const user = new User();
                user.username = decodedToken['sub'];
                user.roles = decodedToken['roles'];
                user.firstname = decodedToken['firstname'];
                user.lastname = decodedToken['lastname'];
                user.appid = decodedToken['appid'];
                // console.log('Existing, valid client side token found. Checking the server.');
                this.http.post(this.config.getCheckTokenEndPoint(), user).pipe(first()).subscribe(() => {
                    // If we land in here, then the token interceptor on the server validated the token
                    this.appId = user.appid;
                    // console.log('Valid token!');
                    this.token$.next(token);
                }, (e) => {
                    this.appId = null;
                    // console.log('Invalid token!');
                    this.token$.next(null);
                });
            }
            else {
                // console.log('Removing invalid token from storage.');
                this.clearToken();
                this.token$.next(null);
            }
        });
        this.getExistingToken();
    }
    /**
     * Refresh the token for the given user.
     *
     * @param {?} user User for which to refresh token.
     * @return {?}
     */
    refreshToken(user) {
        if (!user || !user.username) {
            // console.log('Valid user not supplied, cannot refresh token!');
        }
        else {
            setTimeout(() => {
                this.token$.pipe(first()).subscribe((token) => {
                    // Check whether or not the token is valid according to the server
                    this.http.post(this.config.getRefreshTokenEndPoint(), user, { responseType: 'text' }).pipe(first()).subscribe((token) => {
                        // console.log('Successfully retrieved updated token [' + token + ']');
                        this.storage.set(this.jwtTokenName, token);
                    }, () => {
                        // The server thinks the token is not valid (expired, the secret key changed, etc)
                        // console.log('Invalid token!');
                        this.clearToken();
                        this.token$.next(null);
                    });
                });
                this.getExistingToken();
            }, 100);
        }
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getToken(user) {
        // Check whether or not the token is valid according to the server
        this.http.post(this.config.getGetTokenEndPoint(), user, { responseType: 'text' }).pipe(first()).subscribe((token) => {
            // console.log('Successfully retrieved new token: [' + token + ']');
            this.appId = user.appid;
            this.storage.set(this.jwtTokenName, token)
                .then(() => {
                // console.log('New token added to storage. [' + token + ']')
                this.token$.next(token);
            }, () => {
                // console.log('Could not store new token!');
                this.token$.next(null);
            });
        }, (e) => {
            // The server thinks the token is not valid (expired, the secret key changed, etc)
            // console.log('Could not retrieve new token!');
            this.token$.next(null);
        });
    }
    /**
     * @return {?}
     */
    clearToken() {
        this.storage.remove(this.jwtTokenName)
            .then((jwt) => {
            // console.log('JWT removed from storage');
        }, (reason) => {
            // console.log('JWT could not be removed from storage. Reason = ' + reason);
        });
    }
    /**
     * @return {?}
     */
    getExistingToken() {
        this.storage.get(this.jwtTokenName)
            .then((token) => {
            this.token$.next(token);
        }, (error) => {
            this.token$.next(null);
        })
            .catch((error) => {
            this.token$.next(null);
        });
    }
    /**
     * @return {?}
     */
    getAppId() {
        return this.appId;
    }
}
TokenApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TokenApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: JwtHelperService },
    { type: TokenConfigService },
    { type: Storage }
];
/** @nocollapse */ TokenApiService.ngInjectableDef = i0.defineInjectable({ factory: function TokenApiService_Factory() { return new TokenApiService(i0.inject(i1.HttpClient), i0.inject(i2.JwtHelperService), i0.inject(i3.TokenConfigService), i0.inject(i4.Storage)); }, token: TokenApiService, providedIn: "root" });
if (false) {
    /** @type {?} */
    TokenApiService.prototype.jwtTokenName;
    /** @type {?} */
    TokenApiService.prototype.appId;
    /** @type {?} */
    TokenApiService.prototype.deviceToken;
    /** @type {?} */
    TokenApiService.prototype.token$;
    /** @type {?} */
    TokenApiService.prototype.http;
    /** @type {?} */
    TokenApiService.prototype.jwtHelper;
    /** @type {?} */
    TokenApiService.prototype.config;
    /** @type {?} */
    TokenApiService.prototype.storage;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tYXBpLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1jb21tb24tbGlicmFyeS8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlL3Rva2VuL2FwaS90b2tlbi1hcGkuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQ3pDLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGdDQUFnQyxDQUFDO0FBQ2xFLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDcEQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQzs7Ozs7O0FBSzdCLE1BQU07Ozs7Ozs7SUFVRixZQUFvQixJQUFnQixFQUNoQixXQUNBLFFBQ0E7UUFIQSxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGNBQVMsR0FBVCxTQUFTO1FBQ1QsV0FBTSxHQUFOLE1BQU07UUFDTixZQUFPLEdBQVAsT0FBTzs0QkFaSixXQUFXO3FCQUVWLElBQUk7MkJBRUUsSUFBSTtzQkFHUSxJQUFJLE9BQU8sRUFBVTtLQU05RDs7Ozs7SUFLTSxVQUFVO1FBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFhLEVBQUUsRUFBRTs7WUFDbEQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkQsRUFBRSxDQUFDLENBQUMsWUFB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QixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7WUFWTyxVQUFVO1lBS1YsZ0JBQWdCO1lBSGhCLGtCQUFrQjtZQUNsQixPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SHR0cENsaWVudH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHtVc2VyfSBmcm9tICcuLi8uLi8uLi9tb2RlbC9Vc2VyJztcbmltcG9ydCB7VG9rZW5Db25maWdTZXJ2aWNlfSBmcm9tICcuLi9jb25maWcvdG9rZW4tY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHtTdG9yYWdlfSBmcm9tICdAaW9uaWMvc3RvcmFnZSc7XG5pbXBvcnQge2ZpcnN0fSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0p3dEhlbHBlclNlcnZpY2V9IGZyb20gJ0BhdXRoMC9hbmd1bGFyLWp3dCc7XG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRva2VuQXBpU2VydmljZSB7XG4gICAgcHJpdmF0ZSBqd3RUb2tlbk5hbWUgPSAnand0X3Rva2VuJztcbiAgICAvLyBNYWtlIHRoZSBhcHBJZCBhdmFpbGFibGUgdG8gb3RoZXIgc2VydmljZXNcbiAgICBwcml2YXRlIGFwcElkOiBzdHJpbmcgPSBudWxsO1xuXG4gICAgcHJpdmF0ZSBkZXZpY2VUb2tlbjogc3RyaW5nID0gbnVsbDtcblxuICAgIC8vIFVzZWQgdG8gcmVwb3J0IHdoZW4gYSB0b2tlbiBoYXMgYmVlbiByZXRyaWV2ZWQgZnJvbSBzdG9yYWdlXG4gICAgcHVibGljIHJlYWRvbmx5IHRva2VuJDogU3ViamVjdDxzdHJpbmc+ID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgand0SGVscGVyOiBKd3RIZWxwZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29uZmlnOiBUb2tlbkNvbmZpZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBzdG9yYWdlOiBTdG9yYWdlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICovXG4gICAgcHVibGljIGNoZWNrVG9rZW4oKSB7XG4gICAgICAgIHRoaXMudG9rZW4kLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkVG9rZW4gPSB0aGlzLmp3dEhlbHBlci5kZWNvZGVUb2tlbih0b2tlbik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBhIHVzZXIgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIFJFU1Qgc2VydmljZVxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcigpO1xuICAgICAgICAgICAgICAgIHVzZXIudXNlcm5hbWUgPSBkZWNvZGVkVG9rZW5bJ3N1YiddO1xuICAgICAgICAgICAgICAgIHVzZXIucm9sZXMgPSBkZWNvZGVkVG9rZW5bJ3JvbGVzJ107XG4gICAgICAgICAgICAgICAgdXNlci5maXJzdG5hbWUgPSBkZWNvZGVkVG9rZW5bJ2ZpcnN0bmFtZSddO1xuICAgICAgICAgICAgICAgIHVzZXIubGFzdG5hbWUgPSBkZWNvZGVkVG9rZW5bJ2xhc3RuYW1lJ107XG4gICAgICAgICAgICAgICAgdXNlci5hcHBpZCA9IGRlY29kZWRUb2tlblsnYXBwaWQnXTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdFeGlzdGluZywgdmFsaWQgY2xpZW50IHNpZGUgdG9rZW4gZm91bmQuIENoZWNraW5nIHRoZSBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5odHRwLnBvc3QodGhpcy5jb25maWcuZ2V0Q2hlY2tUb2tlbkVuZFBvaW50KCksIHVzZXIpLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgbGFuZCBpbiBoZXJlLCB0aGVuIHRoZSB0b2tlbiBpbnRlcmNlcHRvciBvbiB0aGUgc2VydmVyIHZhbGlkYXRlZCB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJZCA9IHVzZXIuYXBwaWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWxpZCB0b2tlbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbiQubmV4dCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdJbnZhbGlkIHRva2VuIScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUmVtb3ZpbmcgaW52YWxpZCB0b2tlbiBmcm9tIHN0b3JhZ2UuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRva2VuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbiQubmV4dChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0RXhpc3RpbmdUb2tlbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIHRva2VuIGZvciB0aGUgZ2l2ZW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyIFVzZXIgZm9yIHdoaWNoIHRvIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgcHVibGljIHJlZnJlc2hUb2tlbih1c2VyOiBVc2VyKSB7XG4gICAgICAgIGlmICghdXNlciB8fCAhdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbGlkIHVzZXIgbm90IHN1cHBsaWVkLCBjYW5ub3QgcmVmcmVzaCB0b2tlbiEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW4kLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgb3Igbm90IHRoZSB0b2tlbiBpcyB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAucG9zdCh0aGlzLmNvbmZpZy5nZXRSZWZyZXNoVG9rZW5FbmRQb2ludCgpLCB1c2VyLCB7cmVzcG9uc2VUeXBlOiAndGV4dCd9KS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgodG9rZW46IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcmV0cmlldmVkIHVwZGF0ZWQgdG9rZW4gWycgKyB0b2tlbiArICddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh0aGlzLmp3dFRva2VuTmFtZSwgdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgdGhpbmtzIHRoZSB0b2tlbiBpcyBub3QgdmFsaWQgKGV4cGlyZWQsIHRoZSBzZWNyZXQga2V5IGNoYW5nZWQsIGV0YylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSW52YWxpZCB0b2tlbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFeGlzdGluZ1Rva2VuKCk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRva2VuKHVzZXI6IFVzZXIpIHtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBvciBub3QgdGhlIHRva2VuIGlzIHZhbGlkIGFjY29yZGluZyB0byB0aGUgc2VydmVyXG4gICAgICAgIHRoaXMuaHR0cC5wb3N0KHRoaXMuY29uZmlnLmdldEdldFRva2VuRW5kUG9pbnQoKSwgdXNlciwge3Jlc3BvbnNlVHlwZTogJ3RleHQnfSkucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBuZXcgdG9rZW46IFsnICsgdG9rZW4gKyAnXScpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwSWQgPSB1c2VyLmFwcGlkO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQodGhpcy5qd3RUb2tlbk5hbWUsIHRva2VuKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHRva2VuIGFkZGVkIHRvIHN0b3JhZ2UuIFsnICsgdG9rZW4gKyAnXScpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NvdWxkIG5vdCBzdG9yZSBuZXcgdG9rZW4hJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgdGhpbmtzIHRoZSB0b2tlbiBpcyBub3QgdmFsaWQgKGV4cGlyZWQsIHRoZSBzZWNyZXQga2V5IGNoYW5nZWQsIGV0YylcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ291bGQgbm90IHJldHJpZXZlIG5ldyB0b2tlbiEnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFyVG9rZW4oKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5qd3RUb2tlbk5hbWUpXG4gICAgICAgICAgICAudGhlbigoand0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSldUIHJlbW92ZWQgZnJvbSBzdG9yYWdlJyk7XG4gICAgICAgICAgICB9LCAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSldUIGNvdWxkIG5vdCBiZSByZW1vdmVkIGZyb20gc3RvcmFnZS4gUmVhc29uID0gJyArIHJlYXNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RXhpc3RpbmdUb2tlbigpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLmdldCh0aGlzLmp3dFRva2VuTmFtZSlcbiAgICAgICAgICAgIC50aGVuKCh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbiQubmV4dCh0b2tlbik7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuJC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEFwcElkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcElkO1xuICAgIH1cbn1cbiJdfQ==