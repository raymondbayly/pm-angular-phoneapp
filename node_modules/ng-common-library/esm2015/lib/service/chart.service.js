/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { MarkerColors } from '../model/MarkerColors';
import { DateService } from './date.service';
import * as i0 from "@angular/core";
import * as i1 from "./date.service";
export class ChartService {
    /**
     * @param {?} dateService
     */
    constructor(dateService) {
        this.dateService = dateService;
    }
    /**
     * Create the line across the 0 axis for when RI scores go below zero in a graph.
     * @param {?} minRiScore Minimum RI score.
     * @return {?}
     */
    createZeroAxisLine(minRiScore) {
        return [
            {
                color: '#000000',
                width: minRiScore < 0 ? 1 : null,
                value: minRiScore < 0 ? 0 : null,
                zIndex: 3
            }
        ];
    }
    /**
     * Create an alert plot line for a graph.
     *
     * @param {?} graph
     * @return {?}
     */
    updateAlertPlotLine(graph) {
        /** @type {?} */
        const plotLines = [];
        if (graph && graph.activeWarning) {
            plotLines.push({
                color: '#CE2029',
                value: this.dateService.translateDate(graph.activeWarning.createdDate, graph.timeZone),
                width: 2,
                zIndex: 3
            });
        }
        return plotLines;
    }
    /**
     * @param {?} minRiScore
     * @return {?}
     */
    getMinYAxisTick(minRiScore) {
        return (minRiScore > 0) ? 0 : 20 * Math.floor(minRiScore / 20);
    }
    /**
     * Used in the graph to depict the unit type where a health score was recorded.
     * @param {?} unitType Type of unit to get the marker color for.
     * @return {?}
     */
    getMarkerColor(unitType) {
        /** @type {?} */
        let markerColor = MarkerColors.Normal;
        switch (unitType) {
            case 'N':
                markerColor = MarkerColors.IntensiveCare;
                break;
            case 'C':
                markerColor = MarkerColors.IntensiveCare;
                break;
            case 'P':
                markerColor = MarkerColors.StepDown;
                break;
        }
        return markerColor;
    }
}
ChartService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ChartService.ctorParameters = () => [
    { type: DateService }
];
/** @nocollapse */ ChartService.ngInjectableDef = i0.defineInjectable({ factory: function ChartService_Factory() { return new ChartService(i0.inject(i1.DateService)); }, token: ChartService, providedIn: "root" });
if (false) {
    /** @type {?} */
    ChartService.prototype.dateService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWNvbW1vbi1saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2UvY2hhcnQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUV6QyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDbkQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7QUFLM0MsTUFBTTs7OztJQUVKLFlBQW9CLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0tBQzNDOzs7Ozs7SUFNTSxrQkFBa0IsQ0FBQyxVQUFrQjtRQUMxQyxNQUFNLENBQUM7WUFDTDtnQkFDRSxLQUFLLEVBQUUsU0FBUztnQkFDaEIsS0FBSyxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtnQkFDaEMsS0FBSyxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtnQkFDaEMsTUFBTSxFQUFFLENBQUM7YUFDVjtTQUFDLENBQUM7Ozs7Ozs7O0lBU0EsbUJBQW1CLENBQUMsS0FBZ0I7O1FBQ3pDLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDakMsU0FBUyxDQUFDLElBQUksQ0FBQztnQkFDYixLQUFLLEVBQUUsU0FBUztnQkFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUM7Z0JBQ3RGLEtBQUssRUFBRSxDQUFDO2dCQUNSLE1BQU0sRUFBRSxDQUFDO2FBQ1YsQ0FBQyxDQUFDO1NBQ0o7UUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDOzs7Ozs7SUFHWixlQUFlLENBQUMsVUFBVTtRQUMvQixNQUFNLENBQUMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7O0lBTzFELGNBQWMsQ0FBQyxRQUFnQjs7UUFDcEMsSUFBSSxXQUFXLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUN0QyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEtBQUssR0FBRztnQkFDTixXQUFXLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQztnQkFDekMsS0FBSyxDQUFDO1lBQ1IsS0FBSyxHQUFHO2dCQUNOLFdBQVcsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDO2dCQUN6QyxLQUFLLENBQUM7WUFDUixLQUFLLEdBQUc7Z0JBQ04sV0FBVyxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUM7Z0JBQ3BDLEtBQUssQ0FBQztTQUNUO1FBQ0QsTUFBTSxDQUFDLFdBQVcsQ0FBQzs7OztZQTlEdEIsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7O1lBSk8sV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BlcmFHcmFwaH0gZnJvbSAnLi4vbW9kZWwvUGVyYUdyYXBoJztcbmltcG9ydCB7TWFya2VyQ29sb3JzfSBmcm9tICcuLi9tb2RlbC9NYXJrZXJDb2xvcnMnO1xuaW1wb3J0IHtEYXRlU2VydmljZX0gZnJvbSAnLi9kYXRlLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBDaGFydFNlcnZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZVNlcnZpY2U6IERhdGVTZXJ2aWNlKSB7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBsaW5lIGFjcm9zcyB0aGUgMCBheGlzIGZvciB3aGVuIFJJIHNjb3JlcyBnbyBiZWxvdyB6ZXJvIGluIGEgZ3JhcGguXG4gICAqIEBwYXJhbSBtaW5SaVNjb3JlIE1pbmltdW0gUkkgc2NvcmUuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlWmVyb0F4aXNMaW5lKG1pblJpU2NvcmU6IG51bWJlcikge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgIHdpZHRoOiBtaW5SaVNjb3JlIDwgMCA/IDEgOiBudWxsLFxuICAgICAgICB2YWx1ZTogbWluUmlTY29yZSA8IDAgPyAwIDogbnVsbCxcbiAgICAgICAgekluZGV4OiAzXG4gICAgICB9XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYWxlcnQgcGxvdCBsaW5lIGZvciBhIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gYWxlcnRDcmVhdGVkRGF0ZSBUaGUgY3JlYXRlZCBkYXRlIG9mIHRoZSBhbGVydC5cbiAgICogQHBhcmFtIHRpbWVab25lIFRoZSB0aW1lem9uZSB0aGF0IHRoZSBhbGVydCB3YXMgY3JlYXRlZCBpbi5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVBbGVydFBsb3RMaW5lKGdyYXBoOiBQZXJhR3JhcGgpIHtcbiAgICBjb25zdCBwbG90TGluZXMgPSBbXTtcbiAgICBpZiAoZ3JhcGggJiYgZ3JhcGguYWN0aXZlV2FybmluZykge1xuICAgICAgcGxvdExpbmVzLnB1c2goe1xuICAgICAgICBjb2xvcjogJyNDRTIwMjknLFxuICAgICAgICB2YWx1ZTogdGhpcy5kYXRlU2VydmljZS50cmFuc2xhdGVEYXRlKGdyYXBoLmFjdGl2ZVdhcm5pbmcuY3JlYXRlZERhdGUsIGdyYXBoLnRpbWVab25lKSxcbiAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgIHpJbmRleDogM1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbG90TGluZXM7XG4gIH1cblxuICBwdWJsaWMgZ2V0TWluWUF4aXNUaWNrKG1pblJpU2NvcmUpOiBudW1iZXIge1xuICAgIHJldHVybiAobWluUmlTY29yZSA+IDApID8gMCA6IDIwICogTWF0aC5mbG9vcihtaW5SaVNjb3JlIC8gMjApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgaW4gdGhlIGdyYXBoIHRvIGRlcGljdCB0aGUgdW5pdCB0eXBlIHdoZXJlIGEgaGVhbHRoIHNjb3JlIHdhcyByZWNvcmRlZC5cbiAgICogQHBhcmFtIHVuaXRUeXBlIFR5cGUgb2YgdW5pdCB0byBnZXQgdGhlIG1hcmtlciBjb2xvciBmb3IuXG4gICAqL1xuICBwdWJsaWMgZ2V0TWFya2VyQ29sb3IodW5pdFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IG1hcmtlckNvbG9yID0gTWFya2VyQ29sb3JzLk5vcm1hbDtcbiAgICBzd2l0Y2ggKHVuaXRUeXBlKSB7XG4gICAgICBjYXNlICdOJzpcbiAgICAgICAgbWFya2VyQ29sb3IgPSBNYXJrZXJDb2xvcnMuSW50ZW5zaXZlQ2FyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgbWFya2VyQ29sb3IgPSBNYXJrZXJDb2xvcnMuSW50ZW5zaXZlQ2FyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQJzpcbiAgICAgICAgbWFya2VyQ29sb3IgPSBNYXJrZXJDb2xvcnMuU3RlcERvd247XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyQ29sb3I7XG4gIH1cbn1cbiJdfQ==