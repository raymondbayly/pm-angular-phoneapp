/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as moment_ from 'moment-timezone';
import * as i0 from "@angular/core";
/** @type {?} */
const moment = moment_;
export class DateService {
    /**
     * Formats the date to be displayed based on the parameters provided
     * @param {?} timeZone Each PeraGraph has one. Just pass it as a parameter.
     * @param {?} dateMil The date/time in milliseconds
     * @param {?} formatString A string param that defines the format in which the date needs to be displayed. e.g : MM/DD/YY HH:mm z
     * @return {?}
     */
    getDateFormat(timeZone, dateMil, formatString) {
        return moment(dateMil).utc().tz(timeZone).format(formatString);
    }
    /**
     * Translate a date from a UTC offset.
     *
     * @param {?} date The date to translate.
     * @param {?} timezone The timezone that the date was originally created in.
     * @return {?}
     */
    translateDate(date, timezone) {
        return date + ((3600000 / 60) * moment(date).tz(timezone).utcOffset());
    }
}
DateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DateService.ngInjectableDef = i0.defineInjectable({ factory: function DateService_Factory() { return new DateService(); }, token: DateService, providedIn: "root" });

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctY29tbW9uLWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvc2VydmljZS9kYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxLQUFLLE9BQU8sTUFBTSxpQkFBaUIsQ0FBQzs7O0FBSTNDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQztBQUt2QixNQUFNOzs7Ozs7OztJQU9HLGFBQWEsQ0FBQyxRQUFnQixFQUFFLE9BQWUsRUFBRSxZQUFvQjtRQUMxRSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7OztJQVMxRCxhQUFhLENBQUMsSUFBWSxFQUFFLFFBQWdCO1FBQ2pELE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7Ozs7WUFyQjFFLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudC10aW1lem9uZSc7XG5cbi8vIFRoZSBKYXZhU2NyaXB0IGNvbXBpbGVyIGdpdmVzIGEgd2VpcmQgXCJtb21lbnQgY2Fubm90IGJlIHVzZWQgYXMgYSBuYW1lc3BhY2VcIiB0eXBlIG9mIGVycm9yXG4vLyBUaGlzIGlzIHRoZSB3b3JrYXJvdW5kLi4uXG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBEYXRlU2VydmljZSB7XG4gIC8qKlxuICAgKiBGb3JtYXRzIHRoZSBkYXRlIHRvIGJlIGRpc3BsYXllZCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBwcm92aWRlZFxuICAgKiBAcGFyYW0gZGF0ZU1pbCBUaGUgZGF0ZS90aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0gdGltZVpvbmUgRWFjaCBQZXJhR3JhcGggaGFzIG9uZS4gSnVzdCBwYXNzIGl0IGFzIGEgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gZm9ybWF0U3RyaW5nIEEgc3RyaW5nIHBhcmFtIHRoYXQgZGVmaW5lcyB0aGUgZm9ybWF0IGluIHdoaWNoIHRoZSBkYXRlIG5lZWRzIHRvIGJlIGRpc3BsYXllZC4gZS5nIDogTU0vREQvWVkgSEg6bW0gelxuICAgKi9cbiAgcHVibGljIGdldERhdGVGb3JtYXQodGltZVpvbmU6IHN0cmluZywgZGF0ZU1pbDogbnVtYmVyLCBmb3JtYXRTdHJpbmc6IHN0cmluZykge1xuICAgIHJldHVybiBtb21lbnQoZGF0ZU1pbCkudXRjKCkudHoodGltZVpvbmUpLmZvcm1hdChmb3JtYXRTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBhIGRhdGUgZnJvbSBhIFVUQyBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIHRyYW5zbGF0ZS5cbiAgICogQHBhcmFtIHRpbWV6b25lIFRoZSB0aW1lem9uZSB0aGF0IHRoZSBkYXRlIHdhcyBvcmlnaW5hbGx5IGNyZWF0ZWQgaW4uXG4gICAqL1xuICBwdWJsaWMgdHJhbnNsYXRlRGF0ZShkYXRlOiBudW1iZXIsIHRpbWV6b25lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZGF0ZSArICgoMzYwMDAwMCAvIDYwKSAqIG1vbWVudChkYXRlKS50eih0aW1lem9uZSkudXRjT2Zmc2V0KCkpO1xuICB9XG59XG4iXX0=