/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input } from '@angular/core';
import { ArrayViewService } from '../../service/array-view.service';
import { PeraGraphService } from './service/pera-graph.service';
import { HttpClient } from '@angular/common/http';
import { TooltipService } from './service/tooltip.service';
import { FlowsheetsApiService, UsageApiService, UsageType } from 'ng-common-library';
import { PriorWarningsApiService } from '../../service/prior-warnings/api/prior-warnings-api.service';
var PeraGraphComponent = /** @class */ (function () {
    function PeraGraphComponent(service, flowsheetsApiService, priorWarningsApiService, usageService, graphService, toolTipService, http, ref) {
        this.service = service;
        this.flowsheetsApiService = flowsheetsApiService;
        this.priorWarningsApiService = priorWarningsApiService;
        this.usageService = usageService;
        this.graphService = graphService;
        this.toolTipService = toolTipService;
        this.http = http;
        this.ref = ref;
        this.margin = 10;
        this.isMouseOverPeraGraph = false;
    }
    /**
     * @return {?}
     */
    PeraGraphComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscribeToPeraGraphDataFeeds();
        this.subscribeToToolTipInfoEvent();
        this.style = {
            width: this.peraGraphWidth - this.margin + 'px',
            height: this.peraGraphHeight - this.margin + 'px'
        };
        this.usageService.addUsageData(this.graph, UsageType.Array);
        // Manage change detection explicitly
        this.ref.detach();
    };
    /**
     * Subscribe to the interval observables/subjects that pass information the PeraGraph needs
     *
     * Currently, this includes prior warnings and flowsheets
     */
    /**
     * Subscribe to the interval observables/subjects that pass information the PeraGraph needs
     *
     * Currently, this includes prior warnings and flowsheets
     * @return {?}
     */
    PeraGraphComponent.prototype.subscribeToPeraGraphDataFeeds = /**
     * Subscribe to the interval observables/subjects that pass information the PeraGraph needs
     *
     * Currently, this includes prior warnings and flowsheets
     * @return {?}
     */
    function () {
        var _this = this;
        this.flowSheetMap$ = this.flowsheetsApiService.getFlowSheetSubject().subscribe(function (fscMap) {
            _this.getFlowSheetsForVisit(fscMap);
            if (_this.ref) {
                _this.ref.detectChanges();
            }
        });
        this.priorWarningMap$ = this.priorWarningsApiService.getPriorWarningSubject().subscribe(function (pwMap) {
            _this.getPriorWarningsForVisit(pwMap);
            if (_this.ref) {
                _this.ref.detectChanges();
            }
        });
    };
    /**
     * @return {?}
     */
    PeraGraphComponent.prototype.subscribeToToolTipInfoEvent = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.toolTipInfoEvent$ = this.toolTipService.toolTipInfoUpdated$.subscribe(function (toolTipInfo) {
            // Ensure that the user hasn't moved onto a new graph with a different during the time that the call was made to the server
            if (_this.isMouseOverPeraGraph && toolTipInfo.visitId === _this.graph.visitId) {
                // If the service takes a second to respond and the popover is no longer there, don't try to open it
                if (_this.tooltip) {
                    _this.graphService.tooltip = _this.tooltip;
                    _this.tooltip.open();
                }
                if (_this.ref) {
                    _this.ref.detectChanges();
                }
            }
        });
    };
    /**
     * This only fires when the user passes the mouse over the graph to get the tooltip.
     * For those graphs, force a change detection cycle so that the ToolTip component updates.
     */
    /**
     * This only fires when the user passes the mouse over the graph to get the tooltip.
     * For those graphs, force a change detection cycle so that the ToolTip component updates.
     * @param {?} po
     * @return {?}
     */
    PeraGraphComponent.prototype.mouseEnterHandler = /**
     * This only fires when the user passes the mouse over the graph to get the tooltip.
     * For those graphs, force a change detection cycle so that the ToolTip component updates.
     * @param {?} po
     * @return {?}
     */
    function (po) {
        if (!this.isMouseOverPeraGraph && !po.isOpen()) {
            this.isMouseOverPeraGraph = true;
            this.tooltip = po;
            if (this.graph) {
                // Close any existing tooltip
                this.graphService.closeToolTip();
                this.toolTipService.updateToolTipInfo(this.graph);
            }
        }
    };
    /**
     * This fires when the user passes the mouse over the graph, and then moves the mouse off of the graph
     * For those graphs, close the tooltip
     *
     * @param po
     */
    /**
     * This fires when the user passes the mouse over the graph, and then moves the mouse off of the graph
     * For those graphs, close the tooltip
     *
     * @param {?} po
     * @return {?}
     */
    PeraGraphComponent.prototype.mouseLeaveHandler = /**
     * This fires when the user passes the mouse over the graph, and then moves the mouse off of the graph
     * For those graphs, close the tooltip
     *
     * @param {?} po
     * @return {?}
     */
    function (po) {
        this.isMouseOverPeraGraph = false;
        if (po.isOpen()) {
            po.close();
        }
    };
    /**
     * @param {?} graph
     * @return {?}
     */
    PeraGraphComponent.prototype.graphClicked = /**
     * @param {?} graph
     * @return {?}
     */
    function (graph) {
        if (this.tooltip && this.tooltip.isOpen()) {
            // console.log('Forcefully closing tooltip');
            this.tooltip.close();
            this.tooltip = null;
        }
        this.graphService.graphClickedEvent(graph);
        this.service.tokenRefresh$.next();
    };
    /**
     * @param {?} po
     * @return {?}
     */
    PeraGraphComponent.prototype.isShown = /**
     * @param {?} po
     * @return {?}
     */
    function (po) {
        if (!this.tooltip) {
            // Closing tooltip
            setTimeout(function () { return po.close(); }, 1);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    PeraGraphComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // If the item size changed, update style
        if (changes && changes.peraGraphWidth && changes.peraGraphWidth.previousValue !== changes.peraGraphWidth.currentValue) {
            this.style = {
                width: this.peraGraphWidth - this.margin + 'px',
                height: this.peraGraphHeight - this.margin + 'px'
            };
        }
        // If the graph changed, update the related data so that we're showing the right information
        if (changes &&
            changes.graph &&
            changes.graph.currentValue !== changes.graph.previousValue &&
            !changes.graph.firstChange &&
            changes.graph.currentValue.visitId !== changes.graph.previousValue.visitId) {
            // console.log('ArrayView change: Adding usage data for ' + this.graph.vnm);
            this.usageService.addUsageData(this.graph, UsageType.Array);
            // The graph that we're displaying changed so get the new FSCs from the map
            /** @type {?} */
            var fscMap = this.flowsheetsApiService.getFlowSheetSubjectValue();
            this.getFlowSheetsForVisit(fscMap);
            // Get the prior warning for this graph instead of the stale graph
            /** @type {?} */
            var priorWarnings = this.priorWarningsApiService.getPriorWarningSubjectValue();
            this.getPriorWarningsForVisit(priorWarnings);
            // Push the changes
            if (this.ref) {
                this.ref.detectChanges();
            }
        }
    };
    /**
     * @param {?} fscMap
     * @return {?}
     */
    PeraGraphComponent.prototype.getFlowSheetsForVisit = /**
     * @param {?} fscMap
     * @return {?}
     */
    function (fscMap) {
        if (fscMap) {
            /** @type {?} */
            var fsc = fscMap[this.graph.visitId];
            // Update the RI-related fields if necessary
            if (fsc && !(this.flowsheets === fsc) && JSON.stringify(this.flowsheets) !== JSON.stringify(fsc)) {
                // Note this may trigger extra changes based on how browsers handle JSON object order
                this.flowsheets = fsc;
                this.latestRi = fsc[this.flowsheets.length - 1].riScore;
            }
            else if (!fsc && this.flowsheets !== null) {
                // Clear the RI-related fields
                this.flowsheets = [];
                this.latestRi = null;
            }
        }
    };
    /**
     * @param {?} priorWarnings
     * @return {?}
     */
    PeraGraphComponent.prototype.getPriorWarningsForVisit = /**
     * @param {?} priorWarnings
     * @return {?}
     */
    function (priorWarnings) {
        if (priorWarnings) {
            /** @type {?} */
            var pw = priorWarnings[this.graph.visitId];
            // TODO can we set this.priorWarning = pw without the logic below?
            // If we have a prior warning and it's not the same, trigger a change
            if (pw && pw !== this.priorWarning) {
                this.priorWarning = pw;
            }
            else if (!pw) {
                // No prior warning exists, update our prior warning to reflect this
                this.priorWarning = null;
            }
        }
    };
    /**
     * @return {?}
     */
    PeraGraphComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
        // Unsubscribe when the component is destroyed
        if (this.flowSheetMap$ && !this.flowSheetMap$.closed) {
            this.flowSheetMap$.unsubscribe();
        }
        if (this.priorWarningMap$ && !this.priorWarningMap$.closed) {
            this.priorWarningMap$.unsubscribe();
        }
        if (this.toolTipInfoEvent$ && !this.toolTipInfoEvent$.closed) {
            this.toolTipInfoEvent$.unsubscribe();
        }
    };
    PeraGraphComponent.decorators = [
        { type: Component, args: [{
                    selector: 'phlib-pera-graph',
                    template: "<div class=\"ph-pera-graph\"\n     id=\"{{ graph.vnm }}\"\n     (click)=\"graphClicked(graph)\"\n     [ngStyle]=\"style\">\n\n    <phlib-pera-graph-tile *ngIf=\"service.isDisplayingTiles();else displayPeraGraph\" [graph]=\"graph\"\n                           [latestRi]=\"latestRi\" [priorWarning]=\"priorWarning\"\n                           (mouseenter)=\"mouseEnterHandler(po)\"\n                           (mouseleave)=\"mouseLeaveHandler(po)\"\n                           #po=\"ngbPopover\"\n                           class=\"width-adjustment\"\n                           [ngbPopover]=\"popTemplate\"\n                           [autoClose]=\"true\"\n                           popoverTitle=\"Visit Info\"\n                           placement=\"auto\"\n                           triggers=\"manual\"\n                           container='body'>\n              <ng-template #popTemplate>\n                <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n              </ng-template>\n    </phlib-pera-graph-tile>\n\n    <ng-template #displayPeraGraph>\n      <phlib-pera-graph-header class=\"peraGraphHeader\"\n                               [graph]=\"graph\"\n                               [latestRi]=\"latestRi\"\n                               [priorWarning]=\"priorWarning\"></phlib-pera-graph-header>\n      <phlib-chart\n          [graph]=\"graph\"\n          [flowsheets]=\"flowsheets\"\n          class=\"width-adjustment\"\n          (mouseenter)=\"mouseEnterHandler(po)\"\n          (mouseleave)=\"mouseLeaveHandler(po)\"\n          #po=\"ngbPopover\"\n          [ngbPopover]=\"popTemplate\"\n          [autoClose]=\"true\"\n          (shown)=\"isShown(po)\"\n          triggers=\"manual\"\n          popoverTitle=\"Visit Info\"\n          placement=\"auto\"\n          container='body'>\n        </phlib-chart>\n        <ng-template #popTemplate>\n          <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n        </ng-template>\n    </ng-template>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".ph-pera-graph{border:1px solid #000;padding-top:auto;margin-right:5px;background-color:#fff!important;display:inline-flex;position:relative}.width-adjustment{width:inherit}"]
                }] }
    ];
    /** @nocollapse */
    PeraGraphComponent.ctorParameters = function () { return [
        { type: ArrayViewService },
        { type: FlowsheetsApiService },
        { type: PriorWarningsApiService },
        { type: UsageApiService },
        { type: PeraGraphService },
        { type: TooltipService },
        { type: HttpClient },
        { type: ChangeDetectorRef }
    ]; };
    PeraGraphComponent.propDecorators = {
        graph: [{ type: Input }],
        peraGraphWidth: [{ type: Input }],
        peraGraphHeight: [{ type: Input }]
    };
    return PeraGraphComponent;
}());
export { PeraGraphComponent };
if (false) {
    /** @type {?} */
    PeraGraphComponent.prototype.graph;
    /** @type {?} */
    PeraGraphComponent.prototype.peraGraphWidth;
    /** @type {?} */
    PeraGraphComponent.prototype.peraGraphHeight;
    /** @type {?} */
    PeraGraphComponent.prototype.style;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.margin;
    /** @type {?} */
    PeraGraphComponent.prototype.flowsheets;
    /** @type {?} */
    PeraGraphComponent.prototype.priorWarning;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.flowSheetMap$;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.priorWarningMap$;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.toolTipInfoEvent$;
    /** @type {?} */
    PeraGraphComponent.prototype.latestRi;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.isMouseOverPeraGraph;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.tooltip;
    /** @type {?} */
    PeraGraphComponent.prototype.service;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.flowsheetsApiService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.priorWarningsApiService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.usageService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.graphService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.toolTipService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.http;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.ref;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyYS1ncmFwaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1hcnJheS12aWV3LWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvZ3JvdXAvcGVyYS1ncmFwaC9wZXJhLWdyYXBoLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFLUixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNsRSxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUU5RCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRXpELE9BQU8sRUFBQyxvQkFBb0IsRUFBYSxlQUFlLEVBQUUsU0FBUyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDOUYsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sNkRBQTZELENBQUM7QUFJcEc7SUE2QkksNEJBQW1CLE9BQXlCLEVBQ3hCLG9CQUEwQyxFQUMxQyx1QkFBZ0QsRUFDaEQsWUFBNkIsRUFDN0IsWUFBOEIsRUFDOUIsY0FBOEIsRUFDOUIsSUFBZ0IsRUFDaEIsR0FBc0I7UUFQdkIsWUFBTyxHQUFQLE9BQU8sQ0FBa0I7UUFDeEIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQUMxQyw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXlCO1FBQ2hELGlCQUFZLEdBQVosWUFBWSxDQUFpQjtRQUM3QixpQkFBWSxHQUFaLFlBQVksQ0FBa0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFsQmxDLFdBQU0sR0FBRyxFQUFFLENB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Ozs7SUFDeEIsaUNBQThCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QXJyYXlWaWV3U2VydmljZX0gZnJvbSAnLi4vLi4vc2VydmljZS9hcnJheS12aWV3LnNlcnZpY2UnO1xuaW1wb3J0IHtQZXJhR3JhcGhTZXJ2aWNlfSBmcm9tICcuL3NlcnZpY2UvcGVyYS1ncmFwaC5zZXJ2aWNlJztcbmltcG9ydCB7TmdiUG9wb3Zlcn0gZnJvbSAnQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAnO1xuaW1wb3J0IHtIdHRwQ2xpZW50fSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge1Rvb2x0aXBTZXJ2aWNlfSBmcm9tICcuL3NlcnZpY2UvdG9vbHRpcC5zZXJ2aWNlJztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7Rmxvd3NoZWV0c0FwaVNlcnZpY2UsIFBlcmFHcmFwaCwgVXNhZ2VBcGlTZXJ2aWNlLCBVc2FnZVR5cGV9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5JztcbmltcG9ydCB7UHJpb3JXYXJuaW5nc0FwaVNlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2UvcHJpb3Itd2FybmluZ3MvYXBpL3ByaW9yLXdhcm5pbmdzLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7Rmxvd1NoZWV0QmFzZX0gZnJvbSAnbmctY29tbW9uLWxpYnJhcnkvbGliL21vZGVsL0Zsb3dTaGVldEJhc2UnO1xuaW1wb3J0IHtUb29sdGlwSW5mb30gZnJvbSAnLi4vLi4vbW9kZWwvVG9vbHRpcEluZm8nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3BobGliLXBlcmEtZ3JhcGgnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9wZXJhLWdyYXBoLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9wZXJhLWdyYXBoLmNvbXBvbmVudC5jc3MnXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBQZXJhR3JhcGhDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyYXBoOiBQZXJhR3JhcGg7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBwZXJhR3JhcGhXaWR0aDogbnVtYmVyO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcGVyYUdyYXBoSGVpZ2h0OiBudW1iZXI7XG5cbiAgICBwdWJsaWMgc3R5bGU7XG4gICAgcHJpdmF0ZSBtYXJnaW4gPSAxMDtcblxuICAgIHB1YmxpYyBmbG93c2hlZXRzOiBBcnJheTxGbG93U2hlZXRCYXNlPjtcbiAgICBwdWJsaWMgcHJpb3JXYXJuaW5nOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBmbG93U2hlZXRNYXAkOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBwcmlvcldhcm5pbmdNYXAkOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSB0b29sVGlwSW5mb0V2ZW50JDogU3Vic2NyaXB0aW9uO1xuICAgIHB1YmxpYyBsYXRlc3RSaTogbnVtYmVyO1xuICAgIHByaXZhdGUgaXNNb3VzZU92ZXJQZXJhR3JhcGggPSBmYWxzZTtcbiAgICBwcml2YXRlIHRvb2x0aXA6IE5nYlBvcG92ZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgc2VydmljZTogQXJyYXlWaWV3U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGZsb3dzaGVldHNBcGlTZXJ2aWNlOiBGbG93c2hlZXRzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHByaW9yV2FybmluZ3NBcGlTZXJ2aWNlOiBQcmlvcldhcm5pbmdzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHVzYWdlU2VydmljZTogVXNhZ2VBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZ3JhcGhTZXJ2aWNlOiBQZXJhR3JhcGhTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdG9vbFRpcFNlcnZpY2U6IFRvb2x0aXBTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1BlcmFHcmFwaERhdGFGZWVkcygpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvVG9vbFRpcEluZm9FdmVudCgpO1xuICAgICAgICB0aGlzLnN0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMucGVyYUdyYXBoV2lkdGggLSB0aGlzLm1hcmdpbiArICdweCcsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucGVyYUdyYXBoSGVpZ2h0IC0gdGhpcy5tYXJnaW4gKyAncHgnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNhZ2VTZXJ2aWNlLmFkZFVzYWdlRGF0YSh0aGlzLmdyYXBoLCBVc2FnZVR5cGUuQXJyYXkpO1xuICAgICAgICAvLyBNYW5hZ2UgY2hhbmdlIGRldGVjdGlvbiBleHBsaWNpdGx5XG4gICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byB0aGUgaW50ZXJ2YWwgb2JzZXJ2YWJsZXMvc3ViamVjdHMgdGhhdCBwYXNzIGluZm9ybWF0aW9uIHRoZSBQZXJhR3JhcGggbmVlZHNcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSwgdGhpcyBpbmNsdWRlcyBwcmlvciB3YXJuaW5ncyBhbmQgZmxvd3NoZWV0c1xuICAgICAqL1xuICAgIHN1YnNjcmliZVRvUGVyYUdyYXBoRGF0YUZlZWRzKCkge1xuICAgICAgICB0aGlzLmZsb3dTaGVldE1hcCQgPSB0aGlzLmZsb3dzaGVldHNBcGlTZXJ2aWNlLmdldEZsb3dTaGVldFN1YmplY3QoKS5zdWJzY3JpYmUoKGZzY01hcCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZXRGbG93U2hlZXRzRm9yVmlzaXQoZnNjTWFwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wcmlvcldhcm5pbmdNYXAkID0gdGhpcy5wcmlvcldhcm5pbmdzQXBpU2VydmljZS5nZXRQcmlvcldhcm5pbmdTdWJqZWN0KCkuc3Vic2NyaWJlKChwd01hcCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZXRQcmlvcldhcm5pbmdzRm9yVmlzaXQocHdNYXApO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmVUb1Rvb2xUaXBJbmZvRXZlbnQoKSB7XG4gICAgICAgIHRoaXMudG9vbFRpcEluZm9FdmVudCQgPSB0aGlzLnRvb2xUaXBTZXJ2aWNlLnRvb2xUaXBJbmZvVXBkYXRlZCQuc3Vic2NyaWJlKCh0b29sVGlwSW5mbzogVG9vbHRpcEluZm8pID0+IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSB1c2VyIGhhc24ndCBtb3ZlZCBvbnRvIGEgbmV3IGdyYXBoIHdpdGggYSBkaWZmZXJlbnQgZHVyaW5nIHRoZSB0aW1lIHRoYXQgdGhlIGNhbGwgd2FzIG1hZGUgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNb3VzZU92ZXJQZXJhR3JhcGggJiYgdG9vbFRpcEluZm8udmlzaXRJZCA9PT0gdGhpcy5ncmFwaC52aXNpdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZpY2UgdGFrZXMgYSBzZWNvbmQgdG8gcmVzcG9uZCBhbmQgdGhlIHBvcG92ZXIgaXMgbm8gbG9uZ2VyIHRoZXJlLCBkb24ndCB0cnkgdG8gb3BlbiBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaFNlcnZpY2UudG9vbHRpcCA9IHRoaXMudG9vbHRpcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgb25seSBmaXJlcyB3aGVuIHRoZSB1c2VyIHBhc3NlcyB0aGUgbW91c2Ugb3ZlciB0aGUgZ3JhcGggdG8gZ2V0IHRoZSB0b29sdGlwLlxuICAgICAqIEZvciB0aG9zZSBncmFwaHMsIGZvcmNlIGEgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSBzbyB0aGF0IHRoZSBUb29sVGlwIGNvbXBvbmVudCB1cGRhdGVzLlxuICAgICAqL1xuICAgIG1vdXNlRW50ZXJIYW5kbGVyKHBvOiBOZ2JQb3BvdmVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5pc01vdXNlT3ZlclBlcmFHcmFwaCAmJiAhcG8uaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3VzZU92ZXJQZXJhR3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwID0gcG87XG4gICAgICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIGFueSBleGlzdGluZyB0b29sdGlwXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaFNlcnZpY2UuY2xvc2VUb29sVGlwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sVGlwU2VydmljZS51cGRhdGVUb29sVGlwSW5mbyh0aGlzLmdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmlyZXMgd2hlbiB0aGUgdXNlciBwYXNzZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGdyYXBoLCBhbmQgdGhlbiBtb3ZlcyB0aGUgbW91c2Ugb2ZmIG9mIHRoZSBncmFwaFxuICAgICAqIEZvciB0aG9zZSBncmFwaHMsIGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9cbiAgICAgKi9cbiAgICBtb3VzZUxlYXZlSGFuZGxlcihwbzogTmdiUG9wb3Zlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmlzTW91c2VPdmVyUGVyYUdyYXBoID0gZmFsc2U7XG4gICAgICAgIGlmIChwby5pc09wZW4oKSkge1xuICAgICAgICAgICAgcG8uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdyYXBoQ2xpY2tlZChncmFwaDogUGVyYUdyYXBoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAgJiYgdGhpcy50b29sdGlwLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRm9yY2VmdWxseSBjbG9zaW5nIHRvb2x0aXAnKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoU2VydmljZS5ncmFwaENsaWNrZWRFdmVudChncmFwaCk7XG4gICAgICAgIHRoaXMuc2VydmljZS50b2tlblJlZnJlc2gkLm5leHQoKTtcbiAgICB9XG5cbiAgICBpc1Nob3duKHBvOiBOZ2JQb3BvdmVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy50b29sdGlwKSB7XG4gICAgICAgICAgICAvLyBDbG9zaW5nIHRvb2x0aXBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG8uY2xvc2UoKSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIC8vIElmIHRoZSBpdGVtIHNpemUgY2hhbmdlZCwgdXBkYXRlIHN0eWxlXG4gICAgICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMucGVyYUdyYXBoV2lkdGggJiYgY2hhbmdlcy5wZXJhR3JhcGhXaWR0aC5wcmV2aW91c1ZhbHVlICE9PSBjaGFuZ2VzLnBlcmFHcmFwaFdpZHRoLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5wZXJhR3JhcGhXaWR0aCAtIHRoaXMubWFyZ2luICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMucGVyYUdyYXBoSGVpZ2h0IC0gdGhpcy5tYXJnaW4gKyAncHgnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGNoYW5nZWQsIHVwZGF0ZSB0aGUgcmVsYXRlZCBkYXRhIHNvIHRoYXQgd2UncmUgc2hvd2luZyB0aGUgcmlnaHQgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKGNoYW5nZXMgJiZcbiAgICAgICAgICAgIGNoYW5nZXMuZ3JhcGggJiZcbiAgICAgICAgICAgIGNoYW5nZXMuZ3JhcGguY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmdyYXBoLnByZXZpb3VzVmFsdWUgJiZcbiAgICAgICAgICAgICFjaGFuZ2VzLmdyYXBoLmZpcnN0Q2hhbmdlICYmXG4gICAgICAgICAgICBjaGFuZ2VzLmdyYXBoLmN1cnJlbnRWYWx1ZS52aXNpdElkICE9PSBjaGFuZ2VzLmdyYXBoLnByZXZpb3VzVmFsdWUudmlzaXRJZCkge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQXJyYXlWaWV3IGNoYW5nZTogQWRkaW5nIHVzYWdlIGRhdGEgZm9yICcgKyB0aGlzLmdyYXBoLnZubSk7XG4gICAgICAgICAgICB0aGlzLnVzYWdlU2VydmljZS5hZGRVc2FnZURhdGEodGhpcy5ncmFwaCwgVXNhZ2VUeXBlLkFycmF5KTtcblxuICAgICAgICAgICAgLy8gVGhlIGdyYXBoIHRoYXQgd2UncmUgZGlzcGxheWluZyBjaGFuZ2VkIHNvIGdldCB0aGUgbmV3IEZTQ3MgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICBjb25zdCBmc2NNYXAgPSB0aGlzLmZsb3dzaGVldHNBcGlTZXJ2aWNlLmdldEZsb3dTaGVldFN1YmplY3RWYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5nZXRGbG93U2hlZXRzRm9yVmlzaXQoZnNjTWFwKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHJpb3Igd2FybmluZyBmb3IgdGhpcyBncmFwaCBpbnN0ZWFkIG9mIHRoZSBzdGFsZSBncmFwaFxuICAgICAgICAgICAgY29uc3QgcHJpb3JXYXJuaW5ncyA9IHRoaXMucHJpb3JXYXJuaW5nc0FwaVNlcnZpY2UuZ2V0UHJpb3JXYXJuaW5nU3ViamVjdFZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmdldFByaW9yV2FybmluZ3NGb3JWaXNpdChwcmlvcldhcm5pbmdzKTtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIGNoYW5nZXNcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZsb3dTaGVldHNGb3JWaXNpdChmc2NNYXApIHtcbiAgICAgICAgaWYgKGZzY01hcCkge1xuICAgICAgICAgICAgY29uc3QgZnNjID0gZnNjTWFwW3RoaXMuZ3JhcGgudmlzaXRJZF07XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIFJJLXJlbGF0ZWQgZmllbGRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKGZzYyAmJiAhKHRoaXMuZmxvd3NoZWV0cyA9PT0gZnNjKSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLmZsb3dzaGVldHMpICE9PSBKU09OLnN0cmluZ2lmeShmc2MpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGlzIG1heSB0cmlnZ2VyIGV4dHJhIGNoYW5nZXMgYmFzZWQgb24gaG93IGJyb3dzZXJzIGhhbmRsZSBKU09OIG9iamVjdCBvcmRlclxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd3NoZWV0cyA9IGZzYztcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFJpID0gZnNjW3RoaXMuZmxvd3NoZWV0cy5sZW5ndGggLSAxXS5yaVNjb3JlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZnNjICYmIHRoaXMuZmxvd3NoZWV0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBSSS1yZWxhdGVkIGZpZWxkc1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd3NoZWV0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0UmkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UHJpb3JXYXJuaW5nc0ZvclZpc2l0KHByaW9yV2FybmluZ3MpIHtcbiAgICAgICAgaWYgKHByaW9yV2FybmluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHB3ID0gcHJpb3JXYXJuaW5nc1t0aGlzLmdyYXBoLnZpc2l0SWRdO1xuICAgICAgICAgICAgLy8gVE9ETyBjYW4gd2Ugc2V0IHRoaXMucHJpb3JXYXJuaW5nID0gcHcgd2l0aG91dCB0aGUgbG9naWMgYmVsb3c/XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJpb3Igd2FybmluZyBhbmQgaXQncyBub3QgdGhlIHNhbWUsIHRyaWdnZXIgYSBjaGFuZ2VcbiAgICAgICAgICAgIGlmIChwdyAmJiBwdyAhPT0gdGhpcy5wcmlvcldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW9yV2FybmluZyA9IHB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHcpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBwcmlvciB3YXJuaW5nIGV4aXN0cywgdXBkYXRlIG91ciBwcmlvciB3YXJuaW5nIHRvIHJlZmxlY3QgdGhpc1xuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JXYXJuaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVuc3Vic2NyaWJlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWRcbiAgICAgICAgaWYgKHRoaXMuZmxvd1NoZWV0TWFwJCAmJiAhdGhpcy5mbG93U2hlZXRNYXAkLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5mbG93U2hlZXRNYXAkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJpb3JXYXJuaW5nTWFwJCAmJiAhdGhpcy5wcmlvcldhcm5pbmdNYXAkLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmlvcldhcm5pbmdNYXAkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9vbFRpcEluZm9FdmVudCQgJiYgIXRoaXMudG9vbFRpcEluZm9FdmVudCQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xUaXBJbmZvRXZlbnQkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=