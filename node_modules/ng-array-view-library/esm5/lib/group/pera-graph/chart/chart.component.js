/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input } from '@angular/core';
import * as moment_ from 'moment-timezone';
import { ArrayViewService } from '../../../service/array-view.service';
import { ChartService, DateService } from 'ng-common-library';
/** @type {?} */
var Highcharts = require('highcharts');
// The JavaScript compiler gives a weird "moment cannot be used as a namespace" type of error
// This is the workaround...
/** @type {?} */
var moment = moment_;
var ChartComponent = /** @class */ (function () {
    function ChartComponent(dateService, chartService, arrayViewService, ref) {
        this.dateService = dateService;
        this.chartService = chartService;
        this.arrayViewService = arrayViewService;
        this.ref = ref;
        this.Highcharts = Highcharts;
        this.X_AXIS_DAYS = 5;
        this.DAY_IN_MILLISECONDS = 86400000;
        this.minRiScore = 0;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
    }
    /**
     * @return {?}
     */
    ChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // Manage change detection explicitly
        this.ref.detach();
        // Get the series
        this.series = this.getChartSeries();
        // Build the chart options
        this.chartOptions = this.getChartOptions();
        // Trigger change detection
        this.ref.detectChanges();
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        // Ensure that a chart already exists
        if (this.Highcharts && this.chartOptions) {
            // Fetch the series using the latest flowsheet information
            this.series = this.getChartSeries();
            // If the series is different
            if (this.series !== this.chartOptions.series) {
                this.updateChart();
                this.chartOptions = tslib_1.__assign({}, this.chartOptions);
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        }
    };
    /**
     * Updates the chart
     */
    /**
     * Updates the chart
     * @return {?}
     */
    ChartComponent.prototype.updateChart = /**
     * Updates the chart
     * @return {?}
     */
    function () {
        this.chartOptions.series = this.series;
        this.updateXAxis();
        this.updateYAxis();
    };
    /**
     * Updates the pieces of the Y axis that need updating
     */
    /**
     * Updates the pieces of the Y axis that need updating
     * @return {?}
     */
    ChartComponent.prototype.updateYAxis = /**
     * Updates the pieces of the Y axis that need updating
     * @return {?}
     */
    function () {
        /** @type {?} */
        var minYAxisTick = this.chartService.getMinYAxisTick(this.minRiScore);
        // If the min Y axis value would change, update it
        if (this.chartOptions.yAxis[0].min !== minYAxisTick) {
            this.chartOptions.yAxis[0].min = minYAxisTick;
            this.chartOptions.yAxis[0].plotLines = this.chartService.createZeroAxisLine(this.minRiScore);
        }
    };
    /**
     * Updates the pieces of the X axis that need updating
     */
    /**
     * Updates the pieces of the X axis that need updating
     * @return {?}
     */
    ChartComponent.prototype.updateXAxis = /**
     * Updates the pieces of the X axis that need updating
     * @return {?}
     */
    function () {
        this.chartOptions.xAxis = this.getXaxis();
    };
    /**
     * Returns the chart options
     */
    /**
     * Returns the chart options
     * @return {?}
     */
    ChartComponent.prototype.getChartOptions = /**
     * Returns the chart options
     * @return {?}
     */
    function () {
        return {
            chart: {
                type: 'line',
                spacing: [2, 0, 0, 0],
                marginLeft: 18,
                marginRight: 2,
                plotBackgroundColor: 'white',
                reflow: false,
                animation: false,
                alignTicks: false
            },
            tooltip: {
                enabled: false,
                animation: false
            },
            plotOptions: {
                series: {
                    color: '#848484',
                    turboThreshold: 0,
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                },
                line: {
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                }
            },
            credits: {
                enabled: false
            },
            legend: {
                enabled: false
            },
            title: {
                text: ''
            },
            xAxis: this.getXaxis(),
            yAxis: this.getYaxis(),
            series: this.series
        };
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.getXaxis = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var xAxis = [];
        xAxis.push({
            type: 'datetime',
            startOnTick: false,
            endOnTick: false,
            tickInterval: this.graph.isDischarged ? null : this.DAY_IN_MILLISECONDS,
            gridLineWidth: 1,
            plotLines: this.chartService.updateAlertPlotLine(this.graph),
            title: {
                text: ' '
            },
            labels: {
                distance: 20,
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                formatter: function () {
                    return moment(this.value).utcOffset(0).format('MM/DD');
                },
                step: 1
            },
            min: this.getMinXAxisValue(),
            max: this.getMaxXAxisValue(),
        });
        return xAxis;
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.getMaxXAxisValue = /**
     * @return {?}
     */
    function () {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone);
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.getMinXAxisValue = /**
     * @return {?}
     */
    function () {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone) - this.X_AXIS_DAYS * this.DAY_IN_MILLISECONDS;
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.getYaxis = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var yAxis = [];
        yAxis.push({
            title: {
                text: ' '
            },
            labels: {
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                padding: 1,
                align: 'center'
            },
            offset: -12,
            //     gridLineColor : colorHealthScoreGridLine,
            gridLineWidth: 1,
            min: this.chartService.getMinYAxisTick(this.minRiScore),
            max: 100,
            plotLines: this.chartService.createZeroAxisLine(this.minRiScore),
            tickPositioner: function (min, max) {
                /** @type {?} */
                var tick = min;
                /** @type {?} */
                var ticks = [];
                while (tick <= max) {
                    ticks.push(tick);
                    tick += 20;
                }
                return ticks;
            }
        });
        return yAxis;
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.getChartSeries = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var series = [];
        series.push({
            name: '',
            data: this.getDataPoints(this.flowsheets),
            showInLegend: false,
            turboThreshold: 0,
            color: {
                linearGradient: { x1: 0, x2: 1, y1: 0, y2: 0 },
                stops: this.getArrayOfLocationChanges(this.flowsheets)
            },
            marker: {
                enabled: (this.flowsheets && this.flowsheets.length === 1) ? true : false,
                color: (this.flowsheets && this.flowsheets.length === 1) ? this.chartService.getMarkerColor(this.flowsheets[0].unitType) : null,
                radius: 1.5
            }
        });
        return series;
    };
    /**
     * @param {?} fscList
     * @return {?}
     */
    ChartComponent.prototype.getArrayOfLocationChanges = /**
     * @param {?} fscList
     * @return {?}
     */
    function (fscList) {
        var _this = this;
        /** @type {?} */
        var range = this.maxRecordedDt - this.minRecordedDt;
        /** @type {?} */
        var colors = [[0, 'black']];
        /** @type {?} */
        var color = 'black';
        /** @type {?} */
        var unitType = null;
        /** @type {?} */
        var xval = 0;
        if (fscList && range > 0) {
            fscList.forEach(function (fsc) {
                // If the unit type changed
                if (fsc.unitType !== unitType) {
                    // Get the percentage across the X axis by recorded date
                    xval = (fsc.key.recordedDt - _this.minRecordedDt) / range;
                    // add an entry just prior to this point to smooth the gradient
                    colors.push([xval - .0001, color]);
                    // The the appropriate color for this unitType
                    color = _this.chartService.getMarkerColor(fsc.unitType);
                    // Push the change in color
                    colors.push([xval, color]);
                    // Remember the current unit type
                    unitType = fsc.unitType;
                }
            });
        }
        return colors;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ChartComponent.prototype.getDataPoints = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var dataPoints = [];
        // Reset the variables
        this.minRiScore = 100;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
        // If we have data
        if (data) {
            data.forEach(function (fsc) {
                dataPoints.push([_this.dateService.translateDate(fsc.key.recordedDt, _this.graph.timeZone), fsc.riScore + (Math.random() / 1000)]);
                // Keep track of the extreme values - they are used elsewhere
                _this.minRecordedDt = (_this.minRecordedDt > fsc.key.recordedDt) ? fsc.key.recordedDt : _this.minRecordedDt;
                _this.maxRecordedDt = (_this.maxRecordedDt < fsc.key.recordedDt) ? fsc.key.recordedDt : _this.maxRecordedDt;
                _this.minRiScore = (_this.minRiScore > fsc.riScore) ? fsc.riScore : _this.minRiScore;
            });
        }
        return dataPoints;
    };
    /**
     * @return {?}
     */
    ChartComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
    };
    ChartComponent.decorators = [
        { type: Component, args: [{
                    selector: 'phlib-chart',
                    template: "<div class=\"ph-graph\" *ngIf=\"!flowsheets || flowsheets.length != 0\">\n  <highcharts-chart class=\"ph-hc\"\n                    [Highcharts]=\"Highcharts\"\n                    [options]=\"chartOptions\"\n  ></highcharts-chart>\n</div>\n\n<div class=\"insufficient-data ph-hc\" *ngIf=\"flowsheets && flowsheets.length == 0\">\n  <div class=\"insufficient-data-text\">Insufficient data received to generate RI graph\n    <div *ngIf=\"graph && graph.activeWarning\" class=\"insufficient-data-text\">\n      <br>\n      Warning state generated by prior visit\n    </div>\n  </div>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".ph-graph{width:99%;height:83%;position:absolute;top:17%;left:1px;cursor:pointer}.ph-hc{width:100%!important;position:absolute!important;height:100%!important}.insufficient-data{font-size:.7em;font-weight:700;color:#60606a;padding-left:5%;padding-right:5%;padding-top:13%;display:flex;margin:auto}.insufficient-data-text{margin:auto}"]
                }] }
    ];
    /** @nocollapse */
    ChartComponent.ctorParameters = function () { return [
        { type: DateService },
        { type: ChartService },
        { type: ArrayViewService },
        { type: ChangeDetectorRef }
    ]; };
    ChartComponent.propDecorators = {
        flowsheets: [{ type: Input }],
        graph: [{ type: Input }],
        currentTimestamp: [{ type: Input }]
    };
    return ChartComponent;
}());
export { ChartComponent };
if (false) {
    /** @type {?} */
    ChartComponent.prototype.flowsheets;
    /** @type {?} */
    ChartComponent.prototype.graph;
    /** @type {?} */
    ChartComponent.prototype.currentTimestamp;
    /** @type {?} */
    ChartComponent.prototype.Highcharts;
    /** @type {?} */
    ChartComponent.prototype.chartOptions;
    /** @type {?} */
    ChartComponent.prototype.X_AXIS_DAYS;
    /** @type {?} */
    ChartComponent.prototype.DAY_IN_MILLISECONDS;
    /** @type {?} */
    ChartComponent.prototype.minRiScore;
    /** @type {?} */
    ChartComponent.prototype.minRecordedDt;
    /** @type {?} */
    ChartComponent.prototype.maxRecordedDt;
    /** @type {?} */
    ChartComponent.prototype.series;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.dateService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.chartService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.arrayViewService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.ref;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctYXJyYXktdmlldy1saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL2dyb3VwL3BlcmEtZ3JhcGgvY2hhcnQvY2hhcnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFJTixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEtBQUssT0FBTyxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLHFDQUFxQyxDQUFDO0FBRXJFLE9BQU8sRUFBQyxZQUFZLEVBQUUsV0FBVyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7O0lBSXRELFVBQVUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDOzs7O0lBSWxDLE1BQU0sR0FBRyxPQUFPO0FBRXRCO0lBNEJFLHdCQUFvQixXQUF3QixFQUN4QixZQUEwQixFQUMxQixnQkFBa0MsRUFDbEMsR0FBc0I7UUFIdEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQWYxQyxlQUFVLEdBQUcsVUFBVSxDQUFDO1FBR3hCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLHdCQUFtQixHQUFHLFFBQVEsQ0FBQztRQUUvQixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2Ysa0JBQWEsR0FBRyxxQkFBcUIsQ0FBQztRQUN0QyxrQkFBYSxHQUFHLENBQUMsQ0FBQztJQVFsQixDQUFDOzs7O0lBRUQsaUNBQVE7OztJQUFSO1FBQ0UscUNBQXFDO1FBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDbEIsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQyxNQUFN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dEMsdUNBQWtCOztJQUVsQixnQ0FBTzs7Ozs7SUFFSyxxQ0FBZ0M7Ozs7O0lBQ2hDLHNDQUFrQzs7Ozs7SUFDbEMsMENBQTBDOzs7OztJQUMxQyw2QkFBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LXRpbWV6b25lJztcbmltcG9ydCB7QXJyYXlWaWV3U2VydmljZX0gZnJvbSAnLi4vLi4vLi4vc2VydmljZS9hcnJheS12aWV3LnNlcnZpY2UnO1xuaW1wb3J0IHtQZXJhR3JhcGh9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5L2xpYi9tb2RlbC9QZXJhR3JhcGgnO1xuaW1wb3J0IHtDaGFydFNlcnZpY2UsIERhdGVTZXJ2aWNlfSBmcm9tICduZy1jb21tb24tbGlicmFyeSc7XG5pbXBvcnQge0Zsb3dTaGVldEJhc2V9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5L2xpYi9tb2RlbC9GbG93U2hlZXRCYXNlJztcblxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xuY29uc3QgSGlnaGNoYXJ0cyA9IHJlcXVpcmUoJ2hpZ2hjaGFydHMnKTtcblxuLy8gVGhlIEphdmFTY3JpcHQgY29tcGlsZXIgZ2l2ZXMgYSB3ZWlyZCBcIm1vbWVudCBjYW5ub3QgYmUgdXNlZCBhcyBhIG5hbWVzcGFjZVwiIHR5cGUgb2YgZXJyb3Jcbi8vIFRoaXMgaXMgdGhlIHdvcmthcm91bmQuLi5cbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3BobGliLWNoYXJ0JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2NoYXJ0LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vY2hhcnQuY29tcG9uZW50LmNzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDaGFydENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKVxuICBmbG93c2hlZXRzOiBBcnJheTxGbG93U2hlZXRCYXNlPjtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgZ3JhcGg6IFBlcmFHcmFwaDtcblxuICBASW5wdXQoKVxuICBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XG5cbiAgSGlnaGNoYXJ0cyA9IEhpZ2hjaGFydHM7XG4gIGNoYXJ0T3B0aW9ucztcblxuICBYX0FYSVNfREFZUyA9IDU7XG4gIERBWV9JTl9NSUxMSVNFQ09ORFMgPSA4NjQwMDAwMDtcblxuICBtaW5SaVNjb3JlID0gMDtcbiAgbWluUmVjb3JkZWREdCA9IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTtcbiAgbWF4UmVjb3JkZWREdCA9IDA7XG5cbiAgc2VyaWVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZVNlcnZpY2U6IERhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIGNoYXJ0U2VydmljZTogQ2hhcnRTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIGFycmF5Vmlld1NlcnZpY2U6IEFycmF5Vmlld1NlcnZpY2UsXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gTWFuYWdlIGNoYW5nZSBkZXRlY3Rpb24gZXhwbGljaXRseVxuICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgIC8vIEdldCB0aGUgc2VyaWVzXG4gICAgdGhpcy5zZXJpZXMgPSB0aGlzLmdldENoYXJ0U2VyaWVzKCk7XG4gICAgLy8gQnVpbGQgdGhlIGNoYXJ0IG9wdGlvbnNcbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCk7XG4gICAgLy8gVHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgYSBjaGFydCBhbHJlYWR5IGV4aXN0c1xuICAgIGlmICh0aGlzLkhpZ2hjaGFydHMgJiYgdGhpcy5jaGFydE9wdGlvbnMpIHtcbiAgICAgIC8vIEZldGNoIHRoZSBzZXJpZXMgdXNpbmcgdGhlIGxhdGVzdCBmbG93c2hlZXQgaW5mb3JtYXRpb25cbiAgICAgIHRoaXMuc2VyaWVzID0gdGhpcy5nZXRDaGFydFNlcmllcygpO1xuICAgICAgLy8gSWYgdGhlIHNlcmllcyBpcyBkaWZmZXJlbnRcbiAgICAgIGlmICh0aGlzLnNlcmllcyAhPT0gdGhpcy5jaGFydE9wdGlvbnMuc2VyaWVzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTtcbiAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMgPSB7Li4udGhpcy5jaGFydE9wdGlvbnN9O1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICB0aGlzLnJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2hhcnRcbiAgICovXG4gIHVwZGF0ZUNoYXJ0KCkge1xuICAgIHRoaXMuY2hhcnRPcHRpb25zLnNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgIHRoaXMudXBkYXRlWEF4aXMoKTtcbiAgICB0aGlzLnVwZGF0ZVlBeGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGllY2VzIG9mIHRoZSBZIGF4aXMgdGhhdCBuZWVkIHVwZGF0aW5nXG4gICAqL1xuICB1cGRhdGVZQXhpcygpIHtcbiAgICBjb25zdCBtaW5ZQXhpc1RpY2sgPSB0aGlzLmNoYXJ0U2VydmljZS5nZXRNaW5ZQXhpc1RpY2sodGhpcy5taW5SaVNjb3JlKTtcbiAgICAvLyBJZiB0aGUgbWluIFkgYXhpcyB2YWx1ZSB3b3VsZCBjaGFuZ2UsIHVwZGF0ZSBpdFxuICAgIGlmICh0aGlzLmNoYXJ0T3B0aW9ucy55QXhpc1swXS5taW4gIT09IG1pbllBeGlzVGljaykge1xuICAgICAgdGhpcy5jaGFydE9wdGlvbnMueUF4aXNbMF0ubWluID0gbWluWUF4aXNUaWNrO1xuICAgICAgdGhpcy5jaGFydE9wdGlvbnMueUF4aXNbMF0ucGxvdExpbmVzID0gdGhpcy5jaGFydFNlcnZpY2UuY3JlYXRlWmVyb0F4aXNMaW5lKHRoaXMubWluUmlTY29yZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBpZWNlcyBvZiB0aGUgWCBheGlzIHRoYXQgbmVlZCB1cGRhdGluZ1xuICAgKi9cbiAgdXBkYXRlWEF4aXMoKSB7XG4gICAgdGhpcy5jaGFydE9wdGlvbnMueEF4aXMgPSB0aGlzLmdldFhheGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hhcnQgb3B0aW9uc1xuICAgKi9cbiAgZ2V0Q2hhcnRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydDoge1xuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIHNwYWNpbmc6IFsyLCAwLCAwLCAwXSxcbiAgICAgICAgbWFyZ2luTGVmdDogMTgsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAyLFxuICAgICAgICBwbG90QmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICByZWZsb3c6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgICBhbGlnblRpY2tzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICBjb2xvcjogJyM4NDg0ODQnLFxuICAgICAgICAgIHR1cmJvVGhyZXNob2xkOiAwLFxuICAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlTW91c2VUcmFja2luZzogZmFsc2UsXG4gICAgICAgICAgc3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgIHNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgdGV4dFNoYWRvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgICAgIGVuYWJsZU1vdXNlVHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgIHN0aWNreVRyYWNraW5nOiBmYWxzZSxcbiAgICAgICAgICBzaGFkb3c6IGZhbHNlLFxuICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHRleHRTaGFkb3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlZGl0czoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6ICcnXG4gICAgICB9LFxuICAgICAgeEF4aXM6IHRoaXMuZ2V0WGF4aXMoKSxcbiAgICAgIHlBeGlzOiB0aGlzLmdldFlheGlzKCksXG4gICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzXG4gICAgfTtcbiAgfVxuXG4gIGdldFhheGlzKCkge1xuICAgIGNvbnN0IHhBeGlzID0gW107XG4gICAgeEF4aXMucHVzaCh7XG4gICAgICB0eXBlOiAnZGF0ZXRpbWUnLFxuICAgICAgc3RhcnRPblRpY2s6IGZhbHNlLFxuICAgICAgZW5kT25UaWNrOiBmYWxzZSxcbiAgICAgIHRpY2tJbnRlcnZhbDogdGhpcy5ncmFwaC5pc0Rpc2NoYXJnZWQgPyBudWxsIDogdGhpcy5EQVlfSU5fTUlMTElTRUNPTkRTLFxuICAgICAgZ3JpZExpbmVXaWR0aDogMSxcbiAgICAgIHBsb3RMaW5lczogdGhpcy5jaGFydFNlcnZpY2UudXBkYXRlQWxlcnRQbG90TGluZSh0aGlzLmdyYXBoKSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6ICcgJ1xuICAgICAgfSxcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBkaXN0YW5jZTogMjAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcuNmVtJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMudmFsdWUpLnV0Y09mZnNldCgwKS5mb3JtYXQoJ01NL0REJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IDFcbiAgICAgIH0sXG4gICAgICBtaW46IHRoaXMuZ2V0TWluWEF4aXNWYWx1ZSgpLFxuICAgICAgbWF4OiB0aGlzLmdldE1heFhBeGlzVmFsdWUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4geEF4aXM7XG4gIH1cblxuICBnZXRNYXhYQXhpc1ZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5ncmFwaC5kaXNjaGFyZ2VkKSA/IG51bGwgOiB0aGlzLmRhdGVTZXJ2aWNlLnRyYW5zbGF0ZURhdGUodGhpcy5hcnJheVZpZXdTZXJ2aWNlLmdldEN1cnJlbnRUaW1lc3RhbXAoKSwgdGhpcy5ncmFwaC50aW1lWm9uZSk7XG4gIH1cblxuICBnZXRNaW5YQXhpc1ZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5ncmFwaC5kaXNjaGFyZ2VkKSA/IG51bGwgOiB0aGlzLmRhdGVTZXJ2aWNlLnRyYW5zbGF0ZURhdGUoXG4gICAgICB0aGlzLmFycmF5Vmlld1NlcnZpY2UuZ2V0Q3VycmVudFRpbWVzdGFtcCgpLCB0aGlzLmdyYXBoLnRpbWVab25lKSAtIHRoaXMuWF9BWElTX0RBWVMgKiB0aGlzLkRBWV9JTl9NSUxMSVNFQ09ORFM7XG4gIH1cblxuICBnZXRZYXhpcygpIHtcbiAgICBjb25zdCB5QXhpcyA9IFtdO1xuICAgIHlBeGlzLnB1c2goe1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJyAnXG4gICAgICB9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcuNmVtJ1xuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6IC0xMixcbiAgICAgIC8vICAgICBncmlkTGluZUNvbG9yIDogY29sb3JIZWFsdGhTY29yZUdyaWRMaW5lLFxuICAgICAgZ3JpZExpbmVXaWR0aDogMSxcbiAgICAgIG1pbjogdGhpcy5jaGFydFNlcnZpY2UuZ2V0TWluWUF4aXNUaWNrKHRoaXMubWluUmlTY29yZSksXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHBsb3RMaW5lczogdGhpcy5jaGFydFNlcnZpY2UuY3JlYXRlWmVyb0F4aXNMaW5lKHRoaXMubWluUmlTY29yZSksXG4gICAgICB0aWNrUG9zaXRpb25lcjogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG5cbiAgICAgICAgbGV0IHRpY2sgPSBtaW47XG4gICAgICAgIGNvbnN0IHRpY2tzID0gW107XG5cbiAgICAgICAgd2hpbGUgKHRpY2sgPD0gbWF4KSB7XG4gICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgICB0aWNrICs9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHlBeGlzO1xuICB9XG5cbiAgZ2V0Q2hhcnRTZXJpZXMoKSB7XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgc2VyaWVzLnB1c2goe1xuICAgICAgbmFtZTogJycsXG4gICAgICBkYXRhOiB0aGlzLmdldERhdGFQb2ludHModGhpcy5mbG93c2hlZXRzKSxcbiAgICAgIHNob3dJbkxlZ2VuZDogZmFsc2UsXG4gICAgICB0dXJib1RocmVzaG9sZDogMCxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGxpbmVhckdyYWRpZW50OiB7eDE6IDAsIHgyOiAxLCB5MTogMCwgeTI6IDB9LFxuICAgICAgICBzdG9wczogdGhpcy5nZXRBcnJheU9mTG9jYXRpb25DaGFuZ2VzKHRoaXMuZmxvd3NoZWV0cylcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZDogKHRoaXMuZmxvd3NoZWV0cyAmJiB0aGlzLmZsb3dzaGVldHMubGVuZ3RoID09PSAxKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgY29sb3I6ICh0aGlzLmZsb3dzaGVldHMgJiYgdGhpcy5mbG93c2hlZXRzLmxlbmd0aCA9PT0gMSkgPyB0aGlzLmNoYXJ0U2VydmljZS5nZXRNYXJrZXJDb2xvcih0aGlzLmZsb3dzaGVldHNbMF0udW5pdFR5cGUpIDogbnVsbCxcbiAgICAgICAgcmFkaXVzOiAxLjVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWVzO1xuICB9XG5cbiAgZ2V0QXJyYXlPZkxvY2F0aW9uQ2hhbmdlcyhmc2NMaXN0KSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLm1heFJlY29yZGVkRHQgLSB0aGlzLm1pblJlY29yZGVkRHQ7XG4gICAgY29uc3QgY29sb3JzID0gW1swLCAnYmxhY2snXV07XG4gICAgbGV0IGNvbG9yID0gJ2JsYWNrJztcbiAgICBsZXQgdW5pdFR5cGUgPSBudWxsO1xuICAgIGxldCB4dmFsID0gMDtcblxuICAgIGlmIChmc2NMaXN0ICYmIHJhbmdlID4gMCkge1xuICAgICAgZnNjTGlzdC5mb3JFYWNoKChmc2MpID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIHVuaXQgdHlwZSBjaGFuZ2VkXG4gICAgICAgIGlmIChmc2MudW5pdFR5cGUgIT09IHVuaXRUeXBlKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBwZXJjZW50YWdlIGFjcm9zcyB0aGUgWCBheGlzIGJ5IHJlY29yZGVkIGRhdGVcbiAgICAgICAgICB4dmFsID0gKGZzYy5rZXkucmVjb3JkZWREdCAtIHRoaXMubWluUmVjb3JkZWREdCkgLyByYW5nZTtcbiAgICAgICAgICAvLyBhZGQgYW4gZW50cnkganVzdCBwcmlvciB0byB0aGlzIHBvaW50IHRvIHNtb290aCB0aGUgZ3JhZGllbnRcbiAgICAgICAgICBjb2xvcnMucHVzaChbeHZhbCAtIC4wMDAxLCBjb2xvcl0pO1xuICAgICAgICAgIC8vIFRoZSB0aGUgYXBwcm9wcmlhdGUgY29sb3IgZm9yIHRoaXMgdW5pdFR5cGVcbiAgICAgICAgICBjb2xvciA9IHRoaXMuY2hhcnRTZXJ2aWNlLmdldE1hcmtlckNvbG9yKGZzYy51bml0VHlwZSk7XG4gICAgICAgICAgLy8gUHVzaCB0aGUgY2hhbmdlIGluIGNvbG9yXG4gICAgICAgICAgY29sb3JzLnB1c2goW3h2YWwsIGNvbG9yXSk7XG4gICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgdW5pdCB0eXBlXG4gICAgICAgICAgdW5pdFR5cGUgPSBmc2MudW5pdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcnM7XG4gIH1cblxuICBnZXREYXRhUG9pbnRzKGRhdGEpIHtcbiAgICBjb25zdCBkYXRhUG9pbnRzID0gW107XG4gICAgLy8gUmVzZXQgdGhlIHZhcmlhYmxlc1xuICAgIHRoaXMubWluUmlTY29yZSA9IDEwMDtcbiAgICB0aGlzLm1pblJlY29yZGVkRHQgPSA5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XG4gICAgdGhpcy5tYXhSZWNvcmRlZER0ID0gMDtcblxuICAgIC8vIElmIHdlIGhhdmUgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhLmZvckVhY2goKGZzYykgPT4ge1xuICAgICAgICBkYXRhUG9pbnRzLnB1c2goW3RoaXMuZGF0ZVNlcnZpY2UudHJhbnNsYXRlRGF0ZShmc2Mua2V5LnJlY29yZGVkRHQsIHRoaXMuZ3JhcGgudGltZVpvbmUpLCBmc2MucmlTY29yZSArIChNYXRoLnJhbmRvbSgpIC8gMTAwMCldKTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZXh0cmVtZSB2YWx1ZXMgLSB0aGV5IGFyZSB1c2VkIGVsc2V3aGVyZVxuICAgICAgICB0aGlzLm1pblJlY29yZGVkRHQgPSAodGhpcy5taW5SZWNvcmRlZER0ID4gZnNjLmtleS5yZWNvcmRlZER0KSA/IGZzYy5rZXkucmVjb3JkZWREdCA6IHRoaXMubWluUmVjb3JkZWREdDtcbiAgICAgICAgdGhpcy5tYXhSZWNvcmRlZER0ID0gKHRoaXMubWF4UmVjb3JkZWREdCA8IGZzYy5rZXkucmVjb3JkZWREdCkgPyBmc2Mua2V5LnJlY29yZGVkRHQgOiB0aGlzLm1heFJlY29yZGVkRHQ7XG4gICAgICAgIHRoaXMubWluUmlTY29yZSA9ICh0aGlzLm1pblJpU2NvcmUgPiBmc2MucmlTY29yZSkgPyBmc2MucmlTY29yZSA6IHRoaXMubWluUmlTY29yZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVBvaW50cztcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYuZGV0YWNoKCk7XG4gICAgICB0aGlzLnJlZiA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iXX0=