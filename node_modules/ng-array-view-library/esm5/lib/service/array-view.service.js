/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import * as moment_ from 'moment-timezone';
import { ArrayViewConfigService } from './array-view-config.service';
import { DateService, FlowsheetsApiService, PeragraphApiService } from 'ng-common-library';
import { FilterQueryRestService, FilterService, GroupService, SortService } from 'ng-filters-library';
import { BehaviorSubject, forkJoin, of, Subject } from 'rxjs';
import { ChartTitleChoices } from './chartTitleEnum';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./array-view-config.service";
import * as i3 from "ng-filters-library";
import * as i4 from "ng-common-library";
// The JavaScript compiler gives a weird "moment cannot be used as a namespace" type of error
// This is the workaround...
/** @type {?} */
var moment = moment_;
var ArrayViewService = /** @class */ (function () {
    function ArrayViewService(http, configService, filterService, filterQueryRestService, flowsheetsApiService, peragraphApiService, sortService, groupService, dateService) {
        var _this = this;
        this.http = http;
        this.configService = configService;
        this.filterService = filterService;
        this.filterQueryRestService = filterQueryRestService;
        this.flowsheetsApiService = flowsheetsApiService;
        this.peragraphApiService = peragraphApiService;
        this.sortService = sortService;
        this.groupService = groupService;
        this.dateService = dateService;
        // The possible chart title selections
        this.titleChoices = [
            {
                description: ChartTitleChoices.VNM,
                returnFunc: function (peraGraph) {
                    return peraGraph.vnm;
                }
            },
            {
                description: ChartTitleChoices.ADMIT_DATE,
                returnFunc: function (peraGraph) {
                    if (peraGraph && peraGraph.timeZone && peraGraph.admitDate) {
                        return _this.dateService.getDateFormat(peraGraph.timeZone, peraGraph.admitDate, 'MM/DD/YY HH:mm z');
                    }
                    return '';
                }
            },
            {
                description: ChartTitleChoices.MRN,
                returnFunc: function (peraGraph) {
                    return peraGraph.patient.medicalRecordNumber;
                }
            },
            {
                description: ChartTitleChoices.PATIENT_NAME,
                returnFunc: function (peraGraph) {
                    if (peraGraph.vipIndicator) {
                        return peraGraph.patient.aliasLastName + ', ' + peraGraph.patient.aliasFirstName;
                    }
                    else {
                        return peraGraph.displayName;
                    }
                }
            },
            {
                description: ChartTitleChoices.LOCATION,
                returnFunc: function (peraGraph) {
                    return peraGraph.unitId + '-' + peraGraph.room + '-' + peraGraph.bed;
                }
            },
            {
                description: ChartTitleChoices.ANONYMOUS,
                returnFunc: function (peraGraph) {
                    return 'Chart ' + peraGraph.anonymous;
                }
            }
        ];
        // Current chart title selection - defaults to Patient Name
        this.selectedChartTitle = {
            description: ChartTitleChoices.PATIENT_NAME,
            returnFunc: function (peraGraph) {
                return peraGraph.displayName;
            }
        };
        // Subject for the title selection
        this.chartTitleSubject$ = new BehaviorSubject(this.selectedChartTitle);
        this.maxGraphCountPerGroup = 50;
        this.maxGraphsInDom = 150;
        this.currentTimestamp = null;
        this.displayTiles = false;
        this.peraGraphDefaultHeight = 145;
        this.peraGraphDefaultWidth = 185;
        this.peraGraphTileDefault = 75;
        this.peraGraphHeight = this.peraGraphDefaultHeight;
        this.peraGraphWidth = this.peraGraphDefaultWidth;
        this.startedRefresh$ = new Subject();
        this.completedRefresh$ = new Subject();
        this.tokenRefresh$ = new Subject();
    }
    /**
     * runs the peragraph through all the filters and returns true if none of them return false
     * @param peraGraph - peragraph to evaluate
     * @param filters - object of filter functions
     */
    /**
     * runs the peragraph through all the filters and returns true if none of them return false
     * @param {?} peraGraph - peragraph to evaluate
     * @param {?} filters - object of filter functions
     * @return {?}
     */
    ArrayViewService.prototype.filterPeragraph = /**
     * runs the peragraph through all the filters and returns true if none of them return false
     * @param {?} peraGraph - peragraph to evaluate
     * @param {?} filters - object of filter functions
     * @return {?}
     */
    function (peraGraph, filters) {
        // return true if filter object has no properties
        if ((Object.keys(filters).length === 0 && filters.constructor === Object)) {
            return true;
        }
        else {
            // traverse filter object and test peragraph against each filter until one returns false
            for (var filter in filters) {
                if (filters.hasOwnProperty(filter)) {
                    if (!(filters[filter](peraGraph))) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    /**
     * limit the number of groups to load open on application of filtering/sorting/grouping based on the number of graphs in the dom
     * @param peraGraphs - graphs to make count based off of
     */
    /**
     * limit the number of groups to load open on application of filtering/sorting/grouping based on the number of graphs in the dom
     * @param {?} peraGraphs - graphs to make count based off of
     * @return {?}
     */
    ArrayViewService.prototype.calculateNumberOfGroupsToShow = /**
     * limit the number of groups to load open on application of filtering/sorting/grouping based on the number of graphs in the dom
     * @param {?} peraGraphs - graphs to make count based off of
     * @return {?}
     */
    function (peraGraphs) {
        var e_1, _a, e_2, _b;
        /** @type {?} */
        var groupsToShow = 0;
        /** @type {?} */
        var graphCount = 0;
        /** @type {?} */
        var expanded = true;
        /** @type {?} */
        var numOfGroupsWithGraphs = 0;
        try {
            // for each group, count the number of graphs in that group, capped at the maxGraphsPerGroup variable
            // once the graphs exceed the maxGraphs in dom value return the number of groupstoShow to be applied to groups
            for (var _c = tslib_1.__values(this.groupService.groupSubject$.value), _d = _c.next(); !_d.done; _d = _c.next()) {
                var group = _d.value;
                /** @type {?} */
                var groupGraphCount = 0;
                // helper variable for tracking how many groups have graphs
                /** @type {?} */
                var groupIsFresh = true;
                try {
                    for (var peraGraphs_1 = tslib_1.__values(peraGraphs), peraGraphs_1_1 = peraGraphs_1.next(); !peraGraphs_1_1.done; peraGraphs_1_1 = peraGraphs_1.next()) {
                        var peraGraph = peraGraphs_1_1.value;
                        if (group.laneFunction(peraGraph)) {
                            if (groupIsFresh) {
                                numOfGroupsWithGraphs++;
                                groupIsFresh = false;
                            }
                            groupGraphCount++;
                            if (groupGraphCount >= this.maxGraphCountPerGroup) {
                                break;
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (peraGraphs_1_1 && !peraGraphs_1_1.done && (_b = peraGraphs_1.return)) _b.call(peraGraphs_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                graphCount += groupGraphCount;
                groupsToShow++;
                if (graphCount > this.maxGraphsInDom) {
                    groupsToShow--;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { groupsToShow: groupsToShow, expanded: numOfGroupsWithGraphs <= 1 };
    };
    /**
     * if sorting by RI Score...get RI Scores from server and append to peraGraphs
     * @param peraGraphs - peraGraphs to have Ris attached to
     */
    /**
     * if sorting by RI Score...get RI Scores from server and append to peraGraphs
     * @param {?} peraGraphs - peraGraphs to have Ris attached to
     * @return {?}
     */
    ArrayViewService.prototype.addRIToPeraGraphs = /**
     * if sorting by RI Score...get RI Scores from server and append to peraGraphs
     * @param {?} peraGraphs - peraGraphs to have Ris attached to
     * @return {?}
     */
    function (peraGraphs) {
        if (this.sortService.activeSortName === 'latestRi') {
            return this.flowsheetsApiService.getAllRiScores().pipe(map(function (riScores) {
                var e_3, _a;
                /** @type {?} */
                var riMap = riScores.body;
                try {
                    for (var peraGraphs_2 = tslib_1.__values(peraGraphs), peraGraphs_2_1 = peraGraphs_2.next(); !peraGraphs_2_1.done; peraGraphs_2_1 = peraGraphs_2.next()) {
                        var peraGraph = peraGraphs_2_1.value;
                        if (riScores.body[peraGraph.visitId]) {
                            peraGraph.latestRi = riMap[peraGraph.visitId];
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (peraGraphs_2_1 && !peraGraphs_2_1.done && (_a = peraGraphs_2.return)) _a.call(peraGraphs_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return peraGraphs;
            }));
        }
        else {
            return of(peraGraphs);
        }
    };
    /**
     * sorts peraGraphs based on function passed in through sort parameter then subsorts if needed based on the default sort method
     * if no function is provided, the default sort function is used
     * @param peraGraphA - peraGraph to be sorted
     * @param peraGraphB - peraGraph to be sorted
     * @param sortFunction - function to sort peraGraphs
     */
    /**
     * sorts peraGraphs based on function passed in through sort parameter then subsorts if needed based on the default sort method
     * if no function is provided, the default sort function is used
     * @param {?} peraGraphA - peraGraph to be sorted
     * @param {?} peraGraphB - peraGraph to be sorted
     * @param {?=} sortFunction - function to sort peraGraphs
     * @return {?}
     */
    ArrayViewService.prototype.sortGraphs = /**
     * sorts peraGraphs based on function passed in through sort parameter then subsorts if needed based on the default sort method
     * if no function is provided, the default sort function is used
     * @param {?} peraGraphA - peraGraph to be sorted
     * @param {?} peraGraphB - peraGraph to be sorted
     * @param {?=} sortFunction - function to sort peraGraphs
     * @return {?}
     */
    function (peraGraphA, peraGraphB, sortFunction) {
        // default sort method for peragraphs
        /** @type {?} */
        var defaultSort = function (peraGraphA, peraGraphB) {
            /** @type {?} */
            var comparison = 0;
            if (peraGraphA.displayName > peraGraphB.displayName) {
                comparison = 1;
            }
            else if (peraGraphA.displayName < peraGraphB.displayName) {
                comparison = -1;
            }
            return comparison;
        };
        if (this.sortService.nonStandardSortFunctionActive && this.sortService.nonStandardSortFunction) {
            sortFunction = this.sortService.nonStandardSortFunction;
        }
        // if a function is passed in -> use it. if not use the default sort
        if (!sortFunction) {
            // if no function is provided, use default sort
            return defaultSort(peraGraphA, peraGraphB);
        }
        /** @type {?} */
        var comparison;
        comparison = sortFunction(peraGraphA, peraGraphB);
        if (comparison == 0) {
            comparison = defaultSort(peraGraphA, peraGraphB);
        }
        return comparison;
    };
    /**
     * If a timestamp is provided by config use that, otherwise update the current timestamp every 5 seconds
     */
    /**
     * If a timestamp is provided by config use that, otherwise update the current timestamp every 5 seconds
     * @return {?}
     */
    ArrayViewService.prototype.calcCurrentTimestamp = /**
     * If a timestamp is provided by config use that, otherwise update the current timestamp every 5 seconds
     * @return {?}
     */
    function () {
        if (this.configService.getCurrentTimestamp()) {
            this.currentTimestamp = this.configService.getCurrentTimestamp();
        }
    };
    /**
     * returns the timestamp sent by the server if it isn't null
     * otherwise calls Date.now() to get an up to date timestamp to
     * return
     */
    /**
     * returns the timestamp sent by the server if it isn't null
     * otherwise calls Date.now() to get an up to date timestamp to
     * return
     * @return {?}
     */
    ArrayViewService.prototype.getCurrentTimestamp = /**
     * returns the timestamp sent by the server if it isn't null
     * otherwise calls Date.now() to get an up to date timestamp to
     * return
     * @return {?}
     */
    function () {
        /*
            The currentTimestamp property is only set if the server sends a specific timestamp
            it wants us to use. If that is not provided, we call Date.now() to get the up to date
            timestamp every time this function is invoked
        */
        return this.currentTimestamp ? this.currentTimestamp : Date.now();
    };
    /**
     * @return {?}
     */
    ArrayViewService.prototype.isDisplayingTiles = /**
     * @return {?}
     */
    function () {
        return this.displayTiles;
    };
    /**
     * @return {?}
     */
    ArrayViewService.prototype.toggleTileView = /**
     * @return {?}
     */
    function () {
        // Toggle whether or not we display the tile view and set the width/height accordingly
        this.displayTiles = !this.displayTiles;
        this.peraGraphHeight = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultHeight;
        this.peraGraphWidth = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultWidth;
        this.refreshViewPort();
    };
    // Force a refresh of the viewport by toggling the data
    // Force a refresh of the viewport by toggling the data
    /**
     * @return {?}
     */
    ArrayViewService.prototype.refreshViewPort = 
    // Force a refresh of the viewport by toggling the data
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var previousPeraGraphs = this.peragraphApiService.getPeraGraphSubject().value;
        this.peragraphApiService.getPeraGraphSubject().next([]);
        setTimeout(function () {
            _this.peragraphApiService.getPeraGraphSubject().next(previousPeraGraphs);
        }, 1);
    };
    /**
     * Called on manual refresh or application of filters - refreshes graphs and FSCs
     * and fires completedRefresh$ Subject upon completion
     */
    /**
     * Called on manual refresh or application of filters - refreshes graphs and FSCs
     * and fires completedRefresh$ Subject upon completion
     * @param {?=} getFilterQuery
     * @return {?}
     */
    ArrayViewService.prototype.refreshGraphs = /**
     * Called on manual refresh or application of filters - refreshes graphs and FSCs
     * and fires completedRefresh$ Subject upon completion
     * @param {?=} getFilterQuery
     * @return {?}
     */
    function (getFilterQuery) {
        var _this = this;
        this.startedRefresh$.next();
        if (getFilterQuery) {
            // we use fork join here to combine the REST calls for server side filtering and getting new PeraGraphs
            // quick aside on fork join - all it does is wait for both observables to COMPLETE and then feed you both results
            // before getting to the fork join the vnms from the server side filter query are stored in the filter service
            //      -> this is done to ensure that once the forkjoin completes, client side filtering can commence
            // after filtering the graphs, they are passed to the array view per usual
            forkJoin(this.filterQueryRestService.getFilteredVisits(this.filterService.getActiveServerFilterCriteria()), this.peragraphApiService.getAllPeragraphs()).subscribe(function (graphsAndFilteredVisits) {
                _this.peragraphApiService.getPeraGraphSubject().next(graphsAndFilteredVisits[1]);
                _this.filterService.serverFilteredVisits = graphsAndFilteredVisits[0];
                _this.filterService.filterSubject$.next(_this.filterService.activeFilters);
                _this.completedRefresh$.next();
            });
        }
        else {
            // if we don't need to do server side filtering -> filter in the client immediately
            this.peragraphApiService.getAllPeragraphs().subscribe(function (graphs) {
                _this.peragraphApiService.getPeraGraphSubject().next(graphs);
            });
        }
        this.flowsheetsApiService.getAllPeraGraphFlowSheets().subscribe(function (flowsheets) { return _this.flowsheetsApiService.getFlowSheetSubject().next(flowsheets.body); });
    };
    ArrayViewService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ArrayViewService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: ArrayViewConfigService },
        { type: FilterService },
        { type: FilterQueryRestService },
        { type: FlowsheetsApiService },
        { type: PeragraphApiService },
        { type: SortService },
        { type: GroupService },
        { type: DateService }
    ]; };
    /** @nocollapse */ ArrayViewService.ngInjectableDef = i0.defineInjectable({ factory: function ArrayViewService_Factory() { return new ArrayViewService(i0.inject(i1.HttpClient), i0.inject(i2.ArrayViewConfigService), i0.inject(i3.FilterService), i0.inject(i3.FilterQueryRestService), i0.inject(i4.FlowsheetsApiService), i0.inject(i4.PeragraphApiService), i0.inject(i3.SortService), i0.inject(i3.GroupService), i0.inject(i4.DateService)); }, token: ArrayViewService, providedIn: "root" });
    return ArrayViewService;
}());
export { ArrayViewService };
if (false) {
    /** @type {?} */
    ArrayViewService.prototype.titleChoices;
    /** @type {?} */
    ArrayViewService.prototype.selectedChartTitle;
    /** @type {?} */
    ArrayViewService.prototype.chartTitleSubject$;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.maxGraphCountPerGroup;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.maxGraphsInDom;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.currentTimestamp;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.displayTiles;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphDefaultHeight;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphDefaultWidth;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphTileDefault;
    /** @type {?} */
    ArrayViewService.prototype.peraGraphHeight;
    /** @type {?} */
    ArrayViewService.prototype.peraGraphWidth;
    /** @type {?} */
    ArrayViewService.prototype.startedRefresh$;
    /** @type {?} */
    ArrayViewService.prototype.completedRefresh$;
    /** @type {?} */
    ArrayViewService.prototype.tokenRefresh$;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.configService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.filterService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.filterQueryRestService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.flowsheetsApiService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peragraphApiService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.sortService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.groupService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.dateService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdmlldy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctYXJyYXktdmlldy1saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2UvYXJyYXktdmlldy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ25DLE9BQU8sS0FBSyxPQUFPLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFDbkUsT0FBTyxFQUFDLFdBQVcsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBRXpGLE9BQU8sRUFBQyxzQkFBc0IsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxlQUFlLEVBQUUsUUFBUSxFQUFjLEVBQUUsRUFBRSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDeEUsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sa0JBQWtCLENBQUM7Ozs7Ozs7OztJQUk3QyxNQUFNLEdBQUcsT0FBTztBQUV0QjtJQTZFSSwwQkFBb0IsSUFBZ0IsRUFDaEIsYUFBcUMsRUFDckMsYUFBNEIsRUFDNUIsc0JBQThDLEVBQzlDLG9CQUEwQyxFQUMxQyxtQkFBd0MsRUFDeEMsV0FBd0IsRUFDeEIsWUFBMEIsRUFDMUIsV0FBd0I7UUFSNUMsaUJBU0M7UUFUbUIsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixrQkFBYSxHQUFiLGFBQWEsQ0FBd0I7UUFDckMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsMkJBQXNCLEdBQXRCLHNCQUFz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QUFDLENBQUMsQ0FBQztTQUNOO1FBQ0QsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHlCQUF5QixFQUFFLENBQUMsU0FBUyxDQUFDLFVBQUMsVUFBVSxJQUFLLE9BQUEsS0FBSSxDQUFDLG9CQUFvQixDQUFDLG1CQUFtQixFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBckUsQ0FBcUUsQ0FBQyxDQUFDO0lBQzNKLENBQUM7O2dCQWhSSixVQUFVLFNBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCOzs7O2dCQWhCTyxVQUFVO2dCQUdWLHNCQUFzQjtnQkFHRSxhQUFhO2dCQUFyQyxzQkFBc0I7Z0JBRlQsb0JBQW9CO2dCQUFFLG1CQUFtQjtnQkFFRCxXQUFXO2dCQUF6QixZQUFZO2dCQUZuRCxXQUFXOzs7MkJBTG5CO0NBaVNDLEFBbFJELElBa1JDO1NBL1FZLGdCQUFnQjs7O0lBR3pCLHdDQTRDRTs7SUFHRiw4Q0FLRTs7SUFHRiw4Q0FDeUU7Ozs7O0lBRXpFLGlEQUFtQzs7Ozs7SUFDbkMsMENBQTZCOzs7OztJQUM3Qiw0Q0FBZ0M7Ozs7O0lBQ2hDLHdDQUE2Qjs7Ozs7SUFDN0Isa0RBQXFDOzs7OztJQUNyQyxpREFBb0M7Ozs7O0lBQ3BDLGdEQUFrQzs7SUFDbEMsMkNBQTZEOztJQUM3RCwwQ0FBMkQ7O0lBQzNELDJDQUE0RDs7SUFDNUQsNkNBQThEOztJQUM5RCx5Q0FBMEQ7Ozs7O0lBRTlDLGdDQUF3Qjs7Ozs7SUFDeEIseUNBQTZDOzs7OztJQUM3Qyx5Q0FBb0M7Ozs7O0lBQ3BDLGtEQUFzRDs7Ozs7SUFDdEQsZ0RBQWtEOzs7OztJQUNsRCwrQ0FBZ0Q7Ozs7O0lBQ2hELHVDQUFnQzs7Ozs7SUFDaEMsd0NBQWtDOzs7OztJQUNsQyx1Q0FBZ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIdHRwQ2xpZW50fSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge21hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQtdGltZXpvbmUnO1xuaW1wb3J0IHtBcnJheVZpZXdDb25maWdTZXJ2aWNlfSBmcm9tICcuL2FycmF5LXZpZXctY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRlU2VydmljZSwgRmxvd3NoZWV0c0FwaVNlcnZpY2UsIFBlcmFncmFwaEFwaVNlcnZpY2V9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5JztcbmltcG9ydCB7UGVyYUdyYXBofSBmcm9tICduZy1jb21tb24tbGlicmFyeS9saWIvbW9kZWwvUGVyYUdyYXBoJztcbmltcG9ydCB7RmlsdGVyUXVlcnlSZXN0U2VydmljZSwgRmlsdGVyU2VydmljZSwgR3JvdXBTZXJ2aWNlLCBTb3J0U2VydmljZX0gZnJvbSAnbmctZmlsdGVycy1saWJyYXJ5JztcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBmb3JrSm9pbiwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtDaGFydFRpdGxlQ2hvaWNlc30gZnJvbSAnLi9jaGFydFRpdGxlRW51bSc7XG5cbi8vIFRoZSBKYXZhU2NyaXB0IGNvbXBpbGVyIGdpdmVzIGEgd2VpcmQgXCJtb21lbnQgY2Fubm90IGJlIHVzZWQgYXMgYSBuYW1lc3BhY2VcIiB0eXBlIG9mIGVycm9yXG4vLyBUaGlzIGlzIHRoZSB3b3JrYXJvdW5kLi4uXG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEFycmF5Vmlld1NlcnZpY2Uge1xuXG4gICAgLy8gVGhlIHBvc3NpYmxlIGNoYXJ0IHRpdGxlIHNlbGVjdGlvbnNcbiAgICB0aXRsZUNob2ljZXM6IHtkZXNjcmlwdGlvbjogc3RyaW5nLCByZXR1cm5GdW5jOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IGFueX1bXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IENoYXJ0VGl0bGVDaG9pY2VzLlZOTSxcbiAgICAgICAgICAgIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJhR3JhcGgudm5tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuQURNSVRfREFURSxcbiAgICAgICAgICAgIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZXJhR3JhcGggJiYgcGVyYUdyYXBoLnRpbWVab25lICYmIHBlcmFHcmFwaC5hZG1pdERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF0ZUZvcm1hdChwZXJhR3JhcGgudGltZVpvbmUsIHBlcmFHcmFwaC5hZG1pdERhdGUsICdNTS9ERC9ZWSBISDptbSB6Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IENoYXJ0VGl0bGVDaG9pY2VzLk1STixcbiAgICAgICAgICAgIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJhR3JhcGgucGF0aWVudC5tZWRpY2FsUmVjb3JkTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuUEFUSUVOVF9OQU1FLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmFHcmFwaC52aXBJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaC5wYXRpZW50LmFsaWFzTGFzdE5hbWUgKyAnLCAnICsgcGVyYUdyYXBoLnBhdGllbnQuYWxpYXNGaXJzdE5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaC5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBDaGFydFRpdGxlQ2hvaWNlcy5MT0NBVElPTixcbiAgICAgICAgICAgIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJhR3JhcGgudW5pdElkICsgJy0nICsgcGVyYUdyYXBoLnJvb20gKyAnLScgKyBwZXJhR3JhcGguYmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuQU5PTllNT1VTLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDaGFydCAnICsgcGVyYUdyYXBoLmFub255bW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF07XG5cbiAgICAvLyBDdXJyZW50IGNoYXJ0IHRpdGxlIHNlbGVjdGlvbiAtIGRlZmF1bHRzIHRvIFBhdGllbnQgTmFtZVxuICAgIHNlbGVjdGVkQ2hhcnRUaXRsZToge2Rlc2NyaXB0aW9uOiBzdHJpbmcsIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4gYW55fSA9IHtcbiAgICAgICAgZGVzY3JpcHRpb246IENoYXJ0VGl0bGVDaG9pY2VzLlBBVElFTlRfTkFNRSxcbiAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGVyYUdyYXBoLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN1YmplY3QgZm9yIHRoZSB0aXRsZSBzZWxlY3Rpb25cbiAgICBwdWJsaWMgY2hhcnRUaXRsZVN1YmplY3QkID0gbmV3IEJlaGF2aW9yU3ViamVjdDx7ZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiBhbnl9Pih0aGlzLnNlbGVjdGVkQ2hhcnRUaXRsZSk7XG5cbiAgICBwcml2YXRlIG1heEdyYXBoQ291bnRQZXJHcm91cCA9IDUwO1xuICAgIHByaXZhdGUgbWF4R3JhcGhzSW5Eb20gPSAxNTA7XG4gICAgcHJpdmF0ZSBjdXJyZW50VGltZXN0YW1wID0gbnVsbDtcbiAgICBwcml2YXRlIGRpc3BsYXlUaWxlcyA9IGZhbHNlO1xuICAgIHByaXZhdGUgcGVyYUdyYXBoRGVmYXVsdEhlaWdodCA9IDE0NTtcbiAgICBwcml2YXRlIHBlcmFHcmFwaERlZmF1bHRXaWR0aCA9IDE4NTtcbiAgICBwcml2YXRlIHBlcmFHcmFwaFRpbGVEZWZhdWx0ID0gNzU7XG4gICAgcHVibGljIHBlcmFHcmFwaEhlaWdodDogbnVtYmVyID0gdGhpcy5wZXJhR3JhcGhEZWZhdWx0SGVpZ2h0O1xuICAgIHB1YmxpYyBwZXJhR3JhcGhXaWR0aDogbnVtYmVyID0gdGhpcy5wZXJhR3JhcGhEZWZhdWx0V2lkdGg7XG4gICAgcHVibGljIHN0YXJ0ZWRSZWZyZXNoJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHVibGljIGNvbXBsZXRlZFJlZnJlc2gkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwdWJsaWMgdG9rZW5SZWZyZXNoJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjb25maWdTZXJ2aWNlOiBBcnJheVZpZXdDb25maWdTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTogRmlsdGVyU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGZpbHRlclF1ZXJ5UmVzdFNlcnZpY2U6IEZpbHRlclF1ZXJ5UmVzdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBmbG93c2hlZXRzQXBpU2VydmljZTogRmxvd3NoZWV0c0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwZXJhZ3JhcGhBcGlTZXJ2aWNlOiBQZXJhZ3JhcGhBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgc29ydFNlcnZpY2U6IFNvcnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZ3JvdXBTZXJ2aWNlOiBHcm91cFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkYXRlU2VydmljZTogRGF0ZVNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW5zIHRoZSBwZXJhZ3JhcGggdGhyb3VnaCBhbGwgdGhlIGZpbHRlcnMgYW5kIHJldHVybnMgdHJ1ZSBpZiBub25lIG9mIHRoZW0gcmV0dXJuIGZhbHNlXG4gICAgICogQHBhcmFtIHBlcmFHcmFwaCAtIHBlcmFncmFwaCB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIC0gb2JqZWN0IG9mIGZpbHRlciBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBmaWx0ZXJQZXJhZ3JhcGgocGVyYUdyYXBoLCBmaWx0ZXJzKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIHJldHVybiB0cnVlIGlmIGZpbHRlciBvYmplY3QgaGFzIG5vIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKChPYmplY3Qua2V5cyhmaWx0ZXJzKS5sZW5ndGggPT09IDAgJiYgZmlsdGVycy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmF2ZXJzZSBmaWx0ZXIgb2JqZWN0IGFuZCB0ZXN0IHBlcmFncmFwaCBhZ2FpbnN0IGVhY2ggZmlsdGVyIHVudGlsIG9uZSByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBpbiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMuaGFzT3duUHJvcGVydHkoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWx0ZXJzW2ZpbHRlcl0ocGVyYUdyYXBoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsaW1pdCB0aGUgbnVtYmVyIG9mIGdyb3VwcyB0byBsb2FkIG9wZW4gb24gYXBwbGljYXRpb24gb2YgZmlsdGVyaW5nL3NvcnRpbmcvZ3JvdXBpbmcgYmFzZWQgb24gdGhlIG51bWJlciBvZiBncmFwaHMgaW4gdGhlIGRvbVxuICAgICAqIEBwYXJhbSBwZXJhR3JhcGhzIC0gZ3JhcGhzIHRvIG1ha2UgY291bnQgYmFzZWQgb2ZmIG9mXG4gICAgICovXG4gICAgY2FsY3VsYXRlTnVtYmVyT2ZHcm91cHNUb1Nob3cocGVyYUdyYXBoczogUGVyYUdyYXBoW10pOiB7Z3JvdXBzVG9TaG93OiBudW1iZXIsIGV4cGFuZGVkOiBib29sZWFufSB7XG4gICAgICAgIGxldCBncm91cHNUb1Nob3cgPSAwO1xuICAgICAgICBsZXQgZ3JhcGhDb3VudCA9IDA7XG4gICAgICAgIGxldCBleHBhbmRlZCA9IHRydWU7XG4gICAgICAgIGxldCBudW1PZkdyb3Vwc1dpdGhHcmFwaHMgPSAwO1xuICAgICAgICAvLyBmb3IgZWFjaCBncm91cCwgY291bnQgdGhlIG51bWJlciBvZiBncmFwaHMgaW4gdGhhdCBncm91cCwgY2FwcGVkIGF0IHRoZSBtYXhHcmFwaHNQZXJHcm91cCB2YXJpYWJsZVxuICAgICAgICAvLyBvbmNlIHRoZSBncmFwaHMgZXhjZWVkIHRoZSBtYXhHcmFwaHMgaW4gZG9tIHZhbHVlIHJldHVybiB0aGUgbnVtYmVyIG9mIGdyb3Vwc3RvU2hvdyB0byBiZSBhcHBsaWVkIHRvIGdyb3Vwc1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuZ3JvdXBTZXJ2aWNlLmdyb3VwU3ViamVjdCQudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBncm91cEdyYXBoQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gaGVscGVyIHZhcmlhYmxlIGZvciB0cmFja2luZyBob3cgbWFueSBncm91cHMgaGF2ZSBncmFwaHNcbiAgICAgICAgICAgIGxldCBncm91cElzRnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgZm9yKGNvbnN0IHBlcmFHcmFwaCBvZiBwZXJhR3JhcGhzKSB7XG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAubGFuZUZ1bmN0aW9uKHBlcmFHcmFwaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZ3JvdXBJc0ZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1PZkdyb3Vwc1dpdGhHcmFwaHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSXNGcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwR3JhcGhDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZihncm91cEdyYXBoQ291bnQgPj0gdGhpcy5tYXhHcmFwaENvdW50UGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGhDb3VudCArPSBncm91cEdyYXBoQ291bnQ7XG4gICAgICAgICAgICBncm91cHNUb1Nob3crKztcbiAgICAgICAgICAgIGlmIChncmFwaENvdW50ID4gdGhpcy5tYXhHcmFwaHNJbkRvbSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1RvU2hvdy0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7Z3JvdXBzVG9TaG93OiBncm91cHNUb1Nob3csIGV4cGFuZGVkOiBudW1PZkdyb3Vwc1dpdGhHcmFwaHMgPD0gMX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaWYgc29ydGluZyBieSBSSSBTY29yZS4uLmdldCBSSSBTY29yZXMgZnJvbSBzZXJ2ZXIgYW5kIGFwcGVuZCB0byBwZXJhR3JhcGhzXG4gICAgICogQHBhcmFtIHBlcmFHcmFwaHMgLSBwZXJhR3JhcGhzIHRvIGhhdmUgUmlzIGF0dGFjaGVkIHRvXG4gICAgICovXG4gICAgYWRkUklUb1BlcmFHcmFwaHMocGVyYUdyYXBoczogUGVyYUdyYXBoW10pOiBPYnNlcnZhYmxlPFBlcmFHcmFwaFtdPiB7XG4gICAgICAgIGlmICh0aGlzLnNvcnRTZXJ2aWNlLmFjdGl2ZVNvcnROYW1lID09PSAnbGF0ZXN0UmknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93c2hlZXRzQXBpU2VydmljZS5nZXRBbGxSaVNjb3JlcygpLnBpcGUobWFwKChyaVNjb3JlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpTWFwID0gcmlTY29yZXMuYm9keTtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgcGVyYUdyYXBoIG9mIHBlcmFHcmFwaHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpU2NvcmVzLmJvZHlbcGVyYUdyYXBoLnZpc2l0SWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJhR3JhcGgubGF0ZXN0UmkgPSByaU1hcFtwZXJhR3JhcGgudmlzaXRJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaHM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2YocGVyYUdyYXBocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzb3J0cyBwZXJhR3JhcGhzIGJhc2VkIG9uIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aHJvdWdoIHNvcnQgcGFyYW1ldGVyIHRoZW4gc3Vic29ydHMgaWYgbmVlZGVkIGJhc2VkIG9uIHRoZSBkZWZhdWx0IHNvcnQgbWV0aG9kXG4gICAgICogaWYgbm8gZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNvcnQgZnVuY3Rpb24gaXMgdXNlZFxuICAgICAqIEBwYXJhbSBwZXJhR3JhcGhBIC0gcGVyYUdyYXBoIHRvIGJlIHNvcnRlZFxuICAgICAqIEBwYXJhbSBwZXJhR3JhcGhCIC0gcGVyYUdyYXBoIHRvIGJlIHNvcnRlZFxuICAgICAqIEBwYXJhbSBzb3J0RnVuY3Rpb24gLSBmdW5jdGlvbiB0byBzb3J0IHBlcmFHcmFwaHNcbiAgICAgKi9cbiAgICBzb3J0R3JhcGhzKHBlcmFHcmFwaEEsIHBlcmFHcmFwaEIsIHNvcnRGdW5jdGlvbj86IChwZXJhZ3JhcGhBOiBQZXJhR3JhcGgsIHBlcmFHcmFwaEI6IFBlcmFHcmFwaCkgPT4gbnVtYmVyKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgc29ydCBtZXRob2QgZm9yIHBlcmFncmFwaHNcbiAgICAgICAgY29uc3QgZGVmYXVsdFNvcnQgPSBmdW5jdGlvbiAocGVyYUdyYXBoQTogUGVyYUdyYXBoLCBwZXJhR3JhcGhCOiBQZXJhR3JhcGgpOiBudW1iZXIge1xuICAgICAgICAgICAgbGV0IGNvbXBhcmlzb24gPSAwO1xuICAgICAgICAgICAgaWYgKHBlcmFHcmFwaEEuZGlzcGxheU5hbWUgPiBwZXJhR3JhcGhCLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbiA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBlcmFHcmFwaEEuZGlzcGxheU5hbWUgPCBwZXJhR3JhcGhCLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFNlcnZpY2Uubm9uU3RhbmRhcmRTb3J0RnVuY3Rpb25BY3RpdmUgJiYgdGhpcy5zb3J0U2VydmljZS5ub25TdGFuZGFyZFNvcnRGdW5jdGlvbikge1xuICAgICAgICAgICBzb3J0RnVuY3Rpb24gPSB0aGlzLnNvcnRTZXJ2aWNlLm5vblN0YW5kYXJkU29ydEZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgaW4gLT4gdXNlIGl0LiBpZiBub3QgdXNlIHRoZSBkZWZhdWx0IHNvcnRcbiAgICAgICAgaWYgKCFzb3J0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgZGVmYXVsdCBzb3J0XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNvcnQocGVyYUdyYXBoQSwgcGVyYUdyYXBoQilcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcGFyaXNvbjtcbiAgICAgICAgY29tcGFyaXNvbiA9IHNvcnRGdW5jdGlvbihwZXJhR3JhcGhBLCBwZXJhR3JhcGhCKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT0gMCkge1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IGRlZmF1bHRTb3J0KHBlcmFHcmFwaEEsIHBlcmFHcmFwaEIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGEgdGltZXN0YW1wIGlzIHByb3ZpZGVkIGJ5IGNvbmZpZyB1c2UgdGhhdCwgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCB0aW1lc3RhbXAgZXZlcnkgNSBzZWNvbmRzXG4gICAgICovXG4gICAgY2FsY0N1cnJlbnRUaW1lc3RhbXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0Q3VycmVudFRpbWVzdGFtcCgpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lc3RhbXAgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0Q3VycmVudFRpbWVzdGFtcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdGltZXN0YW1wIHNlbnQgYnkgdGhlIHNlcnZlciBpZiBpdCBpc24ndCBudWxsXG4gICAgICogb3RoZXJ3aXNlIGNhbGxzIERhdGUubm93KCkgdG8gZ2V0IGFuIHVwIHRvIGRhdGUgdGltZXN0YW1wIHRvXG4gICAgICogcmV0dXJuXG4gICAgICovXG4gICAgcHVibGljIGdldEN1cnJlbnRUaW1lc3RhbXAoKTogbnVtYmVyIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIFRoZSBjdXJyZW50VGltZXN0YW1wIHByb3BlcnR5IGlzIG9ubHkgc2V0IGlmIHRoZSBzZXJ2ZXIgc2VuZHMgYSBzcGVjaWZpYyB0aW1lc3RhbXBcbiAgICAgICAgICAgIGl0IHdhbnRzIHVzIHRvIHVzZS4gSWYgdGhhdCBpcyBub3QgcHJvdmlkZWQsIHdlIGNhbGwgRGF0ZS5ub3coKSB0byBnZXQgdGhlIHVwIHRvIGRhdGVcbiAgICAgICAgICAgIHRpbWVzdGFtcCBldmVyeSB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZFxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZXN0YW1wID8gdGhpcy5jdXJyZW50VGltZXN0YW1wIDogRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNEaXNwbGF5aW5nVGlsZXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlUaWxlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9nZ2xlVGlsZVZpZXcoKSB7XG4gICAgICAgIC8vIFRvZ2dsZSB3aGV0aGVyIG9yIG5vdCB3ZSBkaXNwbGF5IHRoZSB0aWxlIHZpZXcgYW5kIHNldCB0aGUgd2lkdGgvaGVpZ2h0IGFjY29yZGluZ2x5XG4gICAgICAgIHRoaXMuZGlzcGxheVRpbGVzID0gIXRoaXMuZGlzcGxheVRpbGVzO1xuICAgICAgICB0aGlzLnBlcmFHcmFwaEhlaWdodCA9ICh0aGlzLmRpc3BsYXlUaWxlcykgPyB0aGlzLnBlcmFHcmFwaFRpbGVEZWZhdWx0IDogdGhpcy5wZXJhR3JhcGhEZWZhdWx0SGVpZ2h0O1xuICAgICAgICB0aGlzLnBlcmFHcmFwaFdpZHRoID0gKHRoaXMuZGlzcGxheVRpbGVzKSA/IHRoaXMucGVyYUdyYXBoVGlsZURlZmF1bHQgOiB0aGlzLnBlcmFHcmFwaERlZmF1bHRXaWR0aDtcbiAgICAgICAgdGhpcy5yZWZyZXNoVmlld1BvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBhIHJlZnJlc2ggb2YgdGhlIHZpZXdwb3J0IGJ5IHRvZ2dsaW5nIHRoZSBkYXRhXG4gICAgcHVibGljIHJlZnJlc2hWaWV3UG9ydCgpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQZXJhR3JhcGhzID0gdGhpcy5wZXJhZ3JhcGhBcGlTZXJ2aWNlLmdldFBlcmFHcmFwaFN1YmplY3QoKS52YWx1ZTtcbiAgICAgICAgdGhpcy5wZXJhZ3JhcGhBcGlTZXJ2aWNlLmdldFBlcmFHcmFwaFN1YmplY3QoKS5uZXh0KFtdKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlcmFncmFwaEFwaVNlcnZpY2UuZ2V0UGVyYUdyYXBoU3ViamVjdCgpLm5leHQocHJldmlvdXNQZXJhR3JhcGhzKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIG1hbnVhbCByZWZyZXNoIG9yIGFwcGxpY2F0aW9uIG9mIGZpbHRlcnMgLSByZWZyZXNoZXMgZ3JhcGhzIGFuZCBGU0NzXG4gICAgICogYW5kIGZpcmVzIGNvbXBsZXRlZFJlZnJlc2gkIFN1YmplY3QgdXBvbiBjb21wbGV0aW9uXG4gICAgICovXG4gICAgcHVibGljIHJlZnJlc2hHcmFwaHMoZ2V0RmlsdGVyUXVlcnk/OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZFJlZnJlc2gkLm5leHQoKTtcbiAgICAgICAgaWYgKGdldEZpbHRlclF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgZm9yayBqb2luIGhlcmUgdG8gY29tYmluZSB0aGUgUkVTVCBjYWxscyBmb3Igc2VydmVyIHNpZGUgZmlsdGVyaW5nIGFuZCBnZXR0aW5nIG5ldyBQZXJhR3JhcGhzXG4gICAgICAgICAgICAvLyBxdWljayBhc2lkZSBvbiBmb3JrIGpvaW4gLSBhbGwgaXQgZG9lcyBpcyB3YWl0IGZvciBib3RoIG9ic2VydmFibGVzIHRvIENPTVBMRVRFIGFuZCB0aGVuIGZlZWQgeW91IGJvdGggcmVzdWx0c1xuICAgICAgICAgICAgLy8gYmVmb3JlIGdldHRpbmcgdG8gdGhlIGZvcmsgam9pbiB0aGUgdm5tcyBmcm9tIHRoZSBzZXJ2ZXIgc2lkZSBmaWx0ZXIgcXVlcnkgYXJlIHN0b3JlZCBpbiB0aGUgZmlsdGVyIHNlcnZpY2VcbiAgICAgICAgICAgIC8vICAgICAgLT4gdGhpcyBpcyBkb25lIHRvIGVuc3VyZSB0aGF0IG9uY2UgdGhlIGZvcmtqb2luIGNvbXBsZXRlcywgY2xpZW50IHNpZGUgZmlsdGVyaW5nIGNhbiBjb21tZW5jZVxuICAgICAgICAgICAgLy8gYWZ0ZXIgZmlsdGVyaW5nIHRoZSBncmFwaHMsIHRoZXkgYXJlIHBhc3NlZCB0byB0aGUgYXJyYXkgdmlldyBwZXIgdXN1YWxcbiAgICAgICAgICAgIGZvcmtKb2luKHRoaXMuZmlsdGVyUXVlcnlSZXN0U2VydmljZS5nZXRGaWx0ZXJlZFZpc2l0cyh0aGlzLmZpbHRlclNlcnZpY2UuZ2V0QWN0aXZlU2VydmVyRmlsdGVyQ3JpdGVyaWEoKSksIHRoaXMucGVyYWdyYXBoQXBpU2VydmljZS5nZXRBbGxQZXJhZ3JhcGhzKCkpLnN1YnNjcmliZSgoZ3JhcGhzQW5kRmlsdGVyZWRWaXNpdHMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmFncmFwaEFwaVNlcnZpY2UuZ2V0UGVyYUdyYXBoU3ViamVjdCgpLm5leHQoZ3JhcGhzQW5kRmlsdGVyZWRWaXNpdHNbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5zZXJ2ZXJGaWx0ZXJlZFZpc2l0cyA9IGdyYXBoc0FuZEZpbHRlcmVkVmlzaXRzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU2VydmljZS5maWx0ZXJTdWJqZWN0JC5uZXh0KHRoaXMuZmlsdGVyU2VydmljZS5hY3RpdmVGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlZFJlZnJlc2gkLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgbmVlZCB0byBkbyBzZXJ2ZXIgc2lkZSBmaWx0ZXJpbmcgLT4gZmlsdGVyIGluIHRoZSBjbGllbnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHRoaXMucGVyYWdyYXBoQXBpU2VydmljZS5nZXRBbGxQZXJhZ3JhcGhzKCkuc3Vic2NyaWJlKChncmFwaHMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmFncmFwaEFwaVNlcnZpY2UuZ2V0UGVyYUdyYXBoU3ViamVjdCgpLm5leHQoZ3JhcGhzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxvd3NoZWV0c0FwaVNlcnZpY2UuZ2V0QWxsUGVyYUdyYXBoRmxvd1NoZWV0cygpLnN1YnNjcmliZSgoZmxvd3NoZWV0cykgPT4gdGhpcy5mbG93c2hlZXRzQXBpU2VydmljZS5nZXRGbG93U2hlZXRTdWJqZWN0KCkubmV4dChmbG93c2hlZXRzLmJvZHkpKTtcbiAgICB9XG5cbn1cbiJdfQ==