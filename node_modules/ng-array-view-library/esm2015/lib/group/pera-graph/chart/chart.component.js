/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input } from '@angular/core';
import * as moment_ from 'moment-timezone';
import { ArrayViewService } from '../../../service/array-view.service';
import { ChartService, DateService } from 'ng-common-library';
/** @type {?} */
const Highcharts = require('highcharts');
// The JavaScript compiler gives a weird "moment cannot be used as a namespace" type of error
// This is the workaround...
/** @type {?} */
const moment = moment_;
export class ChartComponent {
    /**
     * @param {?} dateService
     * @param {?} chartService
     * @param {?} arrayViewService
     * @param {?} ref
     */
    constructor(dateService, chartService, arrayViewService, ref) {
        this.dateService = dateService;
        this.chartService = chartService;
        this.arrayViewService = arrayViewService;
        this.ref = ref;
        this.Highcharts = Highcharts;
        this.X_AXIS_DAYS = 5;
        this.DAY_IN_MILLISECONDS = 86400000;
        this.minRiScore = 0;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Manage change detection explicitly
        this.ref.detach();
        // Get the series
        this.series = this.getChartSeries();
        // Build the chart options
        this.chartOptions = this.getChartOptions();
        // Trigger change detection
        this.ref.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        // Ensure that a chart already exists
        if (this.Highcharts && this.chartOptions) {
            // Fetch the series using the latest flowsheet information
            this.series = this.getChartSeries();
            // If the series is different
            if (this.series !== this.chartOptions.series) {
                this.updateChart();
                this.chartOptions = Object.assign({}, this.chartOptions);
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        }
    }
    /**
     * Updates the chart
     * @return {?}
     */
    updateChart() {
        this.chartOptions.series = this.series;
        this.updateXAxis();
        this.updateYAxis();
    }
    /**
     * Updates the pieces of the Y axis that need updating
     * @return {?}
     */
    updateYAxis() {
        /** @type {?} */
        const minYAxisTick = this.chartService.getMinYAxisTick(this.minRiScore);
        // If the min Y axis value would change, update it
        if (this.chartOptions.yAxis[0].min !== minYAxisTick) {
            this.chartOptions.yAxis[0].min = minYAxisTick;
            this.chartOptions.yAxis[0].plotLines = this.chartService.createZeroAxisLine(this.minRiScore);
        }
    }
    /**
     * Updates the pieces of the X axis that need updating
     * @return {?}
     */
    updateXAxis() {
        this.chartOptions.xAxis = this.getXaxis();
    }
    /**
     * Returns the chart options
     * @return {?}
     */
    getChartOptions() {
        return {
            chart: {
                type: 'line',
                spacing: [2, 0, 0, 0],
                marginLeft: 18,
                marginRight: 2,
                plotBackgroundColor: 'white',
                reflow: false,
                animation: false,
                alignTicks: false
            },
            tooltip: {
                enabled: false,
                animation: false
            },
            plotOptions: {
                series: {
                    color: '#848484',
                    turboThreshold: 0,
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                },
                line: {
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                }
            },
            credits: {
                enabled: false
            },
            legend: {
                enabled: false
            },
            title: {
                text: ''
            },
            xAxis: this.getXaxis(),
            yAxis: this.getYaxis(),
            series: this.series
        };
    }
    /**
     * @return {?}
     */
    getXaxis() {
        /** @type {?} */
        const xAxis = [];
        xAxis.push({
            type: 'datetime',
            startOnTick: false,
            endOnTick: false,
            tickInterval: this.graph.isDischarged ? null : this.DAY_IN_MILLISECONDS,
            gridLineWidth: 1,
            plotLines: this.chartService.updateAlertPlotLine(this.graph),
            title: {
                text: ' '
            },
            labels: {
                distance: 20,
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                formatter: function () {
                    return moment(this.value).utcOffset(0).format('MM/DD');
                },
                step: 1
            },
            min: this.getMinXAxisValue(),
            max: this.getMaxXAxisValue(),
        });
        return xAxis;
    }
    /**
     * @return {?}
     */
    getMaxXAxisValue() {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone);
    }
    /**
     * @return {?}
     */
    getMinXAxisValue() {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone) - this.X_AXIS_DAYS * this.DAY_IN_MILLISECONDS;
    }
    /**
     * @return {?}
     */
    getYaxis() {
        /** @type {?} */
        const yAxis = [];
        yAxis.push({
            title: {
                text: ' '
            },
            labels: {
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                padding: 1,
                align: 'center'
            },
            offset: -12,
            //     gridLineColor : colorHealthScoreGridLine,
            gridLineWidth: 1,
            min: this.chartService.getMinYAxisTick(this.minRiScore),
            max: 100,
            plotLines: this.chartService.createZeroAxisLine(this.minRiScore),
            tickPositioner: function (min, max) {
                /** @type {?} */
                let tick = min;
                /** @type {?} */
                const ticks = [];
                while (tick <= max) {
                    ticks.push(tick);
                    tick += 20;
                }
                return ticks;
            }
        });
        return yAxis;
    }
    /**
     * @return {?}
     */
    getChartSeries() {
        /** @type {?} */
        const series = [];
        series.push({
            name: '',
            data: this.getDataPoints(this.flowsheets),
            showInLegend: false,
            turboThreshold: 0,
            color: {
                linearGradient: { x1: 0, x2: 1, y1: 0, y2: 0 },
                stops: this.getArrayOfLocationChanges(this.flowsheets)
            },
            marker: {
                enabled: (this.flowsheets && this.flowsheets.length === 1) ? true : false,
                color: (this.flowsheets && this.flowsheets.length === 1) ? this.chartService.getMarkerColor(this.flowsheets[0].unitType) : null,
                radius: 1.5
            }
        });
        return series;
    }
    /**
     * @param {?} fscList
     * @return {?}
     */
    getArrayOfLocationChanges(fscList) {
        /** @type {?} */
        const range = this.maxRecordedDt - this.minRecordedDt;
        /** @type {?} */
        const colors = [[0, 'black']];
        /** @type {?} */
        let color = 'black';
        /** @type {?} */
        let unitType = null;
        /** @type {?} */
        let xval = 0;
        if (fscList && range > 0) {
            fscList.forEach((fsc) => {
                // If the unit type changed
                if (fsc.unitType !== unitType) {
                    // Get the percentage across the X axis by recorded date
                    xval = (fsc.key.recordedDt - this.minRecordedDt) / range;
                    // add an entry just prior to this point to smooth the gradient
                    colors.push([xval - .0001, color]);
                    // The the appropriate color for this unitType
                    color = this.chartService.getMarkerColor(fsc.unitType);
                    // Push the change in color
                    colors.push([xval, color]);
                    // Remember the current unit type
                    unitType = fsc.unitType;
                }
            });
        }
        return colors;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getDataPoints(data) {
        /** @type {?} */
        const dataPoints = [];
        // Reset the variables
        this.minRiScore = 100;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
        // If we have data
        if (data) {
            data.forEach((fsc) => {
                dataPoints.push([this.dateService.translateDate(fsc.key.recordedDt, this.graph.timeZone), fsc.riScore + (Math.random() / 1000)]);
                // Keep track of the extreme values - they are used elsewhere
                this.minRecordedDt = (this.minRecordedDt > fsc.key.recordedDt) ? fsc.key.recordedDt : this.minRecordedDt;
                this.maxRecordedDt = (this.maxRecordedDt < fsc.key.recordedDt) ? fsc.key.recordedDt : this.maxRecordedDt;
                this.minRiScore = (this.minRiScore > fsc.riScore) ? fsc.riScore : this.minRiScore;
            });
        }
        return dataPoints;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
    }
}
ChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-chart',
                template: "<div class=\"ph-graph\" *ngIf=\"!flowsheets || flowsheets.length != 0\">\n  <highcharts-chart class=\"ph-hc\"\n                    [Highcharts]=\"Highcharts\"\n                    [options]=\"chartOptions\"\n  ></highcharts-chart>\n</div>\n\n<div class=\"insufficient-data ph-hc\" *ngIf=\"flowsheets && flowsheets.length == 0\">\n  <div class=\"insufficient-data-text\">Insufficient data received to generate RI graph\n    <div *ngIf=\"graph && graph.activeWarning\" class=\"insufficient-data-text\">\n      <br>\n      Warning state generated by prior visit\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ph-graph{width:99%;height:83%;position:absolute;top:17%;left:1px;cursor:pointer}.ph-hc{width:100%!important;position:absolute!important;height:100%!important}.insufficient-data{font-size:.7em;font-weight:700;color:#60606a;padding-left:5%;padding-right:5%;padding-top:13%;display:flex;margin:auto}.insufficient-data-text{margin:auto}"]
            }] }
];
/** @nocollapse */
ChartComponent.ctorParameters = () => [
    { type: DateService },
    { type: ChartService },
    { type: ArrayViewService },
    { type: ChangeDetectorRef }
];
ChartComponent.propDecorators = {
    flowsheets: [{ type: Input }],
    graph: [{ type: Input }],
    currentTimestamp: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ChartComponent.prototype.flowsheets;
    /** @type {?} */
    ChartComponent.prototype.graph;
    /** @type {?} */
    ChartComponent.prototype.currentTimestamp;
    /** @type {?} */
    ChartComponent.prototype.Highcharts;
    /** @type {?} */
    ChartComponent.prototype.chartOptions;
    /** @type {?} */
    ChartComponent.prototype.X_AXIS_DAYS;
    /** @type {?} */
    ChartComponent.prototype.DAY_IN_MILLISECONDS;
    /** @type {?} */
    ChartComponent.prototype.minRiScore;
    /** @type {?} */
    ChartComponent.prototype.minRecordedDt;
    /** @type {?} */
    ChartComponent.prototype.maxRecordedDt;
    /** @type {?} */
    ChartComponent.prototype.series;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.dateService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.chartService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.arrayViewService;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.ref;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctYXJyYXktdmlldy1saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL2dyb3VwL3BlcmEtZ3JhcGgvY2hhcnQvY2hhcnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsS0FBSyxFQUlOLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sS0FBSyxPQUFPLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0scUNBQXFDLENBQUM7QUFFckUsT0FBTyxFQUFDLFlBQVksRUFBRSxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQzs7TUFJdEQsVUFBVSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7Ozs7TUFJbEMsTUFBTSxHQUFHLE9BQU87QUFRdEIsTUFBTSxPQUFPLGNBQWM7Ozs7Ozs7SUFzQnpCLFlBQW9CLFdBQXdCLEVBQ3hCLFlBQTBCLEVBQzFCLGdCQUFrQyxFQUNsQyxHQUFzQjtRQUh0QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBZjFDLGVBQVUsR0FBRyxVQUFVLENBQUM7UUFHeEIsZ0JBQVcsR0FBRyxDQUFDLENBQUM7UUFDaEIsd0JBQW1CLEdBQUcsUUFBUSxDQUFDO1FBRS9CLGVBQVUsR0FBRyxDQUFDLENBQUM7UUFDZixrQkFBYSxHQUFHLHFCQUFxQixDQUFDO1FBQ3RDLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO0lBUWxCLENBQUM7Ozs7SUFFRCxRQUFRO1FBQ04scUNBQXFDO1FBQ3JDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDbEIsaUJBQWlCO1FBQ2pCLElB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QyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2dCQUN6RyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7WUFDcEYsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUNELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNsQixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNqQjtJQUNILENBQUM7OztZQXpTRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLDBsQkFBcUM7Z0JBRXJDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzthQUNoRDs7OztZQWZxQixXQUFXO1lBQXpCLFlBQVk7WUFGWixnQkFBZ0I7WUFUdEIsaUJBQWlCOzs7eUJBNEJoQixLQUFLO29CQUdMLEtBQUs7K0JBR0wsS0FBSzs7OztJQU5OLG9DQUNpQzs7SUFFakMsK0JBQ3dCOztJQUV4QiwwQ0FDeUI7O0lBRXpCLG9DQUF3Qjs7SUFDeEIsc0NBQWE7O0lBRWIscUNBQWdCOztJQUNoQiw2Q0FBK0I7O0lBRS9CLG9DQUFlOztJQUNmLHVDQUFzQzs7SUFDdEMsdUNBQWtCOztJQUVsQixnQ0FBTzs7Ozs7SUFFSyxxQ0FBZ0M7Ozs7O0lBQ2hDLHNDQUFrQzs7Ozs7SUFDbEMsMENBQTBDOzs7OztJQUMxQyw2QkFBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50LXRpbWV6b25lJztcbmltcG9ydCB7QXJyYXlWaWV3U2VydmljZX0gZnJvbSAnLi4vLi4vLi4vc2VydmljZS9hcnJheS12aWV3LnNlcnZpY2UnO1xuaW1wb3J0IHtQZXJhR3JhcGh9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5L2xpYi9tb2RlbC9QZXJhR3JhcGgnO1xuaW1wb3J0IHtDaGFydFNlcnZpY2UsIERhdGVTZXJ2aWNlfSBmcm9tICduZy1jb21tb24tbGlicmFyeSc7XG5pbXBvcnQge0Zsb3dTaGVldEJhc2V9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5L2xpYi9tb2RlbC9GbG93U2hlZXRCYXNlJztcblxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xuY29uc3QgSGlnaGNoYXJ0cyA9IHJlcXVpcmUoJ2hpZ2hjaGFydHMnKTtcblxuLy8gVGhlIEphdmFTY3JpcHQgY29tcGlsZXIgZ2l2ZXMgYSB3ZWlyZCBcIm1vbWVudCBjYW5ub3QgYmUgdXNlZCBhcyBhIG5hbWVzcGFjZVwiIHR5cGUgb2YgZXJyb3Jcbi8vIFRoaXMgaXMgdGhlIHdvcmthcm91bmQuLi5cbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3BobGliLWNoYXJ0JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2NoYXJ0LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vY2hhcnQuY29tcG9uZW50LmNzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDaGFydENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKVxuICBmbG93c2hlZXRzOiBBcnJheTxGbG93U2hlZXRCYXNlPjtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgZ3JhcGg6IFBlcmFHcmFwaDtcblxuICBASW5wdXQoKVxuICBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XG5cbiAgSGlnaGNoYXJ0cyA9IEhpZ2hjaGFydHM7XG4gIGNoYXJ0T3B0aW9ucztcblxuICBYX0FYSVNfREFZUyA9IDU7XG4gIERBWV9JTl9NSUxMSVNFQ09ORFMgPSA4NjQwMDAwMDtcblxuICBtaW5SaVNjb3JlID0gMDtcbiAgbWluUmVjb3JkZWREdCA9IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTtcbiAgbWF4UmVjb3JkZWREdCA9IDA7XG5cbiAgc2VyaWVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZVNlcnZpY2U6IERhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIGNoYXJ0U2VydmljZTogQ2hhcnRTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIGFycmF5Vmlld1NlcnZpY2U6IEFycmF5Vmlld1NlcnZpY2UsXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gTWFuYWdlIGNoYW5nZSBkZXRlY3Rpb24gZXhwbGljaXRseVxuICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgIC8vIEdldCB0aGUgc2VyaWVzXG4gICAgdGhpcy5zZXJpZXMgPSB0aGlzLmdldENoYXJ0U2VyaWVzKCk7XG4gICAgLy8gQnVpbGQgdGhlIGNoYXJ0IG9wdGlvbnNcbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCk7XG4gICAgLy8gVHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgYSBjaGFydCBhbHJlYWR5IGV4aXN0c1xuICAgIGlmICh0aGlzLkhpZ2hjaGFydHMgJiYgdGhpcy5jaGFydE9wdGlvbnMpIHtcbiAgICAgIC8vIEZldGNoIHRoZSBzZXJpZXMgdXNpbmcgdGhlIGxhdGVzdCBmbG93c2hlZXQgaW5mb3JtYXRpb25cbiAgICAgIHRoaXMuc2VyaWVzID0gdGhpcy5nZXRDaGFydFNlcmllcygpO1xuICAgICAgLy8gSWYgdGhlIHNlcmllcyBpcyBkaWZmZXJlbnRcbiAgICAgIGlmICh0aGlzLnNlcmllcyAhPT0gdGhpcy5jaGFydE9wdGlvbnMuc2VyaWVzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTtcbiAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMgPSB7Li4udGhpcy5jaGFydE9wdGlvbnN9O1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICB0aGlzLnJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2hhcnRcbiAgICovXG4gIHVwZGF0ZUNoYXJ0KCkge1xuICAgIHRoaXMuY2hhcnRPcHRpb25zLnNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgIHRoaXMudXBkYXRlWEF4aXMoKTtcbiAgICB0aGlzLnVwZGF0ZVlBeGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGllY2VzIG9mIHRoZSBZIGF4aXMgdGhhdCBuZWVkIHVwZGF0aW5nXG4gICAqL1xuICB1cGRhdGVZQXhpcygpIHtcbiAgICBjb25zdCBtaW5ZQXhpc1RpY2sgPSB0aGlzLmNoYXJ0U2VydmljZS5nZXRNaW5ZQXhpc1RpY2sodGhpcy5taW5SaVNjb3JlKTtcbiAgICAvLyBJZiB0aGUgbWluIFkgYXhpcyB2YWx1ZSB3b3VsZCBjaGFuZ2UsIHVwZGF0ZSBpdFxuICAgIGlmICh0aGlzLmNoYXJ0T3B0aW9ucy55QXhpc1swXS5taW4gIT09IG1pbllBeGlzVGljaykge1xuICAgICAgdGhpcy5jaGFydE9wdGlvbnMueUF4aXNbMF0ubWluID0gbWluWUF4aXNUaWNrO1xuICAgICAgdGhpcy5jaGFydE9wdGlvbnMueUF4aXNbMF0ucGxvdExpbmVzID0gdGhpcy5jaGFydFNlcnZpY2UuY3JlYXRlWmVyb0F4aXNMaW5lKHRoaXMubWluUmlTY29yZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBpZWNlcyBvZiB0aGUgWCBheGlzIHRoYXQgbmVlZCB1cGRhdGluZ1xuICAgKi9cbiAgdXBkYXRlWEF4aXMoKSB7XG4gICAgdGhpcy5jaGFydE9wdGlvbnMueEF4aXMgPSB0aGlzLmdldFhheGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hhcnQgb3B0aW9uc1xuICAgKi9cbiAgZ2V0Q2hhcnRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydDoge1xuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIHNwYWNpbmc6IFsyLCAwLCAwLCAwXSxcbiAgICAgICAgbWFyZ2luTGVmdDogMTgsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAyLFxuICAgICAgICBwbG90QmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICByZWZsb3c6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgICBhbGlnblRpY2tzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICBjb2xvcjogJyM4NDg0ODQnLFxuICAgICAgICAgIHR1cmJvVGhyZXNob2xkOiAwLFxuICAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlTW91c2VUcmFja2luZzogZmFsc2UsXG4gICAgICAgICAgc3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgIHNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgdGV4dFNoYWRvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgICAgIGVuYWJsZU1vdXNlVHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgIHN0aWNreVRyYWNraW5nOiBmYWxzZSxcbiAgICAgICAgICBzaGFkb3c6IGZhbHNlLFxuICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHRleHRTaGFkb3c6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlZGl0czoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6ICcnXG4gICAgICB9LFxuICAgICAgeEF4aXM6IHRoaXMuZ2V0WGF4aXMoKSxcbiAgICAgIHlBeGlzOiB0aGlzLmdldFlheGlzKCksXG4gICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzXG4gICAgfTtcbiAgfVxuXG4gIGdldFhheGlzKCkge1xuICAgIGNvbnN0IHhBeGlzID0gW107XG4gICAgeEF4aXMucHVzaCh7XG4gICAgICB0eXBlOiAnZGF0ZXRpbWUnLFxuICAgICAgc3RhcnRPblRpY2s6IGZhbHNlLFxuICAgICAgZW5kT25UaWNrOiBmYWxzZSxcbiAgICAgIHRpY2tJbnRlcnZhbDogdGhpcy5ncmFwaC5pc0Rpc2NoYXJnZWQgPyBudWxsIDogdGhpcy5EQVlfSU5fTUlMTElTRUNPTkRTLFxuICAgICAgZ3JpZExpbmVXaWR0aDogMSxcbiAgICAgIHBsb3RMaW5lczogdGhpcy5jaGFydFNlcnZpY2UudXBkYXRlQWxlcnRQbG90TGluZSh0aGlzLmdyYXBoKSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6ICcgJ1xuICAgICAgfSxcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBkaXN0YW5jZTogMjAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcuNmVtJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMudmFsdWUpLnV0Y09mZnNldCgwKS5mb3JtYXQoJ01NL0REJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IDFcbiAgICAgIH0sXG4gICAgICBtaW46IHRoaXMuZ2V0TWluWEF4aXNWYWx1ZSgpLFxuICAgICAgbWF4OiB0aGlzLmdldE1heFhBeGlzVmFsdWUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4geEF4aXM7XG4gIH1cblxuICBnZXRNYXhYQXhpc1ZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5ncmFwaC5kaXNjaGFyZ2VkKSA/IG51bGwgOiB0aGlzLmRhdGVTZXJ2aWNlLnRyYW5zbGF0ZURhdGUodGhpcy5hcnJheVZpZXdTZXJ2aWNlLmdldEN1cnJlbnRUaW1lc3RhbXAoKSwgdGhpcy5ncmFwaC50aW1lWm9uZSk7XG4gIH1cblxuICBnZXRNaW5YQXhpc1ZhbHVlKCkge1xuICAgIHJldHVybiAodGhpcy5ncmFwaC5kaXNjaGFyZ2VkKSA/IG51bGwgOiB0aGlzLmRhdGVTZXJ2aWNlLnRyYW5zbGF0ZURhdGUoXG4gICAgICB0aGlzLmFycmF5Vmlld1NlcnZpY2UuZ2V0Q3VycmVudFRpbWVzdGFtcCgpLCB0aGlzLmdyYXBoLnRpbWVab25lKSAtIHRoaXMuWF9BWElTX0RBWVMgKiB0aGlzLkRBWV9JTl9NSUxMSVNFQ09ORFM7XG4gIH1cblxuICBnZXRZYXhpcygpIHtcbiAgICBjb25zdCB5QXhpcyA9IFtdO1xuICAgIHlBeGlzLnB1c2goe1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogJyAnXG4gICAgICB9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcuNmVtJ1xuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICBhbGlnbjogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6IC0xMixcbiAgICAgIC8vICAgICBncmlkTGluZUNvbG9yIDogY29sb3JIZWFsdGhTY29yZUdyaWRMaW5lLFxuICAgICAgZ3JpZExpbmVXaWR0aDogMSxcbiAgICAgIG1pbjogdGhpcy5jaGFydFNlcnZpY2UuZ2V0TWluWUF4aXNUaWNrKHRoaXMubWluUmlTY29yZSksXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHBsb3RMaW5lczogdGhpcy5jaGFydFNlcnZpY2UuY3JlYXRlWmVyb0F4aXNMaW5lKHRoaXMubWluUmlTY29yZSksXG4gICAgICB0aWNrUG9zaXRpb25lcjogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG5cbiAgICAgICAgbGV0IHRpY2sgPSBtaW47XG4gICAgICAgIGNvbnN0IHRpY2tzID0gW107XG5cbiAgICAgICAgd2hpbGUgKHRpY2sgPD0gbWF4KSB7XG4gICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgICB0aWNrICs9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHlBeGlzO1xuICB9XG5cbiAgZ2V0Q2hhcnRTZXJpZXMoKSB7XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgc2VyaWVzLnB1c2goe1xuICAgICAgbmFtZTogJycsXG4gICAgICBkYXRhOiB0aGlzLmdldERhdGFQb2ludHModGhpcy5mbG93c2hlZXRzKSxcbiAgICAgIHNob3dJbkxlZ2VuZDogZmFsc2UsXG4gICAgICB0dXJib1RocmVzaG9sZDogMCxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGxpbmVhckdyYWRpZW50OiB7eDE6IDAsIHgyOiAxLCB5MTogMCwgeTI6IDB9LFxuICAgICAgICBzdG9wczogdGhpcy5nZXRBcnJheU9mTG9jYXRpb25DaGFuZ2VzKHRoaXMuZmxvd3NoZWV0cylcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZDogKHRoaXMuZmxvd3NoZWV0cyAmJiB0aGlzLmZsb3dzaGVldHMubGVuZ3RoID09PSAxKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgY29sb3I6ICh0aGlzLmZsb3dzaGVldHMgJiYgdGhpcy5mbG93c2hlZXRzLmxlbmd0aCA9PT0gMSkgPyB0aGlzLmNoYXJ0U2VydmljZS5nZXRNYXJrZXJDb2xvcih0aGlzLmZsb3dzaGVldHNbMF0udW5pdFR5cGUpIDogbnVsbCxcbiAgICAgICAgcmFkaXVzOiAxLjVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWVzO1xuICB9XG5cbiAgZ2V0QXJyYXlPZkxvY2F0aW9uQ2hhbmdlcyhmc2NMaXN0KSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLm1heFJlY29yZGVkRHQgLSB0aGlzLm1pblJlY29yZGVkRHQ7XG4gICAgY29uc3QgY29sb3JzID0gW1swLCAnYmxhY2snXV07XG4gICAgbGV0IGNvbG9yID0gJ2JsYWNrJztcbiAgICBsZXQgdW5pdFR5cGUgPSBudWxsO1xuICAgIGxldCB4dmFsID0gMDtcblxuICAgIGlmIChmc2NMaXN0ICYmIHJhbmdlID4gMCkge1xuICAgICAgZnNjTGlzdC5mb3JFYWNoKChmc2MpID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIHVuaXQgdHlwZSBjaGFuZ2VkXG4gICAgICAgIGlmIChmc2MudW5pdFR5cGUgIT09IHVuaXRUeXBlKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBwZXJjZW50YWdlIGFjcm9zcyB0aGUgWCBheGlzIGJ5IHJlY29yZGVkIGRhdGVcbiAgICAgICAgICB4dmFsID0gKGZzYy5rZXkucmVjb3JkZWREdCAtIHRoaXMubWluUmVjb3JkZWREdCkgLyByYW5nZTtcbiAgICAgICAgICAvLyBhZGQgYW4gZW50cnkganVzdCBwcmlvciB0byB0aGlzIHBvaW50IHRvIHNtb290aCB0aGUgZ3JhZGllbnRcbiAgICAgICAgICBjb2xvcnMucHVzaChbeHZhbCAtIC4wMDAxLCBjb2xvcl0pO1xuICAgICAgICAgIC8vIFRoZSB0aGUgYXBwcm9wcmlhdGUgY29sb3IgZm9yIHRoaXMgdW5pdFR5cGVcbiAgICAgICAgICBjb2xvciA9IHRoaXMuY2hhcnRTZXJ2aWNlLmdldE1hcmtlckNvbG9yKGZzYy51bml0VHlwZSk7XG4gICAgICAgICAgLy8gUHVzaCB0aGUgY2hhbmdlIGluIGNvbG9yXG4gICAgICAgICAgY29sb3JzLnB1c2goW3h2YWwsIGNvbG9yXSk7XG4gICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgdW5pdCB0eXBlXG4gICAgICAgICAgdW5pdFR5cGUgPSBmc2MudW5pdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcnM7XG4gIH1cblxuICBnZXREYXRhUG9pbnRzKGRhdGEpIHtcbiAgICBjb25zdCBkYXRhUG9pbnRzID0gW107XG4gICAgLy8gUmVzZXQgdGhlIHZhcmlhYmxlc1xuICAgIHRoaXMubWluUmlTY29yZSA9IDEwMDtcbiAgICB0aGlzLm1pblJlY29yZGVkRHQgPSA5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XG4gICAgdGhpcy5tYXhSZWNvcmRlZER0ID0gMDtcblxuICAgIC8vIElmIHdlIGhhdmUgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhLmZvckVhY2goKGZzYykgPT4ge1xuICAgICAgICBkYXRhUG9pbnRzLnB1c2goW3RoaXMuZGF0ZVNlcnZpY2UudHJhbnNsYXRlRGF0ZShmc2Mua2V5LnJlY29yZGVkRHQsIHRoaXMuZ3JhcGgudGltZVpvbmUpLCBmc2MucmlTY29yZSArIChNYXRoLnJhbmRvbSgpIC8gMTAwMCldKTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZXh0cmVtZSB2YWx1ZXMgLSB0aGV5IGFyZSB1c2VkIGVsc2V3aGVyZVxuICAgICAgICB0aGlzLm1pblJlY29yZGVkRHQgPSAodGhpcy5taW5SZWNvcmRlZER0ID4gZnNjLmtleS5yZWNvcmRlZER0KSA/IGZzYy5rZXkucmVjb3JkZWREdCA6IHRoaXMubWluUmVjb3JkZWREdDtcbiAgICAgICAgdGhpcy5tYXhSZWNvcmRlZER0ID0gKHRoaXMubWF4UmVjb3JkZWREdCA8IGZzYy5rZXkucmVjb3JkZWREdCkgPyBmc2Mua2V5LnJlY29yZGVkRHQgOiB0aGlzLm1heFJlY29yZGVkRHQ7XG4gICAgICAgIHRoaXMubWluUmlTY29yZSA9ICh0aGlzLm1pblJpU2NvcmUgPiBmc2MucmlTY29yZSkgPyBmc2MucmlTY29yZSA6IHRoaXMubWluUmlTY29yZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVBvaW50cztcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYuZGV0YWNoKCk7XG4gICAgICB0aGlzLnJlZiA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iXX0=