/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input } from '@angular/core';
import { ArrayViewService } from '../../service/array-view.service';
import { PeraGraphService } from './service/pera-graph.service';
import { HttpClient } from '@angular/common/http';
import { TooltipService } from './service/tooltip.service';
import { FlowsheetsApiService, UsageApiService, UsageType } from 'ng-common-library';
import { PriorWarningsApiService } from '../../service/prior-warnings/api/prior-warnings-api.service';
export class PeraGraphComponent {
    /**
     * @param {?} service
     * @param {?} flowsheetsApiService
     * @param {?} priorWarningsApiService
     * @param {?} usageService
     * @param {?} graphService
     * @param {?} toolTipService
     * @param {?} http
     * @param {?} ref
     */
    constructor(service, flowsheetsApiService, priorWarningsApiService, usageService, graphService, toolTipService, http, ref) {
        this.service = service;
        this.flowsheetsApiService = flowsheetsApiService;
        this.priorWarningsApiService = priorWarningsApiService;
        this.usageService = usageService;
        this.graphService = graphService;
        this.toolTipService = toolTipService;
        this.http = http;
        this.ref = ref;
        this.margin = 10;
        this.isMouseOverPeraGraph = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscribeToPeraGraphDataFeeds();
        this.subscribeToToolTipInfoEvent();
        this.style = {
            width: this.peraGraphWidth - this.margin + 'px',
            height: this.peraGraphHeight - this.margin + 'px'
        };
        this.usageService.addUsageData(this.graph, UsageType.Array);
        // Manage change detection explicitly
        this.ref.detach();
    }
    /**
     * Subscribe to the interval observables/subjects that pass information the PeraGraph needs
     *
     * Currently, this includes prior warnings and flowsheets
     * @return {?}
     */
    subscribeToPeraGraphDataFeeds() {
        this.flowSheetMap$ = this.flowsheetsApiService.getFlowSheetSubject().subscribe((fscMap) => {
            this.getFlowSheetsForVisit(fscMap);
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
        this.priorWarningMap$ = this.priorWarningsApiService.getPriorWarningSubject().subscribe((pwMap) => {
            this.getPriorWarningsForVisit(pwMap);
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
    }
    /**
     * @return {?}
     */
    subscribeToToolTipInfoEvent() {
        this.toolTipInfoEvent$ = this.toolTipService.toolTipInfoUpdated$.subscribe((toolTipInfo) => {
            // Ensure that the user hasn't moved onto a new graph with a different during the time that the call was made to the server
            if (this.isMouseOverPeraGraph && toolTipInfo.visitId === this.graph.visitId) {
                // If the service takes a second to respond and the popover is no longer there, don't try to open it
                if (this.tooltip) {
                    this.graphService.tooltip = this.tooltip;
                    this.tooltip.open();
                }
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        });
    }
    /**
     * This only fires when the user passes the mouse over the graph to get the tooltip.
     * For those graphs, force a change detection cycle so that the ToolTip component updates.
     * @param {?} po
     * @return {?}
     */
    mouseEnterHandler(po) {
        if (!this.isMouseOverPeraGraph && !po.isOpen()) {
            this.isMouseOverPeraGraph = true;
            this.tooltip = po;
            if (this.graph) {
                // Close any existing tooltip
                this.graphService.closeToolTip();
                this.toolTipService.updateToolTipInfo(this.graph);
            }
        }
    }
    /**
     * This fires when the user passes the mouse over the graph, and then moves the mouse off of the graph
     * For those graphs, close the tooltip
     *
     * @param {?} po
     * @return {?}
     */
    mouseLeaveHandler(po) {
        this.isMouseOverPeraGraph = false;
        if (po.isOpen()) {
            po.close();
        }
    }
    /**
     * @param {?} graph
     * @return {?}
     */
    graphClicked(graph) {
        if (this.tooltip && this.tooltip.isOpen()) {
            // console.log('Forcefully closing tooltip');
            this.tooltip.close();
            this.tooltip = null;
        }
        this.graphService.graphClickedEvent(graph);
        this.service.tokenRefresh$.next();
    }
    /**
     * @param {?} po
     * @return {?}
     */
    isShown(po) {
        if (!this.tooltip) {
            // Closing tooltip
            setTimeout(() => po.close(), 1);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // If the item size changed, update style
        if (changes && changes.peraGraphWidth && changes.peraGraphWidth.previousValue !== changes.peraGraphWidth.currentValue) {
            this.style = {
                width: this.peraGraphWidth - this.margin + 'px',
                height: this.peraGraphHeight - this.margin + 'px'
            };
        }
        // If the graph changed, update the related data so that we're showing the right information
        if (changes &&
            changes.graph &&
            changes.graph.currentValue !== changes.graph.previousValue &&
            !changes.graph.firstChange &&
            changes.graph.currentValue.visitId !== changes.graph.previousValue.visitId) {
            // console.log('ArrayView change: Adding usage data for ' + this.graph.vnm);
            this.usageService.addUsageData(this.graph, UsageType.Array);
            // The graph that we're displaying changed so get the new FSCs from the map
            /** @type {?} */
            const fscMap = this.flowsheetsApiService.getFlowSheetSubjectValue();
            this.getFlowSheetsForVisit(fscMap);
            // Get the prior warning for this graph instead of the stale graph
            /** @type {?} */
            const priorWarnings = this.priorWarningsApiService.getPriorWarningSubjectValue();
            this.getPriorWarningsForVisit(priorWarnings);
            // Push the changes
            if (this.ref) {
                this.ref.detectChanges();
            }
        }
    }
    /**
     * @param {?} fscMap
     * @return {?}
     */
    getFlowSheetsForVisit(fscMap) {
        if (fscMap) {
            /** @type {?} */
            const fsc = fscMap[this.graph.visitId];
            // Update the RI-related fields if necessary
            if (fsc && !(this.flowsheets === fsc) && JSON.stringify(this.flowsheets) !== JSON.stringify(fsc)) {
                // Note this may trigger extra changes based on how browsers handle JSON object order
                this.flowsheets = fsc;
                this.latestRi = fsc[this.flowsheets.length - 1].riScore;
            }
            else if (!fsc && this.flowsheets !== null) {
                // Clear the RI-related fields
                this.flowsheets = [];
                this.latestRi = null;
            }
        }
    }
    /**
     * @param {?} priorWarnings
     * @return {?}
     */
    getPriorWarningsForVisit(priorWarnings) {
        if (priorWarnings) {
            /** @type {?} */
            const pw = priorWarnings[this.graph.visitId];
            // TODO can we set this.priorWarning = pw without the logic below?
            // If we have a prior warning and it's not the same, trigger a change
            if (pw && pw !== this.priorWarning) {
                this.priorWarning = pw;
            }
            else if (!pw) {
                // No prior warning exists, update our prior warning to reflect this
                this.priorWarning = null;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
        // Unsubscribe when the component is destroyed
        if (this.flowSheetMap$ && !this.flowSheetMap$.closed) {
            this.flowSheetMap$.unsubscribe();
        }
        if (this.priorWarningMap$ && !this.priorWarningMap$.closed) {
            this.priorWarningMap$.unsubscribe();
        }
        if (this.toolTipInfoEvent$ && !this.toolTipInfoEvent$.closed) {
            this.toolTipInfoEvent$.unsubscribe();
        }
    }
}
PeraGraphComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-pera-graph',
                template: "<div class=\"ph-pera-graph\"\n     id=\"{{ graph.vnm }}\"\n     (click)=\"graphClicked(graph)\"\n     [ngStyle]=\"style\">\n\n    <phlib-pera-graph-tile *ngIf=\"service.isDisplayingTiles();else displayPeraGraph\" [graph]=\"graph\"\n                           [latestRi]=\"latestRi\" [priorWarning]=\"priorWarning\"\n                           (mouseenter)=\"mouseEnterHandler(po)\"\n                           (mouseleave)=\"mouseLeaveHandler(po)\"\n                           #po=\"ngbPopover\"\n                           class=\"width-adjustment\"\n                           [ngbPopover]=\"popTemplate\"\n                           [autoClose]=\"true\"\n                           popoverTitle=\"Visit Info\"\n                           placement=\"auto\"\n                           triggers=\"manual\"\n                           container='body'>\n              <ng-template #popTemplate>\n                <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n              </ng-template>\n    </phlib-pera-graph-tile>\n\n    <ng-template #displayPeraGraph>\n      <phlib-pera-graph-header class=\"peraGraphHeader\"\n                               [graph]=\"graph\"\n                               [latestRi]=\"latestRi\"\n                               [priorWarning]=\"priorWarning\"></phlib-pera-graph-header>\n      <phlib-chart\n          [graph]=\"graph\"\n          [flowsheets]=\"flowsheets\"\n          class=\"width-adjustment\"\n          (mouseenter)=\"mouseEnterHandler(po)\"\n          (mouseleave)=\"mouseLeaveHandler(po)\"\n          #po=\"ngbPopover\"\n          [ngbPopover]=\"popTemplate\"\n          [autoClose]=\"true\"\n          (shown)=\"isShown(po)\"\n          triggers=\"manual\"\n          popoverTitle=\"Visit Info\"\n          placement=\"auto\"\n          container='body'>\n        </phlib-chart>\n        <ng-template #popTemplate>\n          <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n        </ng-template>\n    </ng-template>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ph-pera-graph{border:1px solid #000;padding-top:auto;margin-right:5px;background-color:#fff!important;display:inline-flex;position:relative}.width-adjustment{width:inherit}"]
            }] }
];
/** @nocollapse */
PeraGraphComponent.ctorParameters = () => [
    { type: ArrayViewService },
    { type: FlowsheetsApiService },
    { type: PriorWarningsApiService },
    { type: UsageApiService },
    { type: PeraGraphService },
    { type: TooltipService },
    { type: HttpClient },
    { type: ChangeDetectorRef }
];
PeraGraphComponent.propDecorators = {
    graph: [{ type: Input }],
    peraGraphWidth: [{ type: Input }],
    peraGraphHeight: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PeraGraphComponent.prototype.graph;
    /** @type {?} */
    PeraGraphComponent.prototype.peraGraphWidth;
    /** @type {?} */
    PeraGraphComponent.prototype.peraGraphHeight;
    /** @type {?} */
    PeraGraphComponent.prototype.style;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.margin;
    /** @type {?} */
    PeraGraphComponent.prototype.flowsheets;
    /** @type {?} */
    PeraGraphComponent.prototype.priorWarning;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.flowSheetMap$;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.priorWarningMap$;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.toolTipInfoEvent$;
    /** @type {?} */
    PeraGraphComponent.prototype.latestRi;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.isMouseOverPeraGraph;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.tooltip;
    /** @type {?} */
    PeraGraphComponent.prototype.service;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.flowsheetsApiService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.priorWarningsApiService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.usageService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.graphService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.toolTipService;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.http;
    /**
     * @type {?}
     * @private
     */
    PeraGraphComponent.prototype.ref;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyYS1ncmFwaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1hcnJheS12aWV3LWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvZ3JvdXAvcGVyYS1ncmFwaC9wZXJhLWdyYXBoLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFLUixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNsRSxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUU5RCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRXpELE9BQU8sRUFBQyxvQkFBb0IsRUFBYSxlQUFlLEVBQUUsU0FBUyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDOUYsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sNkRBQTZELENBQUM7QUFVcEcsTUFBTSxPQUFPLGtCQUFrQjs7Ozs7Ozs7Ozs7SUF1QjNCLFlBQW1CLE9BQXlCLEVBQ3hCLG9CQUEwQyxFQUMxQyx1QkFBZ0QsRUFDaEQsWUFBNkIsRUFDN0IsWUFBOEIsRUFDOUIsY0FBOEIsRUFDOUIsSUFBZ0IsRUFDaEIsR0FBc0I7UUFQdkIsWUFBTyxHQUFQLE9BQU8sQ0FBa0I7UUFDeEIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQUMxQyw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXlCO1FBQ2hELGlCQUFZLEdBQVosWUFBWSxDQUFpQjtRQUM3QixpQkFBWSxHQUFaLFlBQVksQ0FBa0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsUUFBRyxHQUFILEdBQUcsQ0FB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QUFNLEVBQUU7WUFDeEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3ZDO1FBQ0QsSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFO1lBQzFELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN4QztJQUNMLENBQUM7OztZQW5OSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGtCQUFrQjtnQkFDNUIsbStEQUEwQztnQkFFMUMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O2FBQ2xEOzs7O1lBaEJPLGdCQUFnQjtZQU1oQixvQkFBb0I7WUFDcEIsdUJBQXVCO1lBRFUsZUFBZTtZQUxoRCxnQkFBZ0I7WUFHaEIsY0FBYztZQURkLFVBQVU7WUFYZCxpQkFBaUI7OztvQkEyQmhCLEtBQUs7NkJBR0wsS0FBSzs4QkFHTCxLQUFLOzs7O0lBTk4sbUNBQ3dCOztJQUV4Qiw0Q0FDOEI7O0lBRTlCLDZDQUMrQjs7SUFFL0IsbUNBQWE7Ozs7O0lBQ2Isb0NBQW9COztJQUVwQix3Q0FBd0M7O0lBQ3hDLDBDQUE0Qjs7Ozs7SUFDNUIsMkNBQW9DOzs7OztJQUNwQyw4Q0FBdUM7Ozs7O0lBQ3ZDLCtDQUF3Qzs7SUFDeEMsc0NBQXdCOzs7OztJQUN4QixrREFBcUM7Ozs7O0lBQ3JDLHFDQUE0Qjs7SUFFaEIscUNBQWdDOzs7OztJQUNoQyxrREFBa0Q7Ozs7O0lBQ2xELHFEQUF3RDs7Ozs7SUFDeEQsMENBQXFDOzs7OztJQUNyQywwQ0FBc0M7Ozs7O0lBQ3RDLDRDQUFzQzs7Ozs7SUFDdEMsa0NBQXdCOzs7OztJQUN4QixpQ0FBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBcnJheVZpZXdTZXJ2aWNlfSBmcm9tICcuLi8uLi9zZXJ2aWNlL2FycmF5LXZpZXcuc2VydmljZSc7XG5pbXBvcnQge1BlcmFHcmFwaFNlcnZpY2V9IGZyb20gJy4vc2VydmljZS9wZXJhLWdyYXBoLnNlcnZpY2UnO1xuaW1wb3J0IHtOZ2JQb3BvdmVyfSBmcm9tICdAbmctYm9vdHN0cmFwL25nLWJvb3RzdHJhcCc7XG5pbXBvcnQge0h0dHBDbGllbnR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7VG9vbHRpcFNlcnZpY2V9IGZyb20gJy4vc2VydmljZS90b29sdGlwLnNlcnZpY2UnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtGbG93c2hlZXRzQXBpU2VydmljZSwgUGVyYUdyYXBoLCBVc2FnZUFwaVNlcnZpY2UsIFVzYWdlVHlwZX0gZnJvbSAnbmctY29tbW9uLWxpYnJhcnknO1xuaW1wb3J0IHtQcmlvcldhcm5pbmdzQXBpU2VydmljZX0gZnJvbSAnLi4vLi4vc2VydmljZS9wcmlvci13YXJuaW5ncy9hcGkvcHJpb3Itd2FybmluZ3MtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHtGbG93U2hlZXRCYXNlfSBmcm9tICduZy1jb21tb24tbGlicmFyeS9saWIvbW9kZWwvRmxvd1NoZWV0QmFzZSc7XG5pbXBvcnQge1Rvb2x0aXBJbmZvfSBmcm9tICcuLi8uLi9tb2RlbC9Ub29sdGlwSW5mbyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncGhsaWItcGVyYS1ncmFwaCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3BlcmEtZ3JhcGguY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3BlcmEtZ3JhcGguY29tcG9uZW50LmNzcyddLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFBlcmFHcmFwaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMge1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ3JhcGg6IFBlcmFHcmFwaDtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHBlcmFHcmFwaFdpZHRoOiBudW1iZXI7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBwZXJhR3JhcGhIZWlnaHQ6IG51bWJlcjtcblxuICAgIHB1YmxpYyBzdHlsZTtcbiAgICBwcml2YXRlIG1hcmdpbiA9IDEwO1xuXG4gICAgcHVibGljIGZsb3dzaGVldHM6IEFycmF5PEZsb3dTaGVldEJhc2U+O1xuICAgIHB1YmxpYyBwcmlvcldhcm5pbmc6IHN0cmluZztcbiAgICBwcml2YXRlIGZsb3dTaGVldE1hcCQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIHByaW9yV2FybmluZ01hcCQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIHRvb2xUaXBJbmZvRXZlbnQkOiBTdWJzY3JpcHRpb247XG4gICAgcHVibGljIGxhdGVzdFJpOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBpc01vdXNlT3ZlclBlcmFHcmFwaCA9IGZhbHNlO1xuICAgIHByaXZhdGUgdG9vbHRpcDogTmdiUG9wb3ZlcjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXJ2aWNlOiBBcnJheVZpZXdTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZmxvd3NoZWV0c0FwaVNlcnZpY2U6IEZsb3dzaGVldHNBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcHJpb3JXYXJuaW5nc0FwaVNlcnZpY2U6IFByaW9yV2FybmluZ3NBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNhZ2VTZXJ2aWNlOiBVc2FnZUFwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBncmFwaFNlcnZpY2U6IFBlcmFHcmFwaFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0b29sVGlwU2VydmljZTogVG9vbHRpcFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvUGVyYUdyYXBoRGF0YUZlZWRzKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Ub29sVGlwSW5mb0V2ZW50KCk7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5wZXJhR3JhcGhXaWR0aCAtIHRoaXMubWFyZ2luICsgJ3B4JyxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5wZXJhR3JhcGhIZWlnaHQgLSB0aGlzLm1hcmdpbiArICdweCdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51c2FnZVNlcnZpY2UuYWRkVXNhZ2VEYXRhKHRoaXMuZ3JhcGgsIFVzYWdlVHlwZS5BcnJheSk7XG4gICAgICAgIC8vIE1hbmFnZSBjaGFuZ2UgZGV0ZWN0aW9uIGV4cGxpY2l0bHlcbiAgICAgICAgdGhpcy5yZWYuZGV0YWNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBpbnRlcnZhbCBvYnNlcnZhYmxlcy9zdWJqZWN0cyB0aGF0IHBhc3MgaW5mb3JtYXRpb24gdGhlIFBlcmFHcmFwaCBuZWVkc1xuICAgICAqXG4gICAgICogQ3VycmVudGx5LCB0aGlzIGluY2x1ZGVzIHByaW9yIHdhcm5pbmdzIGFuZCBmbG93c2hlZXRzXG4gICAgICovXG4gICAgc3Vic2NyaWJlVG9QZXJhR3JhcGhEYXRhRmVlZHMoKSB7XG4gICAgICAgIHRoaXMuZmxvd1NoZWV0TWFwJCA9IHRoaXMuZmxvd3NoZWV0c0FwaVNlcnZpY2UuZ2V0Rmxvd1NoZWV0U3ViamVjdCgpLnN1YnNjcmliZSgoZnNjTWFwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldEZsb3dTaGVldHNGb3JWaXNpdChmc2NNYXApO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnByaW9yV2FybmluZ01hcCQgPSB0aGlzLnByaW9yV2FybmluZ3NBcGlTZXJ2aWNlLmdldFByaW9yV2FybmluZ1N1YmplY3QoKS5zdWJzY3JpYmUoKHB3TWFwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldFByaW9yV2FybmluZ3NGb3JWaXNpdChwd01hcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN1YnNjcmliZVRvVG9vbFRpcEluZm9FdmVudCgpIHtcbiAgICAgICAgdGhpcy50b29sVGlwSW5mb0V2ZW50JCA9IHRoaXMudG9vbFRpcFNlcnZpY2UudG9vbFRpcEluZm9VcGRhdGVkJC5zdWJzY3JpYmUoKHRvb2xUaXBJbmZvOiBUb29sdGlwSW5mbykgPT4ge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHVzZXIgaGFzbid0IG1vdmVkIG9udG8gYSBuZXcgZ3JhcGggd2l0aCBhIGRpZmZlcmVudCBkdXJpbmcgdGhlIHRpbWUgdGhhdCB0aGUgY2FsbCB3YXMgbWFkZSB0byB0aGUgc2VydmVyXG4gICAgICAgICAgICBpZiAodGhpcy5pc01vdXNlT3ZlclBlcmFHcmFwaCAmJiB0b29sVGlwSW5mby52aXNpdElkID09PSB0aGlzLmdyYXBoLnZpc2l0SWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VydmljZSB0YWtlcyBhIHNlY29uZCB0byByZXNwb25kIGFuZCB0aGUgcG9wb3ZlciBpcyBubyBsb25nZXIgdGhlcmUsIGRvbid0IHRyeSB0byBvcGVuIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoU2VydmljZS50b29sdGlwID0gdGhpcy50b29sdGlwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvbmx5IGZpcmVzIHdoZW4gdGhlIHVzZXIgcGFzc2VzIHRoZSBtb3VzZSBvdmVyIHRoZSBncmFwaCB0byBnZXQgdGhlIHRvb2x0aXAuXG4gICAgICogRm9yIHRob3NlIGdyYXBocywgZm9yY2UgYSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlIHNvIHRoYXQgdGhlIFRvb2xUaXAgY29tcG9uZW50IHVwZGF0ZXMuXG4gICAgICovXG4gICAgbW91c2VFbnRlckhhbmRsZXIocG86IE5nYlBvcG92ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTW91c2VPdmVyUGVyYUdyYXBoICYmICFwby5pc09wZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5pc01vdXNlT3ZlclBlcmFHcmFwaCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBwbztcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgYW55IGV4aXN0aW5nIHRvb2x0aXBcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoU2VydmljZS5jbG9zZVRvb2xUaXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xUaXBTZXJ2aWNlLnVwZGF0ZVRvb2xUaXBJbmZvKHRoaXMuZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmaXJlcyB3aGVuIHRoZSB1c2VyIHBhc3NlcyB0aGUgbW91c2Ugb3ZlciB0aGUgZ3JhcGgsIGFuZCB0aGVuIG1vdmVzIHRoZSBtb3VzZSBvZmYgb2YgdGhlIGdyYXBoXG4gICAgICogRm9yIHRob3NlIGdyYXBocywgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb1xuICAgICAqL1xuICAgIG1vdXNlTGVhdmVIYW5kbGVyKHBvOiBOZ2JQb3BvdmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNNb3VzZU92ZXJQZXJhR3JhcGggPSBmYWxzZTtcbiAgICAgICAgaWYgKHBvLmlzT3BlbigpKSB7XG4gICAgICAgICAgICBwby5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ3JhcGhDbGlja2VkKGdyYXBoOiBQZXJhR3JhcGgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcCAmJiB0aGlzLnRvb2x0aXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdGb3JjZWZ1bGx5IGNsb3NpbmcgdG9vbHRpcCcpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhTZXJ2aWNlLmdyYXBoQ2xpY2tlZEV2ZW50KGdyYXBoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnRva2VuUmVmcmVzaCQubmV4dCgpO1xuICAgIH1cblxuICAgIGlzU2hvd24ocG86IE5nYlBvcG92ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcbiAgICAgICAgICAgIC8vIENsb3NpbmcgdG9vbHRpcFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwby5jbG9zZSgpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGl0ZW0gc2l6ZSBjaGFuZ2VkLCB1cGRhdGUgc3R5bGVcbiAgICAgICAgaWYgKGNoYW5nZXMgJiYgY2hhbmdlcy5wZXJhR3JhcGhXaWR0aCAmJiBjaGFuZ2VzLnBlcmFHcmFwaFdpZHRoLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXMucGVyYUdyYXBoV2lkdGguY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnBlcmFHcmFwaFdpZHRoIC0gdGhpcy5tYXJnaW4gKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5wZXJhR3JhcGhIZWlnaHQgLSB0aGlzLm1hcmdpbiArICdweCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZ3JhcGggY2hhbmdlZCwgdXBkYXRlIHRoZSByZWxhdGVkIGRhdGEgc28gdGhhdCB3ZSdyZSBzaG93aW5nIHRoZSByaWdodCBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoY2hhbmdlcyAmJlxuICAgICAgICAgICAgY2hhbmdlcy5ncmFwaCAmJlxuICAgICAgICAgICAgY2hhbmdlcy5ncmFwaC5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZ3JhcGgucHJldmlvdXNWYWx1ZSAmJlxuICAgICAgICAgICAgIWNoYW5nZXMuZ3JhcGguZmlyc3RDaGFuZ2UgJiZcbiAgICAgICAgICAgIGNoYW5nZXMuZ3JhcGguY3VycmVudFZhbHVlLnZpc2l0SWQgIT09IGNoYW5nZXMuZ3JhcGgucHJldmlvdXNWYWx1ZS52aXNpdElkKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBcnJheVZpZXcgY2hhbmdlOiBBZGRpbmcgdXNhZ2UgZGF0YSBmb3IgJyArIHRoaXMuZ3JhcGgudm5tKTtcbiAgICAgICAgICAgIHRoaXMudXNhZ2VTZXJ2aWNlLmFkZFVzYWdlRGF0YSh0aGlzLmdyYXBoLCBVc2FnZVR5cGUuQXJyYXkpO1xuXG4gICAgICAgICAgICAvLyBUaGUgZ3JhcGggdGhhdCB3ZSdyZSBkaXNwbGF5aW5nIGNoYW5nZWQgc28gZ2V0IHRoZSBuZXcgRlNDcyBmcm9tIHRoZSBtYXBcbiAgICAgICAgICAgIGNvbnN0IGZzY01hcCA9IHRoaXMuZmxvd3NoZWV0c0FwaVNlcnZpY2UuZ2V0Rmxvd1NoZWV0U3ViamVjdFZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmdldEZsb3dTaGVldHNGb3JWaXNpdChmc2NNYXApO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBwcmlvciB3YXJuaW5nIGZvciB0aGlzIGdyYXBoIGluc3RlYWQgb2YgdGhlIHN0YWxlIGdyYXBoXG4gICAgICAgICAgICBjb25zdCBwcmlvcldhcm5pbmdzID0gdGhpcy5wcmlvcldhcm5pbmdzQXBpU2VydmljZS5nZXRQcmlvcldhcm5pbmdTdWJqZWN0VmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJpb3JXYXJuaW5nc0ZvclZpc2l0KHByaW9yV2FybmluZ3MpO1xuICAgICAgICAgICAgLy8gUHVzaCB0aGUgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rmxvd1NoZWV0c0ZvclZpc2l0KGZzY01hcCkge1xuICAgICAgICBpZiAoZnNjTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBmc2MgPSBmc2NNYXBbdGhpcy5ncmFwaC52aXNpdElkXTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgUkktcmVsYXRlZCBmaWVsZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoZnNjICYmICEodGhpcy5mbG93c2hlZXRzID09PSBmc2MpICYmIEpTT04uc3RyaW5naWZ5KHRoaXMuZmxvd3NoZWV0cykgIT09IEpTT04uc3RyaW5naWZ5KGZzYykpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoaXMgbWF5IHRyaWdnZXIgZXh0cmEgY2hhbmdlcyBiYXNlZCBvbiBob3cgYnJvd3NlcnMgaGFuZGxlIEpTT04gb2JqZWN0IG9yZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93c2hlZXRzID0gZnNjO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0UmkgPSBmc2NbdGhpcy5mbG93c2hlZXRzLmxlbmd0aCAtIDFdLnJpU2NvcmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmc2MgJiYgdGhpcy5mbG93c2hlZXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFJJLXJlbGF0ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93c2hlZXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RSaSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRQcmlvcldhcm5pbmdzRm9yVmlzaXQocHJpb3JXYXJuaW5ncykge1xuICAgICAgICBpZiAocHJpb3JXYXJuaW5ncykge1xuICAgICAgICAgICAgY29uc3QgcHcgPSBwcmlvcldhcm5pbmdzW3RoaXMuZ3JhcGgudmlzaXRJZF07XG4gICAgICAgICAgICAvLyBUT0RPIGNhbiB3ZSBzZXQgdGhpcy5wcmlvcldhcm5pbmcgPSBwdyB3aXRob3V0IHRoZSBsb2dpYyBiZWxvdz9cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcmlvciB3YXJuaW5nIGFuZCBpdCdzIG5vdCB0aGUgc2FtZSwgdHJpZ2dlciBhIGNoYW5nZVxuICAgICAgICAgICAgaWYgKHB3ICYmIHB3ICE9PSB0aGlzLnByaW9yV2FybmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JXYXJuaW5nID0gcHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwdykge1xuICAgICAgICAgICAgICAgIC8vIE5vIHByaW9yIHdhcm5pbmcgZXhpc3RzLCB1cGRhdGUgb3VyIHByaW9yIHdhcm5pbmcgdG8gcmVmbGVjdCB0aGlzXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcldhcm5pbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICAgICAgICBpZiAodGhpcy5mbG93U2hlZXRNYXAkICYmICF0aGlzLmZsb3dTaGVldE1hcCQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZsb3dTaGVldE1hcCQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmlvcldhcm5pbmdNYXAkICYmICF0aGlzLnByaW9yV2FybmluZ01hcCQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnByaW9yV2FybmluZ01hcCQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b29sVGlwSW5mb0V2ZW50JCAmJiAhdGhpcy50b29sVGlwSW5mb0V2ZW50JC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbFRpcEluZm9FdmVudCQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==