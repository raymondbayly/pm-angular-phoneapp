/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import * as moment_ from 'moment-timezone';
import { ArrayViewConfigService } from './array-view-config.service';
import { DateService, FlowsheetsApiService, PeragraphApiService } from 'ng-common-library';
import { FilterQueryRestService, FilterService, GroupService, SortService } from 'ng-filters-library';
import { BehaviorSubject, forkJoin, of, Subject } from 'rxjs';
import { ChartTitleChoices } from './chartTitleEnum';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./array-view-config.service";
import * as i3 from "ng-filters-library";
import * as i4 from "ng-common-library";
// The JavaScript compiler gives a weird "moment cannot be used as a namespace" type of error
// This is the workaround...
/** @type {?} */
const moment = moment_;
export class ArrayViewService {
    /**
     * @param {?} http
     * @param {?} configService
     * @param {?} filterService
     * @param {?} filterQueryRestService
     * @param {?} flowsheetsApiService
     * @param {?} peragraphApiService
     * @param {?} sortService
     * @param {?} groupService
     * @param {?} dateService
     */
    constructor(http, configService, filterService, filterQueryRestService, flowsheetsApiService, peragraphApiService, sortService, groupService, dateService) {
        this.http = http;
        this.configService = configService;
        this.filterService = filterService;
        this.filterQueryRestService = filterQueryRestService;
        this.flowsheetsApiService = flowsheetsApiService;
        this.peragraphApiService = peragraphApiService;
        this.sortService = sortService;
        this.groupService = groupService;
        this.dateService = dateService;
        // The possible chart title selections
        this.titleChoices = [
            {
                description: ChartTitleChoices.VNM,
                returnFunc: (peraGraph) => {
                    return peraGraph.vnm;
                }
            },
            {
                description: ChartTitleChoices.ADMIT_DATE,
                returnFunc: (peraGraph) => {
                    if (peraGraph && peraGraph.timeZone && peraGraph.admitDate) {
                        return this.dateService.getDateFormat(peraGraph.timeZone, peraGraph.admitDate, 'MM/DD/YY HH:mm z');
                    }
                    return '';
                }
            },
            {
                description: ChartTitleChoices.MRN,
                returnFunc: (peraGraph) => {
                    return peraGraph.patient.medicalRecordNumber;
                }
            },
            {
                description: ChartTitleChoices.PATIENT_NAME,
                returnFunc: (peraGraph) => {
                    if (peraGraph.vipIndicator) {
                        return peraGraph.patient.aliasLastName + ', ' + peraGraph.patient.aliasFirstName;
                    }
                    else {
                        return peraGraph.displayName;
                    }
                }
            },
            {
                description: ChartTitleChoices.LOCATION,
                returnFunc: (peraGraph) => {
                    return peraGraph.unitId + '-' + peraGraph.room + '-' + peraGraph.bed;
                }
            },
            {
                description: ChartTitleChoices.ANONYMOUS,
                returnFunc: (peraGraph) => {
                    return 'Chart ' + peraGraph.anonymous;
                }
            }
        ];
        // Current chart title selection - defaults to Patient Name
        this.selectedChartTitle = {
            description: ChartTitleChoices.PATIENT_NAME,
            returnFunc: (peraGraph) => {
                return peraGraph.displayName;
            }
        };
        // Subject for the title selection
        this.chartTitleSubject$ = new BehaviorSubject(this.selectedChartTitle);
        this.maxGraphCountPerGroup = 50;
        this.maxGraphsInDom = 150;
        this.currentTimestamp = null;
        this.displayTiles = false;
        this.peraGraphDefaultHeight = 145;
        this.peraGraphDefaultWidth = 185;
        this.peraGraphTileDefault = 75;
        this.peraGraphHeight = this.peraGraphDefaultHeight;
        this.peraGraphWidth = this.peraGraphDefaultWidth;
        this.startedRefresh$ = new Subject();
        this.completedRefresh$ = new Subject();
        this.tokenRefresh$ = new Subject();
    }
    /**
     * runs the peragraph through all the filters and returns true if none of them return false
     * @param {?} peraGraph - peragraph to evaluate
     * @param {?} filters - object of filter functions
     * @return {?}
     */
    filterPeragraph(peraGraph, filters) {
        // return true if filter object has no properties
        if ((Object.keys(filters).length === 0 && filters.constructor === Object)) {
            return true;
        }
        else {
            // traverse filter object and test peragraph against each filter until one returns false
            for (const filter in filters) {
                if (filters.hasOwnProperty(filter)) {
                    if (!(filters[filter](peraGraph))) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * limit the number of groups to load open on application of filtering/sorting/grouping based on the number of graphs in the dom
     * @param {?} peraGraphs - graphs to make count based off of
     * @return {?}
     */
    calculateNumberOfGroupsToShow(peraGraphs) {
        /** @type {?} */
        let groupsToShow = 0;
        /** @type {?} */
        let graphCount = 0;
        /** @type {?} */
        let expanded = true;
        /** @type {?} */
        let numOfGroupsWithGraphs = 0;
        // for each group, count the number of graphs in that group, capped at the maxGraphsPerGroup variable
        // once the graphs exceed the maxGraphs in dom value return the number of groupstoShow to be applied to groups
        for (const group of this.groupService.groupSubject$.value) {
            /** @type {?} */
            let groupGraphCount = 0;
            // helper variable for tracking how many groups have graphs
            /** @type {?} */
            let groupIsFresh = true;
            for (const peraGraph of peraGraphs) {
                if (group.laneFunction(peraGraph)) {
                    if (groupIsFresh) {
                        numOfGroupsWithGraphs++;
                        groupIsFresh = false;
                    }
                    groupGraphCount++;
                    if (groupGraphCount >= this.maxGraphCountPerGroup) {
                        break;
                    }
                }
            }
            graphCount += groupGraphCount;
            groupsToShow++;
            if (graphCount > this.maxGraphsInDom) {
                groupsToShow--;
                break;
            }
        }
        return { groupsToShow: groupsToShow, expanded: numOfGroupsWithGraphs <= 1 };
    }
    /**
     * if sorting by RI Score...get RI Scores from server and append to peraGraphs
     * @param {?} peraGraphs - peraGraphs to have Ris attached to
     * @return {?}
     */
    addRIToPeraGraphs(peraGraphs) {
        if (this.sortService.activeSortName === 'latestRi') {
            return this.flowsheetsApiService.getAllRiScores().pipe(map((riScores) => {
                /** @type {?} */
                const riMap = riScores.body;
                for (const peraGraph of peraGraphs) {
                    if (riScores.body[peraGraph.visitId]) {
                        peraGraph.latestRi = riMap[peraGraph.visitId];
                    }
                }
                return peraGraphs;
            }));
        }
        else {
            return of(peraGraphs);
        }
    }
    /**
     * sorts peraGraphs based on function passed in through sort parameter then subsorts if needed based on the default sort method
     * if no function is provided, the default sort function is used
     * @param {?} peraGraphA - peraGraph to be sorted
     * @param {?} peraGraphB - peraGraph to be sorted
     * @param {?=} sortFunction - function to sort peraGraphs
     * @return {?}
     */
    sortGraphs(peraGraphA, peraGraphB, sortFunction) {
        // default sort method for peragraphs
        /** @type {?} */
        const defaultSort = function (peraGraphA, peraGraphB) {
            /** @type {?} */
            let comparison = 0;
            if (peraGraphA.displayName > peraGraphB.displayName) {
                comparison = 1;
            }
            else if (peraGraphA.displayName < peraGraphB.displayName) {
                comparison = -1;
            }
            return comparison;
        };
        if (this.sortService.nonStandardSortFunctionActive && this.sortService.nonStandardSortFunction) {
            sortFunction = this.sortService.nonStandardSortFunction;
        }
        // if a function is passed in -> use it. if not use the default sort
        if (!sortFunction) {
            // if no function is provided, use default sort
            return defaultSort(peraGraphA, peraGraphB);
        }
        /** @type {?} */
        let comparison;
        comparison = sortFunction(peraGraphA, peraGraphB);
        if (comparison == 0) {
            comparison = defaultSort(peraGraphA, peraGraphB);
        }
        return comparison;
    }
    /**
     * If a timestamp is provided by config use that, otherwise update the current timestamp every 5 seconds
     * @return {?}
     */
    calcCurrentTimestamp() {
        if (this.configService.getCurrentTimestamp()) {
            this.currentTimestamp = this.configService.getCurrentTimestamp();
        }
    }
    /**
     * returns the timestamp sent by the server if it isn't null
     * otherwise calls Date.now() to get an up to date timestamp to
     * return
     * @return {?}
     */
    getCurrentTimestamp() {
        /*
            The currentTimestamp property is only set if the server sends a specific timestamp
            it wants us to use. If that is not provided, we call Date.now() to get the up to date
            timestamp every time this function is invoked
        */
        return this.currentTimestamp ? this.currentTimestamp : Date.now();
    }
    /**
     * @return {?}
     */
    isDisplayingTiles() {
        return this.displayTiles;
    }
    /**
     * @return {?}
     */
    toggleTileView() {
        // Toggle whether or not we display the tile view and set the width/height accordingly
        this.displayTiles = !this.displayTiles;
        this.peraGraphHeight = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultHeight;
        this.peraGraphWidth = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultWidth;
        this.refreshViewPort();
    }
    // Force a refresh of the viewport by toggling the data
    /**
     * @return {?}
     */
    refreshViewPort() {
        /** @type {?} */
        const previousPeraGraphs = this.peragraphApiService.getPeraGraphSubject().value;
        this.peragraphApiService.getPeraGraphSubject().next([]);
        setTimeout(() => {
            this.peragraphApiService.getPeraGraphSubject().next(previousPeraGraphs);
        }, 1);
    }
    /**
     * Called on manual refresh or application of filters - refreshes graphs and FSCs
     * and fires completedRefresh$ Subject upon completion
     * @param {?=} getFilterQuery
     * @return {?}
     */
    refreshGraphs(getFilterQuery) {
        this.startedRefresh$.next();
        if (getFilterQuery) {
            // we use fork join here to combine the REST calls for server side filtering and getting new PeraGraphs
            // quick aside on fork join - all it does is wait for both observables to COMPLETE and then feed you both results
            // before getting to the fork join the vnms from the server side filter query are stored in the filter service
            //      -> this is done to ensure that once the forkjoin completes, client side filtering can commence
            // after filtering the graphs, they are passed to the array view per usual
            forkJoin(this.filterQueryRestService.getFilteredVisits(this.filterService.getActiveServerFilterCriteria()), this.peragraphApiService.getAllPeragraphs()).subscribe((graphsAndFilteredVisits) => {
                this.peragraphApiService.getPeraGraphSubject().next(graphsAndFilteredVisits[1]);
                this.filterService.serverFilteredVisits = graphsAndFilteredVisits[0];
                this.filterService.filterSubject$.next(this.filterService.activeFilters);
                this.completedRefresh$.next();
            });
        }
        else {
            // if we don't need to do server side filtering -> filter in the client immediately
            this.peragraphApiService.getAllPeragraphs().subscribe((graphs) => {
                this.peragraphApiService.getPeraGraphSubject().next(graphs);
            });
        }
        this.flowsheetsApiService.getAllPeraGraphFlowSheets().subscribe((flowsheets) => this.flowsheetsApiService.getFlowSheetSubject().next(flowsheets.body));
    }
}
ArrayViewService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ArrayViewService.ctorParameters = () => [
    { type: HttpClient },
    { type: ArrayViewConfigService },
    { type: FilterService },
    { type: FilterQueryRestService },
    { type: FlowsheetsApiService },
    { type: PeragraphApiService },
    { type: SortService },
    { type: GroupService },
    { type: DateService }
];
/** @nocollapse */ ArrayViewService.ngInjectableDef = i0.defineInjectable({ factory: function ArrayViewService_Factory() { return new ArrayViewService(i0.inject(i1.HttpClient), i0.inject(i2.ArrayViewConfigService), i0.inject(i3.FilterService), i0.inject(i3.FilterQueryRestService), i0.inject(i4.FlowsheetsApiService), i0.inject(i4.PeragraphApiService), i0.inject(i3.SortService), i0.inject(i3.GroupService), i0.inject(i4.DateService)); }, token: ArrayViewService, providedIn: "root" });
if (false) {
    /** @type {?} */
    ArrayViewService.prototype.titleChoices;
    /** @type {?} */
    ArrayViewService.prototype.selectedChartTitle;
    /** @type {?} */
    ArrayViewService.prototype.chartTitleSubject$;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.maxGraphCountPerGroup;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.maxGraphsInDom;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.currentTimestamp;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.displayTiles;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphDefaultHeight;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphDefaultWidth;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peraGraphTileDefault;
    /** @type {?} */
    ArrayViewService.prototype.peraGraphHeight;
    /** @type {?} */
    ArrayViewService.prototype.peraGraphWidth;
    /** @type {?} */
    ArrayViewService.prototype.startedRefresh$;
    /** @type {?} */
    ArrayViewService.prototype.completedRefresh$;
    /** @type {?} */
    ArrayViewService.prototype.tokenRefresh$;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.configService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.filterService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.filterQueryRestService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.flowsheetsApiService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.peragraphApiService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.sortService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.groupService;
    /**
     * @type {?}
     * @private
     */
    ArrayViewService.prototype.dateService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdmlldy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctYXJyYXktdmlldy1saWJyYXJ5LyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2UvYXJyYXktdmlldy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRCxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkMsT0FBTyxLQUFLLE9BQU8sTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNuRSxPQUFPLEVBQUMsV0FBVyxFQUFFLG9CQUFvQixFQUFFLG1CQUFtQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFekYsT0FBTyxFQUFDLHNCQUFzQixFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDcEcsT0FBTyxFQUFDLGVBQWUsRUFBRSxRQUFRLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUN4RSxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7O01BSTdDLE1BQU0sR0FBRyxPQUFPO0FBS3RCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7Ozs7Ozs7OztJQTBFekIsWUFBb0IsSUFBZ0IsRUFDaEIsYUFBcUMsRUFDckMsYUFBNEIsRUFDNUIsc0JBQThDLEVBQzlDLG9CQUEwQyxFQUMxQyxtQkFBd0MsRUFDeEMsV0FBd0IsRUFDeEIsWUFBMEIsRUFDMUIsV0FBd0I7UUFSeEIsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixrQkFBYSxHQUFiLGFBQWEsQ0FBd0I7UUFDckMsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsMkJB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O1lBR1Ysc0JBQXNCO1lBR0UsYUFBYTtZQUFyQyxzQkFBc0I7WUFGVCxvQkFBb0I7WUFBRSxtQkFBbUI7WUFFRCxXQUFXO1lBQXpCLFlBQVk7WUFGbkQsV0FBVzs7Ozs7SUFnQmYsd0NBNENFOztJQUdGLDhDQUtFOztJQUdGLDhDQUN5RTs7Ozs7SUFFekUsaURBQW1DOzs7OztJQUNuQywwQ0FBNkI7Ozs7O0lBQzdCLDRDQUFnQzs7Ozs7SUFDaEMsd0NBQTZCOzs7OztJQUM3QixrREFBcUM7Ozs7O0lBQ3JDLGlEQUFvQzs7Ozs7SUFDcEMsZ0RBQWtDOztJQUNsQywyQ0FBNkQ7O0lBQzdELDBDQUEyRDs7SUFDM0QsMkNBQTREOztJQUM1RCw2Q0FBOEQ7O0lBQzlELHlDQUEwRDs7Ozs7SUFFOUMsZ0NBQXdCOzs7OztJQUN4Qix5Q0FBNkM7Ozs7O0lBQzdDLHlDQUFvQzs7Ozs7SUFDcEMsa0RBQXNEOzs7OztJQUN0RCxnREFBa0Q7Ozs7O0lBQ2xELCtDQUFnRDs7Ozs7SUFDaEQsdUNBQWdDOzs7OztJQUNoQyx3Q0FBa0M7Ozs7O0lBQ2xDLHVDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0h0dHBDbGllbnR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7bWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudC10aW1lem9uZSc7XG5pbXBvcnQge0FycmF5Vmlld0NvbmZpZ1NlcnZpY2V9IGZyb20gJy4vYXJyYXktdmlldy1jb25maWcuc2VydmljZSc7XG5pbXBvcnQge0RhdGVTZXJ2aWNlLCBGbG93c2hlZXRzQXBpU2VydmljZSwgUGVyYWdyYXBoQXBpU2VydmljZX0gZnJvbSAnbmctY29tbW9uLWxpYnJhcnknO1xuaW1wb3J0IHtQZXJhR3JhcGh9IGZyb20gJ25nLWNvbW1vbi1saWJyYXJ5L2xpYi9tb2RlbC9QZXJhR3JhcGgnO1xuaW1wb3J0IHtGaWx0ZXJRdWVyeVJlc3RTZXJ2aWNlLCBGaWx0ZXJTZXJ2aWNlLCBHcm91cFNlcnZpY2UsIFNvcnRTZXJ2aWNlfSBmcm9tICduZy1maWx0ZXJzLWxpYnJhcnknO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIGZvcmtKb2luLCBPYnNlcnZhYmxlLCBvZiwgU3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0NoYXJ0VGl0bGVDaG9pY2VzfSBmcm9tICcuL2NoYXJ0VGl0bGVFbnVtJztcblxuLy8gVGhlIEphdmFTY3JpcHQgY29tcGlsZXIgZ2l2ZXMgYSB3ZWlyZCBcIm1vbWVudCBjYW5ub3QgYmUgdXNlZCBhcyBhIG5hbWVzcGFjZVwiIHR5cGUgb2YgZXJyb3Jcbi8vIFRoaXMgaXMgdGhlIHdvcmthcm91bmQuLi5cbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQXJyYXlWaWV3U2VydmljZSB7XG5cbiAgICAvLyBUaGUgcG9zc2libGUgY2hhcnQgdGl0bGUgc2VsZWN0aW9uc1xuICAgIHRpdGxlQ2hvaWNlczoge2Rlc2NyaXB0aW9uOiBzdHJpbmcsIHJldHVybkZ1bmM6IChwZXJhR3JhcGg6IFBlcmFHcmFwaCkgPT4gYW55fVtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuVk5NLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaC52bm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBDaGFydFRpdGxlQ2hvaWNlcy5BRE1JVF9EQVRFLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmFHcmFwaCAmJiBwZXJhR3JhcGgudGltZVpvbmUgJiYgcGVyYUdyYXBoLmFkbWl0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXREYXRlRm9ybWF0KHBlcmFHcmFwaC50aW1lWm9uZSwgcGVyYUdyYXBoLmFkbWl0RGF0ZSwgJ01NL0REL1lZIEhIOm1tIHonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuTVJOLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaC5wYXRpZW50Lm1lZGljYWxSZWNvcmROdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBDaGFydFRpdGxlQ2hvaWNlcy5QQVRJRU5UX05BTUUsXG4gICAgICAgICAgICByZXR1cm5GdW5jOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVyYUdyYXBoLnZpcEluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVyYUdyYXBoLnBhdGllbnQuYWxpYXNMYXN0TmFtZSArICcsICcgKyBwZXJhR3JhcGgucGF0aWVudC5hbGlhc0ZpcnN0TmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVyYUdyYXBoLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IENoYXJ0VGl0bGVDaG9pY2VzLkxPQ0FUSU9OLFxuICAgICAgICAgICAgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmFHcmFwaC51bml0SWQgKyAnLScgKyBwZXJhR3JhcGgucm9vbSArICctJyArIHBlcmFHcmFwaC5iZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBDaGFydFRpdGxlQ2hvaWNlcy5BTk9OWU1PVVMsXG4gICAgICAgICAgICByZXR1cm5GdW5jOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0NoYXJ0ICcgKyBwZXJhR3JhcGguYW5vbnltb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXTtcblxuICAgIC8vIEN1cnJlbnQgY2hhcnQgdGl0bGUgc2VsZWN0aW9uIC0gZGVmYXVsdHMgdG8gUGF0aWVudCBOYW1lXG4gICAgc2VsZWN0ZWRDaGFydFRpdGxlOiB7ZGVzY3JpcHRpb246IHN0cmluZywgcmV0dXJuRnVuYzogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiBhbnl9ID0ge1xuICAgICAgICBkZXNjcmlwdGlvbjogQ2hhcnRUaXRsZUNob2ljZXMuUEFUSUVOVF9OQU1FLFxuICAgICAgICByZXR1cm5GdW5jOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwZXJhR3JhcGguZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU3ViamVjdCBmb3IgdGhlIHRpdGxlIHNlbGVjdGlvblxuICAgIHB1YmxpYyBjaGFydFRpdGxlU3ViamVjdCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHtkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgICAgICByZXR1cm5GdW5jOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IGFueX0+KHRoaXMuc2VsZWN0ZWRDaGFydFRpdGxlKTtcblxuICAgIHByaXZhdGUgbWF4R3JhcGhDb3VudFBlckdyb3VwID0gNTA7XG4gICAgcHJpdmF0ZSBtYXhHcmFwaHNJbkRvbSA9IDE1MDtcbiAgICBwcml2YXRlIGN1cnJlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgIHByaXZhdGUgZGlzcGxheVRpbGVzID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBwZXJhR3JhcGhEZWZhdWx0SGVpZ2h0ID0gMTQ1O1xuICAgIHByaXZhdGUgcGVyYUdyYXBoRGVmYXVsdFdpZHRoID0gMTg1O1xuICAgIHByaXZhdGUgcGVyYUdyYXBoVGlsZURlZmF1bHQgPSA3NTtcbiAgICBwdWJsaWMgcGVyYUdyYXBoSGVpZ2h0OiBudW1iZXIgPSB0aGlzLnBlcmFHcmFwaERlZmF1bHRIZWlnaHQ7XG4gICAgcHVibGljIHBlcmFHcmFwaFdpZHRoOiBudW1iZXIgPSB0aGlzLnBlcmFHcmFwaERlZmF1bHRXaWR0aDtcbiAgICBwdWJsaWMgc3RhcnRlZFJlZnJlc2gkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwdWJsaWMgY29tcGxldGVkUmVmcmVzaCQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHB1YmxpYyB0b2tlblJlZnJlc2gkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbmZpZ1NlcnZpY2U6IEFycmF5Vmlld0NvbmZpZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBmaWx0ZXJTZXJ2aWNlOiBGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZmlsdGVyUXVlcnlSZXN0U2VydmljZTogRmlsdGVyUXVlcnlSZXN0U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGZsb3dzaGVldHNBcGlTZXJ2aWNlOiBGbG93c2hlZXRzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHBlcmFncmFwaEFwaVNlcnZpY2U6IFBlcmFncmFwaEFwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBzb3J0U2VydmljZTogU29ydFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBncm91cFNlcnZpY2U6IEdyb3VwU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRhdGVTZXJ2aWNlOiBEYXRlU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJ1bnMgdGhlIHBlcmFncmFwaCB0aHJvdWdoIGFsbCB0aGUgZmlsdGVycyBhbmQgcmV0dXJucyB0cnVlIGlmIG5vbmUgb2YgdGhlbSByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0gcGVyYUdyYXBoIC0gcGVyYWdyYXBoIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIGZpbHRlcnMgLSBvYmplY3Qgb2YgZmlsdGVyIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIGZpbHRlclBlcmFncmFwaChwZXJhR3JhcGgsIGZpbHRlcnMpOiBib29sZWFuIHtcbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgZmlsdGVyIG9iamVjdCBoYXMgbm8gcHJvcGVydGllc1xuICAgICAgICBpZiAoKE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA9PT0gMCAmJiBmaWx0ZXJzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlIGZpbHRlciBvYmplY3QgYW5kIHRlc3QgcGVyYWdyYXBoIGFnYWluc3QgZWFjaCBmaWx0ZXIgdW50aWwgb25lIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIGluIGZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVycy5oYXNPd25Qcm9wZXJ0eShmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZpbHRlcnNbZmlsdGVyXShwZXJhR3JhcGgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxpbWl0IHRoZSBudW1iZXIgb2YgZ3JvdXBzIHRvIGxvYWQgb3BlbiBvbiBhcHBsaWNhdGlvbiBvZiBmaWx0ZXJpbmcvc29ydGluZy9ncm91cGluZyBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGdyYXBocyBpbiB0aGUgZG9tXG4gICAgICogQHBhcmFtIHBlcmFHcmFwaHMgLSBncmFwaHMgdG8gbWFrZSBjb3VudCBiYXNlZCBvZmYgb2ZcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVOdW1iZXJPZkdyb3Vwc1RvU2hvdyhwZXJhR3JhcGhzOiBQZXJhR3JhcGhbXSk6IHtncm91cHNUb1Nob3c6IG51bWJlciwgZXhwYW5kZWQ6IGJvb2xlYW59IHtcbiAgICAgICAgbGV0IGdyb3Vwc1RvU2hvdyA9IDA7XG4gICAgICAgIGxldCBncmFwaENvdW50ID0gMDtcbiAgICAgICAgbGV0IGV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IG51bU9mR3JvdXBzV2l0aEdyYXBocyA9IDA7XG4gICAgICAgIC8vIGZvciBlYWNoIGdyb3VwLCBjb3VudCB0aGUgbnVtYmVyIG9mIGdyYXBocyBpbiB0aGF0IGdyb3VwLCBjYXBwZWQgYXQgdGhlIG1heEdyYXBoc1Blckdyb3VwIHZhcmlhYmxlXG4gICAgICAgIC8vIG9uY2UgdGhlIGdyYXBocyBleGNlZWQgdGhlIG1heEdyYXBocyBpbiBkb20gdmFsdWUgcmV0dXJuIHRoZSBudW1iZXIgb2YgZ3JvdXBzdG9TaG93IHRvIGJlIGFwcGxpZWQgdG8gZ3JvdXBzXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy5ncm91cFNlcnZpY2UuZ3JvdXBTdWJqZWN0JC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGdyb3VwR3JhcGhDb3VudCA9IDA7XG4gICAgICAgICAgICAvLyBoZWxwZXIgdmFyaWFibGUgZm9yIHRyYWNraW5nIGhvdyBtYW55IGdyb3VwcyBoYXZlIGdyYXBoc1xuICAgICAgICAgICAgbGV0IGdyb3VwSXNGcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBmb3IoY29uc3QgcGVyYUdyYXBoIG9mIHBlcmFHcmFwaHMpIHtcbiAgICAgICAgICAgICAgICBpZihncm91cC5sYW5lRnVuY3Rpb24ocGVyYUdyYXBoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZihncm91cElzRnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bU9mR3JvdXBzV2l0aEdyYXBocysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJc0ZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBHcmFwaENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmKGdyb3VwR3JhcGhDb3VudCA+PSB0aGlzLm1heEdyYXBoQ291bnRQZXJHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaENvdW50ICs9IGdyb3VwR3JhcGhDb3VudDtcbiAgICAgICAgICAgIGdyb3Vwc1RvU2hvdysrO1xuICAgICAgICAgICAgaWYgKGdyYXBoQ291bnQgPiB0aGlzLm1heEdyYXBoc0luRG9tKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzVG9TaG93LS07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtncm91cHNUb1Nob3c6IGdyb3Vwc1RvU2hvdywgZXhwYW5kZWQ6IG51bU9mR3JvdXBzV2l0aEdyYXBocyA8PSAxfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpZiBzb3J0aW5nIGJ5IFJJIFNjb3JlLi4uZ2V0IFJJIFNjb3JlcyBmcm9tIHNlcnZlciBhbmQgYXBwZW5kIHRvIHBlcmFHcmFwaHNcbiAgICAgKiBAcGFyYW0gcGVyYUdyYXBocyAtIHBlcmFHcmFwaHMgdG8gaGF2ZSBSaXMgYXR0YWNoZWQgdG9cbiAgICAgKi9cbiAgICBhZGRSSVRvUGVyYUdyYXBocyhwZXJhR3JhcGhzOiBQZXJhR3JhcGhbXSk6IE9ic2VydmFibGU8UGVyYUdyYXBoW10+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ydFNlcnZpY2UuYWN0aXZlU29ydE5hbWUgPT09ICdsYXRlc3RSaScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dzaGVldHNBcGlTZXJ2aWNlLmdldEFsbFJpU2NvcmVzKCkucGlwZShtYXAoKHJpU2NvcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlNYXAgPSByaVNjb3Jlcy5ib2R5O1xuICAgICAgICAgICAgICAgIGZvcihjb25zdCBwZXJhR3JhcGggb2YgcGVyYUdyYXBocykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlTY29yZXMuYm9keVtwZXJhR3JhcGgudmlzaXRJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmFHcmFwaC5sYXRlc3RSaSA9IHJpTWFwW3BlcmFHcmFwaC52aXNpdElkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyYUdyYXBocztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvZihwZXJhR3JhcGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNvcnRzIHBlcmFHcmFwaHMgYmFzZWQgb24gZnVuY3Rpb24gcGFzc2VkIGluIHRocm91Z2ggc29ydCBwYXJhbWV0ZXIgdGhlbiBzdWJzb3J0cyBpZiBuZWVkZWQgYmFzZWQgb24gdGhlIGRlZmF1bHQgc29ydCBtZXRob2RcbiAgICAgKiBpZiBubyBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc29ydCBmdW5jdGlvbiBpcyB1c2VkXG4gICAgICogQHBhcmFtIHBlcmFHcmFwaEEgLSBwZXJhR3JhcGggdG8gYmUgc29ydGVkXG4gICAgICogQHBhcmFtIHBlcmFHcmFwaEIgLSBwZXJhR3JhcGggdG8gYmUgc29ydGVkXG4gICAgICogQHBhcmFtIHNvcnRGdW5jdGlvbiAtIGZ1bmN0aW9uIHRvIHNvcnQgcGVyYUdyYXBoc1xuICAgICAqL1xuICAgIHNvcnRHcmFwaHMocGVyYUdyYXBoQSwgcGVyYUdyYXBoQiwgc29ydEZ1bmN0aW9uPzogKHBlcmFncmFwaEE6IFBlcmFHcmFwaCwgcGVyYUdyYXBoQjogUGVyYUdyYXBoKSA9PiBudW1iZXIpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBzb3J0IG1ldGhvZCBmb3IgcGVyYWdyYXBoc1xuICAgICAgICBjb25zdCBkZWZhdWx0U29ydCA9IGZ1bmN0aW9uIChwZXJhR3JhcGhBOiBQZXJhR3JhcGgsIHBlcmFHcmFwaEI6IFBlcmFHcmFwaCk6IG51bWJlciB7XG4gICAgICAgICAgICBsZXQgY29tcGFyaXNvbiA9IDA7XG4gICAgICAgICAgICBpZiAocGVyYUdyYXBoQS5kaXNwbGF5TmFtZSA+IHBlcmFHcmFwaEIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyYUdyYXBoQS5kaXNwbGF5TmFtZSA8IHBlcmFHcmFwaEIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0U2VydmljZS5ub25TdGFuZGFyZFNvcnRGdW5jdGlvbkFjdGl2ZSAmJiB0aGlzLnNvcnRTZXJ2aWNlLm5vblN0YW5kYXJkU29ydEZ1bmN0aW9uKSB7XG4gICAgICAgICAgIHNvcnRGdW5jdGlvbiA9IHRoaXMuc29ydFNlcnZpY2Uubm9uU3RhbmRhcmRTb3J0RnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCBpbiAtPiB1c2UgaXQuIGlmIG5vdCB1c2UgdGhlIGRlZmF1bHQgc29ydFxuICAgICAgICBpZiAoIXNvcnRGdW5jdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgbm8gZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSBkZWZhdWx0IHNvcnRcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U29ydChwZXJhR3JhcGhBLCBwZXJhR3JhcGhCKVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wYXJpc29uO1xuICAgICAgICBjb21wYXJpc29uID0gc29ydEZ1bmN0aW9uKHBlcmFHcmFwaEEsIHBlcmFHcmFwaEIpO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PSAwKSB7XG4gICAgICAgICAgICBjb21wYXJpc29uID0gZGVmYXVsdFNvcnQocGVyYUdyYXBoQSwgcGVyYUdyYXBoQik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgYSB0aW1lc3RhbXAgaXMgcHJvdmlkZWQgYnkgY29uZmlnIHVzZSB0aGF0LCBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IHRpbWVzdGFtcCBldmVyeSA1IHNlY29uZHNcbiAgICAgKi9cbiAgICBjYWxjQ3VycmVudFRpbWVzdGFtcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VydmljZS5nZXRDdXJyZW50VGltZXN0YW1wKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVzdGFtcCA9IHRoaXMuY29uZmlnU2VydmljZS5nZXRDdXJyZW50VGltZXN0YW1wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB0aW1lc3RhbXAgc2VudCBieSB0aGUgc2VydmVyIGlmIGl0IGlzbid0IG51bGxcbiAgICAgKiBvdGhlcndpc2UgY2FsbHMgRGF0ZS5ub3coKSB0byBnZXQgYW4gdXAgdG8gZGF0ZSB0aW1lc3RhbXAgdG9cbiAgICAgKiByZXR1cm5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q3VycmVudFRpbWVzdGFtcCgpOiBudW1iZXIge1xuICAgICAgICAvKlxuICAgICAgICAgICAgVGhlIGN1cnJlbnRUaW1lc3RhbXAgcHJvcGVydHkgaXMgb25seSBzZXQgaWYgdGhlIHNlcnZlciBzZW5kcyBhIHNwZWNpZmljIHRpbWVzdGFtcFxuICAgICAgICAgICAgaXQgd2FudHMgdXMgdG8gdXNlLiBJZiB0aGF0IGlzIG5vdCBwcm92aWRlZCwgd2UgY2FsbCBEYXRlLm5vdygpIHRvIGdldCB0aGUgdXAgdG8gZGF0ZVxuICAgICAgICAgICAgdGltZXN0YW1wIGV2ZXJ5IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lc3RhbXAgPyB0aGlzLmN1cnJlbnRUaW1lc3RhbXAgOiBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc0Rpc3BsYXlpbmdUaWxlcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRpbGVzO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b2dnbGVUaWxlVmlldygpIHtcbiAgICAgICAgLy8gVG9nZ2xlIHdoZXRoZXIgb3Igbm90IHdlIGRpc3BsYXkgdGhlIHRpbGUgdmlldyBhbmQgc2V0IHRoZSB3aWR0aC9oZWlnaHQgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5kaXNwbGF5VGlsZXMgPSAhdGhpcy5kaXNwbGF5VGlsZXM7XG4gICAgICAgIHRoaXMucGVyYUdyYXBoSGVpZ2h0ID0gKHRoaXMuZGlzcGxheVRpbGVzKSA/IHRoaXMucGVyYUdyYXBoVGlsZURlZmF1bHQgOiB0aGlzLnBlcmFHcmFwaERlZmF1bHRIZWlnaHQ7XG4gICAgICAgIHRoaXMucGVyYUdyYXBoV2lkdGggPSAodGhpcy5kaXNwbGF5VGlsZXMpID8gdGhpcy5wZXJhR3JhcGhUaWxlRGVmYXVsdCA6IHRoaXMucGVyYUdyYXBoRGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLnJlZnJlc2hWaWV3UG9ydCgpO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgcmVmcmVzaCBvZiB0aGUgdmlld3BvcnQgYnkgdG9nZ2xpbmcgdGhlIGRhdGFcbiAgICBwdWJsaWMgcmVmcmVzaFZpZXdQb3J0KCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1BlcmFHcmFwaHMgPSB0aGlzLnBlcmFncmFwaEFwaVNlcnZpY2UuZ2V0UGVyYUdyYXBoU3ViamVjdCgpLnZhbHVlO1xuICAgICAgICB0aGlzLnBlcmFncmFwaEFwaVNlcnZpY2UuZ2V0UGVyYUdyYXBoU3ViamVjdCgpLm5leHQoW10pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVyYWdyYXBoQXBpU2VydmljZS5nZXRQZXJhR3JhcGhTdWJqZWN0KCkubmV4dChwcmV2aW91c1BlcmFHcmFwaHMpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gbWFudWFsIHJlZnJlc2ggb3IgYXBwbGljYXRpb24gb2YgZmlsdGVycyAtIHJlZnJlc2hlcyBncmFwaHMgYW5kIEZTQ3NcbiAgICAgKiBhbmQgZmlyZXMgY29tcGxldGVkUmVmcmVzaCQgU3ViamVjdCB1cG9uIGNvbXBsZXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVmcmVzaEdyYXBocyhnZXRGaWx0ZXJRdWVyeT86IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zdGFydGVkUmVmcmVzaCQubmV4dCgpO1xuICAgICAgICBpZiAoZ2V0RmlsdGVyUXVlcnkpIHtcbiAgICAgICAgICAgIC8vIHdlIHVzZSBmb3JrIGpvaW4gaGVyZSB0byBjb21iaW5lIHRoZSBSRVNUIGNhbGxzIGZvciBzZXJ2ZXIgc2lkZSBmaWx0ZXJpbmcgYW5kIGdldHRpbmcgbmV3IFBlcmFHcmFwaHNcbiAgICAgICAgICAgIC8vIHF1aWNrIGFzaWRlIG9uIGZvcmsgam9pbiAtIGFsbCBpdCBkb2VzIGlzIHdhaXQgZm9yIGJvdGggb2JzZXJ2YWJsZXMgdG8gQ09NUExFVEUgYW5kIHRoZW4gZmVlZCB5b3UgYm90aCByZXN1bHRzXG4gICAgICAgICAgICAvLyBiZWZvcmUgZ2V0dGluZyB0byB0aGUgZm9yayBqb2luIHRoZSB2bm1zIGZyb20gdGhlIHNlcnZlciBzaWRlIGZpbHRlciBxdWVyeSBhcmUgc3RvcmVkIGluIHRoZSBmaWx0ZXIgc2VydmljZVxuICAgICAgICAgICAgLy8gICAgICAtPiB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIHRoYXQgb25jZSB0aGUgZm9ya2pvaW4gY29tcGxldGVzLCBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgY2FuIGNvbW1lbmNlXG4gICAgICAgICAgICAvLyBhZnRlciBmaWx0ZXJpbmcgdGhlIGdyYXBocywgdGhleSBhcmUgcGFzc2VkIHRvIHRoZSBhcnJheSB2aWV3IHBlciB1c3VhbFxuICAgICAgICAgICAgZm9ya0pvaW4odGhpcy5maWx0ZXJRdWVyeVJlc3RTZXJ2aWNlLmdldEZpbHRlcmVkVmlzaXRzKHRoaXMuZmlsdGVyU2VydmljZS5nZXRBY3RpdmVTZXJ2ZXJGaWx0ZXJDcml0ZXJpYSgpKSwgdGhpcy5wZXJhZ3JhcGhBcGlTZXJ2aWNlLmdldEFsbFBlcmFncmFwaHMoKSkuc3Vic2NyaWJlKChncmFwaHNBbmRGaWx0ZXJlZFZpc2l0cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyYWdyYXBoQXBpU2VydmljZS5nZXRQZXJhR3JhcGhTdWJqZWN0KCkubmV4dChncmFwaHNBbmRGaWx0ZXJlZFZpc2l0c1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLnNlcnZlckZpbHRlcmVkVmlzaXRzID0gZ3JhcGhzQW5kRmlsdGVyZWRWaXNpdHNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlLmZpbHRlclN1YmplY3QkLm5leHQodGhpcy5maWx0ZXJTZXJ2aWNlLmFjdGl2ZUZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVkUmVmcmVzaCQubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIGRvIHNlcnZlciBzaWRlIGZpbHRlcmluZyAtPiBmaWx0ZXIgaW4gdGhlIGNsaWVudCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdGhpcy5wZXJhZ3JhcGhBcGlTZXJ2aWNlLmdldEFsbFBlcmFncmFwaHMoKS5zdWJzY3JpYmUoKGdyYXBocykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyYWdyYXBoQXBpU2VydmljZS5nZXRQZXJhR3JhcGhTdWJqZWN0KCkubmV4dChncmFwaHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbG93c2hlZXRzQXBpU2VydmljZS5nZXRBbGxQZXJhR3JhcGhGbG93U2hlZXRzKCkuc3Vic2NyaWJlKChmbG93c2hlZXRzKSA9PiB0aGlzLmZsb3dzaGVldHNBcGlTZXJ2aWNlLmdldEZsb3dTaGVldFN1YmplY3QoKS5uZXh0KGZsb3dzaGVldHMuYm9keSkpO1xuICAgIH1cblxufVxuIl19