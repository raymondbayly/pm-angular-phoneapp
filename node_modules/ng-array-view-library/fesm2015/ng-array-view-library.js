import 'moment';
import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { map, switchMap, filter, first, mergeMap, tap } from 'rxjs/operators';
import { LoginService } from 'ng-login-library';
import { BehaviorSubject, forkJoin, of, Subject, timer, combineLatest } from 'rxjs';
import * as moment_ from 'moment-timezone';
import { HighchartsChartModule } from 'highcharts-angular';
import { VirtualScrollModule } from 'od-virtualscroll';
import { ResizableModule } from 'angular-resizable-element';
import { Injectable, ChangeDetectionStrategy, Component, Input, ChangeDetectorRef, ElementRef, Renderer2, NgModule, ViewChild, defineInjectable, inject } from '@angular/core';
import { DateService, FlowsheetsApiService, PeragraphApiService, WarningService, UsageType, UsageApiService, ChartService, TokenApiService } from 'ng-common-library';
import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { FilterQueryRestService, FilterService, GroupService, SortService, FilterQueryConfigService } from 'ng-filters-library';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayViewConfigService {
    constructor() {
        this.configurationLoaded$ = new BehaviorSubject(false);
        this.currentTimestamp = null;
        this.toolTipInfoEndPoint = null;
    }
    /**
     * @return {?}
     */
    getToolTipInfoEndPoint() {
        if (!this.toolTipInfoEndPoint) {
            console.warn('Tooltip endpoint is not set!');
        }
        return this.toolTipInfoEndPoint;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    setToolTipInfoEndPoint(val) {
        this.toolTipInfoEndPoint = val;
    }
    /**
     * @return {?}
     */
    getCurrentTimestamp() {
        return this.currentTimestamp;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setCurrentTimestamp(value) {
        this.currentTimestamp = value;
    }
}
ArrayViewConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ArrayViewConfigService.ngInjectableDef = defineInjectable({ factory: function ArrayViewConfigService_Factory() { return new ArrayViewConfigService(); }, token: ArrayViewConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ChartTitleChoices = {
    VNM: 'Visit Number',
    ADMIT_DATE: 'Admission Date',
    MRN: 'Medical Record Number',
    PATIENT_NAME: 'Patient Name',
    LOCATION: 'Room Number',
    ANONYMOUS: 'Anonymous',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayViewService {
    /**
     * @param {?} http
     * @param {?} configService
     * @param {?} filterService
     * @param {?} filterQueryRestService
     * @param {?} flowsheetsApiService
     * @param {?} peragraphApiService
     * @param {?} sortService
     * @param {?} groupService
     * @param {?} dateService
     */
    constructor(http, configService, filterService, filterQueryRestService, flowsheetsApiService, peragraphApiService, sortService, groupService, dateService) {
        this.http = http;
        this.configService = configService;
        this.filterService = filterService;
        this.filterQueryRestService = filterQueryRestService;
        this.flowsheetsApiService = flowsheetsApiService;
        this.peragraphApiService = peragraphApiService;
        this.sortService = sortService;
        this.groupService = groupService;
        this.dateService = dateService;
        // The possible chart title selections
        this.titleChoices = [
            {
                description: ChartTitleChoices.VNM,
                returnFunc: (peraGraph) => {
                    return peraGraph.vnm;
                }
            },
            {
                description: ChartTitleChoices.ADMIT_DATE,
                returnFunc: (peraGraph) => {
                    if (peraGraph && peraGraph.timeZone && peraGraph.admitDate) {
                        return this.dateService.getDateFormat(peraGraph.timeZone, peraGraph.admitDate, 'MM/DD/YY HH:mm z');
                    }
                    return '';
                }
            },
            {
                description: ChartTitleChoices.MRN,
                returnFunc: (peraGraph) => {
                    return peraGraph.patient.medicalRecordNumber;
                }
            },
            {
                description: ChartTitleChoices.PATIENT_NAME,
                returnFunc: (peraGraph) => {
                    if (peraGraph.vipIndicator) {
                        return peraGraph.patient.aliasLastName + ', ' + peraGraph.patient.aliasFirstName;
                    }
                    else {
                        return peraGraph.displayName;
                    }
                }
            },
            {
                description: ChartTitleChoices.LOCATION,
                returnFunc: (peraGraph) => {
                    return peraGraph.unitId + '-' + peraGraph.room + '-' + peraGraph.bed;
                }
            },
            {
                description: ChartTitleChoices.ANONYMOUS,
                returnFunc: (peraGraph) => {
                    return 'Chart ' + peraGraph.anonymous;
                }
            }
        ];
        // Current chart title selection - defaults to Patient Name
        this.selectedChartTitle = {
            description: ChartTitleChoices.PATIENT_NAME,
            returnFunc: (peraGraph) => {
                return peraGraph.displayName;
            }
        };
        // Subject for the title selection
        this.chartTitleSubject$ = new BehaviorSubject(this.selectedChartTitle);
        this.maxGraphCountPerGroup = 50;
        this.maxGraphsInDom = 150;
        this.currentTimestamp = null;
        this.displayTiles = false;
        this.peraGraphDefaultHeight = 145;
        this.peraGraphDefaultWidth = 185;
        this.peraGraphTileDefault = 75;
        this.peraGraphHeight = this.peraGraphDefaultHeight;
        this.peraGraphWidth = this.peraGraphDefaultWidth;
        this.startedRefresh$ = new Subject();
        this.completedRefresh$ = new Subject();
        this.tokenRefresh$ = new Subject();
    }
    /**
     * runs the peragraph through all the filters and returns true if none of them return false
     * @param {?} peraGraph - peragraph to evaluate
     * @param {?} filters - object of filter functions
     * @return {?}
     */
    filterPeragraph(peraGraph, filters) {
        // return true if filter object has no properties
        if ((Object.keys(filters).length === 0 && filters.constructor === Object)) {
            return true;
        }
        else {
            // traverse filter object and test peragraph against each filter until one returns false
            for (const filter$$1 in filters) {
                if (filters.hasOwnProperty(filter$$1)) {
                    if (!(filters[filter$$1](peraGraph))) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * limit the number of groups to load open on application of filtering/sorting/grouping based on the number of graphs in the dom
     * @param {?} peraGraphs - graphs to make count based off of
     * @return {?}
     */
    calculateNumberOfGroupsToShow(peraGraphs) {
        /** @type {?} */
        let groupsToShow = 0;
        /** @type {?} */
        let graphCount = 0;
        /** @type {?} */
        let numOfGroupsWithGraphs = 0;
        // for each group, count the number of graphs in that group, capped at the maxGraphsPerGroup variable
        // once the graphs exceed the maxGraphs in dom value return the number of groupstoShow to be applied to groups
        for (const group of this.groupService.groupSubject$.value) {
            /** @type {?} */
            let groupGraphCount = 0;
            // helper variable for tracking how many groups have graphs
            /** @type {?} */
            let groupIsFresh = true;
            for (const peraGraph of peraGraphs) {
                if (group.laneFunction(peraGraph)) {
                    if (groupIsFresh) {
                        numOfGroupsWithGraphs++;
                        groupIsFresh = false;
                    }
                    groupGraphCount++;
                    if (groupGraphCount >= this.maxGraphCountPerGroup) {
                        break;
                    }
                }
            }
            graphCount += groupGraphCount;
            groupsToShow++;
            if (graphCount > this.maxGraphsInDom) {
                groupsToShow--;
                break;
            }
        }
        return { groupsToShow: groupsToShow, expanded: numOfGroupsWithGraphs <= 1 };
    }
    /**
     * if sorting by RI Score...get RI Scores from server and append to peraGraphs
     * @param {?} peraGraphs - peraGraphs to have Ris attached to
     * @return {?}
     */
    addRIToPeraGraphs(peraGraphs) {
        if (this.sortService.activeSortName === 'latestRi') {
            return this.flowsheetsApiService.getAllRiScores().pipe(map((riScores) => {
                /** @type {?} */
                const riMap = riScores.body;
                for (const peraGraph of peraGraphs) {
                    if (riScores.body[peraGraph.visitId]) {
                        peraGraph.latestRi = riMap[peraGraph.visitId];
                    }
                }
                return peraGraphs;
            }));
        }
        else {
            return of(peraGraphs);
        }
    }
    /**
     * sorts peraGraphs based on function passed in through sort parameter then subsorts if needed based on the default sort method
     * if no function is provided, the default sort function is used
     * @param {?} peraGraphA - peraGraph to be sorted
     * @param {?} peraGraphB - peraGraph to be sorted
     * @param {?=} sortFunction - function to sort peraGraphs
     * @return {?}
     */
    sortGraphs(peraGraphA, peraGraphB, sortFunction) {
        // default sort method for peragraphs
        /** @type {?} */
        const defaultSort = function (peraGraphA, peraGraphB) {
            /** @type {?} */
            let comparison = 0;
            if (peraGraphA.displayName > peraGraphB.displayName) {
                comparison = 1;
            }
            else if (peraGraphA.displayName < peraGraphB.displayName) {
                comparison = -1;
            }
            return comparison;
        };
        if (this.sortService.nonStandardSortFunctionActive && this.sortService.nonStandardSortFunction) {
            sortFunction = this.sortService.nonStandardSortFunction;
        }
        // if a function is passed in -> use it. if not use the default sort
        if (!sortFunction) {
            // if no function is provided, use default sort
            return defaultSort(peraGraphA, peraGraphB);
        }
        /** @type {?} */
        let comparison;
        comparison = sortFunction(peraGraphA, peraGraphB);
        if (comparison == 0) {
            comparison = defaultSort(peraGraphA, peraGraphB);
        }
        return comparison;
    }
    /**
     * If a timestamp is provided by config use that, otherwise update the current timestamp every 5 seconds
     * @return {?}
     */
    calcCurrentTimestamp() {
        if (this.configService.getCurrentTimestamp()) {
            this.currentTimestamp = this.configService.getCurrentTimestamp();
        }
    }
    /**
     * returns the timestamp sent by the server if it isn't null
     * otherwise calls Date.now() to get an up to date timestamp to
     * return
     * @return {?}
     */
    getCurrentTimestamp() {
        /*
            The currentTimestamp property is only set if the server sends a specific timestamp
            it wants us to use. If that is not provided, we call Date.now() to get the up to date
            timestamp every time this function is invoked
        */
        return this.currentTimestamp ? this.currentTimestamp : Date.now();
    }
    /**
     * @return {?}
     */
    isDisplayingTiles() {
        return this.displayTiles;
    }
    /**
     * @return {?}
     */
    toggleTileView() {
        // Toggle whether or not we display the tile view and set the width/height accordingly
        this.displayTiles = !this.displayTiles;
        this.peraGraphHeight = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultHeight;
        this.peraGraphWidth = (this.displayTiles) ? this.peraGraphTileDefault : this.peraGraphDefaultWidth;
        this.refreshViewPort();
    }
    // Force a refresh of the viewport by toggling the data
    /**
     * @return {?}
     */
    refreshViewPort() {
        /** @type {?} */
        const previousPeraGraphs = this.peragraphApiService.getPeraGraphSubject().value;
        this.peragraphApiService.getPeraGraphSubject().next([]);
        setTimeout(() => {
            this.peragraphApiService.getPeraGraphSubject().next(previousPeraGraphs);
        }, 1);
    }
    /**
     * Called on manual refresh or application of filters - refreshes graphs and FSCs
     * and fires completedRefresh$ Subject upon completion
     * @param {?=} getFilterQuery
     * @return {?}
     */
    refreshGraphs(getFilterQuery) {
        this.startedRefresh$.next();
        if (getFilterQuery) {
            // we use fork join here to combine the REST calls for server side filtering and getting new PeraGraphs
            // quick aside on fork join - all it does is wait for both observables to COMPLETE and then feed you both results
            // before getting to the fork join the vnms from the server side filter query are stored in the filter service
            //      -> this is done to ensure that once the forkjoin completes, client side filtering can commence
            // after filtering the graphs, they are passed to the array view per usual
            forkJoin(this.filterQueryRestService.getFilteredVisits(this.filterService.getActiveServerFilterCriteria()), this.peragraphApiService.getAllPeragraphs()).subscribe((graphsAndFilteredVisits) => {
                this.peragraphApiService.getPeraGraphSubject().next(graphsAndFilteredVisits[1]);
                this.filterService.serverFilteredVisits = graphsAndFilteredVisits[0];
                this.filterService.filterSubject$.next(this.filterService.activeFilters);
                this.completedRefresh$.next();
            });
        }
        else {
            // if we don't need to do server side filtering -> filter in the client immediately
            this.peragraphApiService.getAllPeragraphs().subscribe((graphs) => {
                this.peragraphApiService.getPeraGraphSubject().next(graphs);
            });
        }
        this.flowsheetsApiService.getAllPeraGraphFlowSheets().subscribe((flowsheets) => this.flowsheetsApiService.getFlowSheetSubject().next(flowsheets.body));
    }
}
ArrayViewService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ArrayViewService.ctorParameters = () => [
    { type: HttpClient },
    { type: ArrayViewConfigService },
    { type: FilterService },
    { type: FilterQueryRestService },
    { type: FlowsheetsApiService },
    { type: PeragraphApiService },
    { type: SortService },
    { type: GroupService },
    { type: DateService }
];
/** @nocollapse */ ArrayViewService.ngInjectableDef = defineInjectable({ factory: function ArrayViewService_Factory() { return new ArrayViewService(inject(HttpClient), inject(ArrayViewConfigService), inject(FilterService), inject(FilterQueryRestService), inject(FlowsheetsApiService), inject(PeragraphApiService), inject(SortService), inject(GroupService), inject(DateService)); }, token: ArrayViewService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const WarningColors = {
    VeryHigh: '#D51C19',
    High: '#EE834C',
    Medium: '#F6CC5D',
    NoCurrent: '#3185B8',
    NoRi: '#AAABAC',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeraGraphService {
    constructor() {
        // Subject for navigating to the PSG
        this.graphClicked$ = new Subject();
    }
    /**
     * @param {?} graph
     * @return {?}
     */
    graphClickedEvent(graph) {
        this.closeToolTip();
        this.graphClicked$.next(graph);
    }
    /**
     * @param {?} warning
     * @param {?} latestRi
     * @param {?} isDischarged
     * @return {?}
     */
    getBackgroundColorByWarningAndRi(warning, latestRi, isDischarged) {
        /** @type {?} */
        let backgroundColor;
        if (warning && !isDischarged) {
            switch (warning.category) {
                case 'V':
                    backgroundColor = WarningColors.VeryHigh;
                    break;
                case 'H':
                    backgroundColor = WarningColors.High;
                    break;
                case 'M':
                    backgroundColor = WarningColors.Medium;
                    break;
            }
        }
        else if (latestRi && !isDischarged) {
            backgroundColor = WarningColors.NoCurrent;
        }
        else {
            backgroundColor = WarningColors.NoRi;
        }
        return backgroundColor;
    }
    /**
     * @param {?} latestRi
     * @return {?}
     */
    getRiScoreToDisplay(latestRi) {
        return (latestRi) ? latestRi + '' : '--';
    }
    /**
     * @return {?}
     */
    closeToolTip() {
        if (this.tooltip && this.tooltip.isOpen) {
            this.tooltip.close();
        }
    }
}
PeraGraphService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PeraGraphService.ctorParameters = () => [];
/** @nocollapse */ PeraGraphService.ngInjectableDef = defineInjectable({ factory: function PeraGraphService_Factory() { return new PeraGraphService(); }, token: PeraGraphService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PriorWarningsConfigService {
    constructor() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setPriorWarningEndPoint(value) {
        this.priorWarningEndPoint = value;
    }
    /**
     * @return {?}
     */
    getPriorWarningEndPoint() {
        return this.priorWarningEndPoint;
    }
}
PriorWarningsConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PriorWarningsConfigService.ctorParameters = () => [];
/** @nocollapse */ PriorWarningsConfigService.ngInjectableDef = defineInjectable({ factory: function PriorWarningsConfigService_Factory() { return new PriorWarningsConfigService(); }, token: PriorWarningsConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PriorWarningsApiService {
    /**
     * @param {?} http
     * @param {?} priorWarningsConfigService
     */
    constructor(http, priorWarningsConfigService) {
        this.http = http;
        this.priorWarningsConfigService = priorWarningsConfigService;
        this.pollInstance$ = timer(0, 60000);
        this._priorWarningSubject = new BehaviorSubject(null);
    }
    /**
     * @return {?}
     */
    getPriorWarningSubjectValue() {
        return this._priorWarningSubject.value;
    }
    /**
     * @return {?}
     */
    getPriorWarningSubject() {
        return this._priorWarningSubject;
    }
    /**
     * @return {?}
     */
    getPriorWarnings() {
        return this.http.get(this.priorWarningsConfigService.getPriorWarningEndPoint(), { observe: 'response' });
    }
    /**
     * @return {?}
     */
    getPriorWarningInterval() {
        return this.pollInstance$.pipe(switchMap(() => this.getPriorWarnings()));
    }
}
PriorWarningsApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PriorWarningsApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: PriorWarningsConfigService }
];
/** @nocollapse */ PriorWarningsApiService.ngInjectableDef = defineInjectable({ factory: function PriorWarningsApiService_Factory() { return new PriorWarningsApiService(inject(HttpClient), inject(PriorWarningsConfigService)); }, token: PriorWarningsApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayViewComponent {
    /**
     * @param {?} arrayViewService
     * @param {?} arrayViewConfigService
     * @param {?} peragraphApiService
     * @param {?} filterService
     * @param {?} flowsheetsApiService
     * @param {?} priorWarningsConfigService
     * @param {?} priorWarningsApiService
     * @param {?} peraGraphService
     * @param {?} sortService
     * @param {?} groupService
     * @param {?} ref
     */
    constructor(arrayViewService, arrayViewConfigService, peragraphApiService, filterService, flowsheetsApiService, priorWarningsConfigService, priorWarningsApiService, peraGraphService, sortService, groupService, ref) {
        this.arrayViewService = arrayViewService;
        this.arrayViewConfigService = arrayViewConfigService;
        this.peragraphApiService = peragraphApiService;
        this.filterService = filterService;
        this.flowsheetsApiService = flowsheetsApiService;
        this.priorWarningsConfigService = priorWarningsConfigService;
        this.priorWarningsApiService = priorWarningsApiService;
        this.peraGraphService = peraGraphService;
        this.sortService = sortService;
        this.groupService = groupService;
        this.ref = ref;
        // collects all the peraGraphs from their input sources combines them, filters them, and then passes them onto the groups
        this.filteredPeraGraphs$ = new BehaviorSubject([]);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.numGroupsDisplay = this.groupService.changeNumberOfGroupsToShow$;
        this.expandedSubject$ = this.groupService.expandGroups$;
        this.groups$ = this.groupService.groupSubject$;
        // Load the configuration for the array view and subscribe to the PeraGraphs and Flowsheet services.
        this.arrayViewConfigService.configurationLoaded$.pipe(filter((isReady) => isReady), first()).subscribe(() => this.initializeArrayView());
        this.updateBehaviorBasedOnInputs();
    }
    /**
     * @return {?}
     */
    initializeArrayView() {
        // Once we have the configuration, we can get the rest of the information that we need
        this.arrayViewService.calcCurrentTimestamp();
        // get all Peragraphs on an interval and push them into the peraGraphSubject to be filtered
        this.peraGraphSubscription = this.peragraphApiService.getPeraGraphInterval().subscribe(peraGraphs => {
            this.peragraphApiService.getPeraGraphSubject().next(peraGraphs);
        });
        // uses combineLatest to update the array view when either new graphs are added (peraGraph Subject - sourced by peraGraphInterval and manual graph refreshes) or new filters are added (filterSubject)
        // and then filters before pushing to groups
        this.filteredPeraGraphsSubscription = combineLatest(this.peragraphApiService.getPeraGraphSubject(), this.filterService.filterSubject$).pipe(map((peraGraphsAndFilters) => peraGraphsAndFilters[0].filter(peraGraph => this.arrayViewService.filterPeragraph(peraGraph, this.filterService.activeFilters))), mergeMap((peraGraphs) => this.arrayViewService.addRIToPeraGraphs(peraGraphs)), map((peraGraphs) => peraGraphs.sort((peraGraphA, peraGraphB) => this.arrayViewService.sortGraphs(peraGraphA, peraGraphB, this.sortService.activeSortFunction))), tap((peraGraphs) => {
            // if this iteration of the filtered graphs subject was triggered by the apply filters button
            // then recalculate and close the proper groups
            // if generated by refresh button or interval, don't reset the closed groups
            /** @type {?} */
            const groupDisplay = this.arrayViewService.calculateNumberOfGroupsToShow(peraGraphs);
            if (this.groupService.changeGroupsClosed) {
                this.groupService.changeNumberOfGroupsToShow$.next(groupDisplay.groupsToShow);
                this.groupService.changeGroupsClosed = false;
            }
            this.groupService.expandGroups$.next(groupDisplay.expanded);
        })).subscribe((peraGraphs) => {
            // Assign an index to the anonymous property of the PeraGraph - used by the Anonymous Patient chart title.
            /** @type {?} */
            let anonymousIndex = 1;
            peraGraphs.forEach(graph => {
                graph.anonymous = anonymousIndex;
                anonymousIndex++;
            });
            this.filteredPeraGraphs$.next(peraGraphs);
            this.arrayViewService.completedRefresh$.next();
            // Push the new Chart title selection through the Subject.
            this.arrayViewService.chartTitleSubject$.next(this.arrayViewService.selectedChartTitle);
        });
        // Whenever we get new FSCs (on an interval) push them out through the subject so the groups receive the updated map of FSCs
        this.flowSheetSubscription = this.flowsheetsApiService.getFlowSheetInterval().subscribe(flowsheets => this.flowsheetsApiService.getFlowSheetSubject().next(flowsheets.body));
        // Whenever we get new prior warnings (on an interval) push them out through the subject so the groups receive the updated map of warnings
        if (this.priorWarningsConfigService.getPriorWarningEndPoint()) {
            this.priorWarningSubscription = this.priorWarningsApiService.getPriorWarningInterval().subscribe(priorWarnings => this.priorWarningsApiService.getPriorWarningSubject().next(priorWarnings.body));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.scrollContainerWidth !== this.getScrollContainerWidth()) {
            this.scrollContainerWidth = this.getScrollContainerWidth();
            if (this.ref) {
                this.ref.detectChanges();
            }
        }
    }
    /**
     * Used to dynamically set the width of the scroll container (based on the width of the array view component)
     * @return {?}
     */
    getScrollContainerWidth() {
        /** @type {?} */
        const width = this.arrayViewElementRef.nativeElement.offsetWidth;
        // Ensure that the container has padding
        /** @type {?} */
        const padding = width * .11;
        // Get the number of graphs that we should be able to display in the window (taking the padding into account)
        /** @type {?} */
        const numGraphsInRow = Math.floor((width - padding) / this.arrayViewService.peraGraphWidth);
        // Return the width
        return numGraphsInRow * this.arrayViewService.peraGraphWidth + 'px';
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updateBehaviorBasedOnInputs();
        // TODO update this when we add the ability to change the title/grouping/sorting
    }
    /**
     * Updates the fields in the array view service and in this component based on the input so that we see the desired behavior
     * @private
     * @return {?}
     */
    updateBehaviorBasedOnInputs() {
        this.disableGroupsIfAppropriate();
        this.setPeraGraphSortingFunction();
        this.updatePeraGraphDimensions();
    }
    /**
     * If we pass in an explicit width/height, use them
     * @private
     * @return {?}
     */
    updatePeraGraphDimensions() {
        if (this.peraGraphHeight && this.peraGraphWidth) {
            this.arrayViewService.peraGraphWidth = this.peraGraphWidth;
            this.arrayViewService.peraGraphHeight = this.peraGraphHeight;
            this.arrayViewService.refreshViewPort();
        }
    }
    /**
     * This sets the array view service's sorting function to the input passed to the array view component
     * @private
     * @return {?}
     */
    setPeraGraphSortingFunction() {
        if (this.peraGraphSortingFunction) {
            this.arrayViewService.sortGraphs = this.peraGraphSortingFunction;
        }
    }
    /**
     * If groups are disabled or absent, add a single group that will catch all graphs and not display a header
     * @private
     * @return {?}
     */
    disableGroupsIfAppropriate() {
        // If groups are disabled or if we don't have groups
        if (this.disableGroups || this.groups$ == null) {
            this.groups$ = of([[null, function (peraGraph) {
                        return true;
                    }]]);
        }
    }
    // not sure if this is needed since we are using combinedLatest above but I left it just in case
    // public filterChanged() {
    //   // Get the current list of PeraGraphs without making another call
    //   let peraGraphs = this.peragraphApiService.getPeraGraphSubject().value;
    //   // Filter the list according to the updated matchesFilter function within the arrayView service
    //   peraGraphs = this.arrayViewService.filterPeragraphs(peraGraphs, this.filterService.activeFilters)
    //   // Publish result to all subscribing groups
    //   this.peragraphApiService.getPeraGraphSubject().next(peraGraphs);
    // }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
        if (this.peraGraphSubscription && !this.peraGraphSubscription.closed) {
            this.peraGraphSubscription.unsubscribe();
        }
        if (this.flowSheetSubscription && !this.flowSheetSubscription.closed) {
            this.flowSheetSubscription.unsubscribe();
        }
        if (this.priorWarningSubscription && !this.priorWarningSubscription.closed) {
            this.priorWarningSubscription.unsubscribe();
        }
        if (this.filteredPeraGraphsSubscription && !this.filteredPeraGraphs$.closed) {
            this.filteredPeraGraphsSubscription.unsubscribe();
        }
    }
}
ArrayViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-array-view',
                template: "<div class=\"array-view\" #arrayView>\n    <!--<button class=\"btn btn-outline-success my-2 my-sm-0\" (click)=\"arrayViewService.toggleTileView()\">Tile View</button>-->\n    <phlib-group *ngFor=\"let group of groups$ | async; let i = index\"\n                 [showPeraGraphs]=\"i < numGroupsDisplay.value\"\n                 [expanded]=\"expandedSubject$.value\"\n                 [group]=\"group\" [peraGraphWidth]=\"arrayViewService.peraGraphWidth\"\n                 [peraGraphHeight]=\"arrayViewService.peraGraphHeight\" [scrollContainerWidth]=\"scrollContainerWidth\"\n                 [filteredPeraGraphs$]=\"filteredPeraGraphs$\"\n    ></phlib-group>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
ArrayViewComponent.ctorParameters = () => [
    { type: ArrayViewService },
    { type: ArrayViewConfigService },
    { type: PeragraphApiService },
    { type: FilterService },
    { type: FlowsheetsApiService },
    { type: PriorWarningsConfigService },
    { type: PriorWarningsApiService },
    { type: PeraGraphService },
    { type: SortService },
    { type: GroupService },
    { type: ChangeDetectorRef }
];
ArrayViewComponent.propDecorators = {
    peraGraphSortingFunction: [{ type: Input }],
    peraGraphTitleFunction: [{ type: Input }],
    disableGroups: [{ type: Input }],
    numGroupsDisplay: [{ type: Input }],
    peraGraphHeight: [{ type: Input }],
    peraGraphWidth: [{ type: Input }],
    arrayViewElementRef: [{ type: ViewChild, args: ['arrayView',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupComponent {
    /**
     * @param {?} arrayViewService
     * @param {?} filterService
     * @param {?} peraGraphService
     * @param {?} peragraphApiService
     * @param {?} ref
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(arrayViewService, filterService, peraGraphService, peragraphApiService, ref, elementRef, renderer) {
        this.arrayViewService = arrayViewService;
        this.filterService = filterService;
        this.peraGraphService = peraGraphService;
        this.peragraphApiService = peragraphApiService;
        this.ref = ref;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.showPeraGraphs = false;
        this.expanded = false;
        this.filterFunction = null;
        // Default number of rows - TODO possibly make this configurable, or remember the user's last selection and save it
        this.nonExpandedRows = 3;
        this.expandedRows = 6;
        this.currentNumberOfRowsDisplayed = this.nonExpandedRows;
        this.options$ = new BehaviorSubject(null);
        // Differentiate between a single click and a double click
        this.clickTimer = 0;
        this.preventSingleClick = false;
        this.style = { maxHeight: this.viewContainerMaxHeight };
        this.hideGroup = false;
        /**
         * Function to determine equality, given two indicies in the array (optional, default: (p,c) => p === c))
         *
         * @param prevDataIndex
         * @param curDataIndex
         * @return
         */
        this.equals = (prevDataIndex, curDataIndex) => {
            /** @type {?} */
            const curPeraGraph = this.currentPeraGraphs[curDataIndex];
            /** @type {?} */
            const previousPeraGraph = (this.previousPeraGraphs) ? this.previousPeraGraphs[prevDataIndex] : null;
            /*
             Most browsers maintain the order of the fields so this should work in most cases and when it fails, it'll just return false so anything
             else is an optimization
             */
            return previousPeraGraph != null && curPeraGraph != null && JSON.stringify(previousPeraGraph) === JSON.stringify(curPeraGraph);
        };
    }
    // TODO break pieces out into a service as appropriate
    /**
     * @return {?}
     */
    ngOnInit() {
        // Set the group information
        this.groupName = this.group.laneTitle;
        this.filterFunction = this.group.laneFunction;
        this.updatePeraGraphs();
        if (this.expanded) {
            this.currentNumberOfRowsDisplayed = this.expandedRows;
        }
        else {
            this.currentNumberOfRowsDisplayed = this.nonExpandedRows;
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updateNumberOfItemsInViewport();
        // Identify the ideal width, and set both it and the height through ng-style on the viewport container
        this.updateViewPortPerCurrentRows();
        this.updatePeraGraphs();
        this.maintainGroupLength();
    }
    /**
     * @return {?}
     */
    hideOrDisplayGroup() {
        if (this.elementRef) {
            if (this.groupLength === 0) {
                this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'none');
            }
            else {
                this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'block');
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    updatePeraGraphs() {
        this.peraGraphs$ = this.filteredPeraGraphs$.pipe(map(peraGraphs => peraGraphs.filter(peraGraph => this.matchesGroup(peraGraph))), tap(peraGraphs => {
            // Used to determine equality for virtual scrolling
            this.previousPeraGraphs = this.currentPeraGraphs;
            this.currentPeraGraphs = peraGraphs;
            // Specifies the number of graphs in a group
            this.groupLength = peraGraphs.length;
            this.hideOrDisplayGroup();
        }));
    }
    /**
     * When we're not displaying PeraGraphs, we don't pass the observable to the virtual scroll which typically populates the group length.
     * This function will conditionally get the group length through other means.
     * @return {?}
     */
    maintainGroupLength() {
        if (!this.showPeraGraphs) {
            // If we're not showing peraGraphs, subscribe separately so that we can get the group length
            this.peraGraphs_length$ = this.filteredPeraGraphs$.pipe(map(peraGraphs => peraGraphs.filter(peraGraph => this.matchesGroup(peraGraph)))).subscribe((peraGraphs) => {
                this.groupLength = peraGraphs.length;
                this.hideOrDisplayGroup();
                if (this.ref) {
                    this.ref.detectChanges();
                }
            });
        }
        else if (this.peraGraphs_length$ && !this.peraGraphs_length$.closed) {
            // If we're showing peraGraphs, there's no need for this subscription
            this.peraGraphs_length$.unsubscribe();
        }
    }
    /**
     * This function determines which graphs belong to this group
     *
     * @param {?} peraGraph
     * @return {?}
     */
    matchesGroup(peraGraph) {
        if (this.filterFunction) {
            return this.filterFunction(peraGraph);
        }
        return true;
    }
    /**
     * Called when the viewport is being resized manually
     *
     * @param {?} event
     * @return {?}
     */
    onResizing(event) {
        // Set the height according to the event
        this.viewContainerMaxHeight = event.rectangle.height + 'px';
        // Set the number of rows that should be displayed according to the new height
        this.currentNumberOfRowsDisplayed = Math.ceil(event.rectangle.height / this.peraGraphHeight);
        this.updateViewPortPerCurrentRows();
    }
    /**
     * Called when the header is clicked
     * @return {?}
     */
    click() {
        this.preventSingleClick = false;
        // @ts-ignore
        this.clickTimer = setTimeout(() => {
            if (!this.preventSingleClick) {
                this.toggleShow();
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        }, 200);
    }
    /**
     * Called when the header is double clicked
     * @return {?}
     */
    doubleClick() {
        clearTimeout(this.clickTimer);
        this.preventSingleClick = true;
        this.toggleExpand();
    }
    /**
     * Updates the height/width of the viewport container as well as the height/width/number of items in the viewport
     * @return {?}
     */
    updateViewPortPerCurrentRows() {
        if (this.expanded) {
            this.currentNumberOfRowsDisplayed = this.expandedRows;
        }
        else {
            this.currentNumberOfRowsDisplayed = this.nonExpandedRows;
        }
        // Set the height of the container from the number of rows that should be displayed
        this.viewContainerMaxHeight = this.getViewPortHeightFromRowsAsString(this.currentNumberOfRowsDisplayed);
        this.setStyle(this.viewContainerMaxHeight);
        // Update the options so that the correct number of rows are displayed in the viewport
        this.updateNumberOfItemsInViewport();
    }
    /**
     * Toggles whether or not any PeraGraphs are shown in the group
     * @return {?}
     */
    toggleShow() {
        // Switch from removing the element from the DOM via ngIf to using the hidden attribute once it's rendered once
        this.hideGroup = (this.showPeraGraphs) ? !this.hideGroup : false;
        this.arrayViewService.tokenRefresh$.next();
        // If we have never displayed PeraGraphs in this group
        if (!this.showPeraGraphs) {
            // Start rendering graphs for the first time
            this.startRenderingPeraGraphs();
        }
    }
    /**
     * This function toggles expansion of the viewport height
     * @return {?}
     */
    toggleExpand() {
        this.arrayViewService.tokenRefresh$.next();
        this.expanded = !this.expanded;
        // Update the number of rows being displayed according to the current expanded status
        this.currentNumberOfRowsDisplayed = (this.expanded) ? this.expandedRows : this.nonExpandedRows;
        // Update the viewport
        this.updateViewPortPerCurrentRows();
        // If we're not showing graphs, show them
        if (!this.showPeraGraphs || this.hideGroup) {
            this.hideGroup = false;
            // If we have never displayed peragraphs in this group
            if (!this.showPeraGraphs) {
                // Start rendering graphs for the first time
                this.startRenderingPeraGraphs();
            }
        }
    }
    /**
     * If ngIf is currently evaluating to false, trigger a change and update the view container
     * @return {?}
     */
    startRenderingPeraGraphs() {
        this.showPeraGraphs = true;
        this.updateViewPortPerCurrentRows();
        if (this.ref) {
            this.ref.detectChanges();
        }
    }
    /**
     * Updates item size and the number of rows being rendered
     * @return {?}
     */
    updateNumberOfItemsInViewport() {
        this.options$.next({
            itemHeight: this.peraGraphHeight,
            itemWidth: this.peraGraphWidth,
            numAdditionalRows: this.getNumberOfRowsToRender()
        });
    }
    /**
     * Applies a buffer to the number of rows being displayed to improve scrolling performance
     *
     * @return {?}
     */
    getNumberOfRowsToRender() {
        /** @type {?} */
        const additionalRowsToRender = (this.arrayViewService.isDisplayingTiles()) ? 100 : 2;
        return this.currentNumberOfRowsDisplayed + additionalRowsToRender;
    }
    /**
     * Set the height and width of the viewport container
     *
     * @param {?} height
     * @return {?}
     */
    setStyle(height) {
        this.style = {
            maxHeight: height,
            width: this.scrollContainerWidth
        };
    }
    /**
     * Returns the ideal viewport height for the number of rows passed to the function
     *
     * @param {?} rows
     * @return {?}
     */
    getViewPortHeightFromRowsAsString(rows) {
        return this.peraGraphHeight * rows + 'px';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
        this.filterFunction = null;
    }
}
GroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-group',
                template: "<div class=\"clickable-header\">\n  <app-group-header\n    (click)=\"click()\"\n    (dblclick)=\"doubleClick()\"\n    [name]=\"groupName\"\n    [numberOfPatients]=\"groupLength\"\n    *ngIf=\"groupName\"\n  ></app-group-header>\n</div>\n\n<od-virtualscroll class=\"ph-group\" *ngIf=\"showPeraGraphs\" [ngStyle]=\"style\"\n                  mwlResizable [resizeEdges]=\"{bottom: true}\"\n                  (resizing)=\"onResizing($event)\" [resizeCursorPrecision]=\"8\" [vsData]=\"peraGraphs$\"\n                  [vsOptions]=\"options$\" [vsEqualsFunc]=\"equals\" [hidden]=\"hideGroup\">\n  <ng-template let-peraGraph>\n    <phlib-pera-graph\n      [graph]=\"peraGraph\"\n      [peraGraphHeight]=\"peraGraphHeight\"\n      [peraGraphWidth]=\"peraGraphWidth\">\n      >\n    </phlib-pera-graph>\n  </ng-template>\n</od-virtualscroll>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["mwlResizable{box-sizing:border-box}.ph-group{margin-right:5vw;margin-left:5vw;overflow:auto;display:flex;justify-content:space-between}/deep/ .od-scroll-container{margin:0}.clickable-header{margin-right:8vw}"]
            }] }
];
/** @nocollapse */
GroupComponent.ctorParameters = () => [
    { type: ArrayViewService },
    { type: FilterService },
    { type: PeraGraphService },
    { type: PeragraphApiService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 }
];
GroupComponent.propDecorators = {
    showPeraGraphs: [{ type: Input }],
    expanded: [{ type: Input }],
    group: [{ type: Input }],
    peraGraphHeight: [{ type: Input }],
    peraGraphWidth: [{ type: Input }],
    scrollContainerWidth: [{ type: Input }],
    filteredPeraGraphs$: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipService {
    /**
     * @param {?} graphService
     * @param {?} arrayViewService
     * @param {?} http
     * @param {?} loginService
     * @param {?} tokenApiService
     * @param {?} arrayViewConfigService
     */
    constructor(graphService, arrayViewService, http, loginService, tokenApiService, arrayViewConfigService) {
        this.graphService = graphService;
        this.arrayViewService = arrayViewService;
        this.http = http;
        this.loginService = loginService;
        this.tokenApiService = tokenApiService;
        this.arrayViewConfigService = arrayViewConfigService;
        this.toolTipInfoUpdated$ = new Subject();
    }
    /**
     * @param {?} graph
     * @return {?}
     */
    updateToolTipInfo(graph) {
        this.tokenApiService.refreshToken(this.loginService.getCurrentUser());
        // Get the current tooltip info from the server.
        this.http.get(this.arrayViewConfigService.getToolTipInfoEndPoint() + '/pid/' + graph.patient.pid + '/visit/' + graph.visitId).pipe(first()).subscribe((toolTipInfo) => {
            // Ensure that the user hasn't moved onto a new graph with a different during the time that the call was made to the server
            if (graph.visitId === toolTipInfo.visitId) {
                /** @type {?} */
                const numberOfOtherVisitsWithValidRi = toolTipInfo.numberOfOtherVisitsWithValidRi;
                // The query will return a -1 value if the current and only visit has no valid RI scores.
                graph.numberVisitsWithValidRI = (numberOfOtherVisitsWithValidRi > 0) ? numberOfOtherVisitsWithValidRi : 0;
                // Tooltip diagnosis formatting
                if (toolTipInfo.diagnosis != null) {
                    // Replace the first ^ with nothing
                    /** @type {?} */
                    const tmpDiag = toolTipInfo.diagnosis.replace('^', '');
                    // Replace the rest of the ^ with ', '
                    graph.diagnosis = tmpDiag.replace(/\^/g, ', ');
                }
                this.toolTipInfoUpdated$.next(toolTipInfo);
            }
        });
    }
}
TooltipService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TooltipService.ctorParameters = () => [
    { type: PeraGraphService },
    { type: ArrayViewService },
    { type: HttpClient },
    { type: LoginService },
    { type: TokenApiService },
    { type: ArrayViewConfigService }
];
/** @nocollapse */ TooltipService.ngInjectableDef = defineInjectable({ factory: function TooltipService_Factory() { return new TooltipService(inject(PeraGraphService), inject(ArrayViewService), inject(HttpClient), inject(LoginService), inject(TokenApiService), inject(ArrayViewConfigService)); }, token: TooltipService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeraGraphComponent {
    /**
     * @param {?} service
     * @param {?} flowsheetsApiService
     * @param {?} priorWarningsApiService
     * @param {?} usageService
     * @param {?} graphService
     * @param {?} toolTipService
     * @param {?} http
     * @param {?} ref
     */
    constructor(service, flowsheetsApiService, priorWarningsApiService, usageService, graphService, toolTipService, http, ref) {
        this.service = service;
        this.flowsheetsApiService = flowsheetsApiService;
        this.priorWarningsApiService = priorWarningsApiService;
        this.usageService = usageService;
        this.graphService = graphService;
        this.toolTipService = toolTipService;
        this.http = http;
        this.ref = ref;
        this.margin = 10;
        this.isMouseOverPeraGraph = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscribeToPeraGraphDataFeeds();
        this.subscribeToToolTipInfoEvent();
        this.style = {
            width: this.peraGraphWidth - this.margin + 'px',
            height: this.peraGraphHeight - this.margin + 'px'
        };
        this.usageService.addUsageData(this.graph, UsageType.Array);
        // Manage change detection explicitly
        this.ref.detach();
    }
    /**
     * Subscribe to the interval observables/subjects that pass information the PeraGraph needs
     *
     * Currently, this includes prior warnings and flowsheets
     * @return {?}
     */
    subscribeToPeraGraphDataFeeds() {
        this.flowSheetMap$ = this.flowsheetsApiService.getFlowSheetSubject().subscribe((fscMap) => {
            this.getFlowSheetsForVisit(fscMap);
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
        this.priorWarningMap$ = this.priorWarningsApiService.getPriorWarningSubject().subscribe((pwMap) => {
            this.getPriorWarningsForVisit(pwMap);
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
    }
    /**
     * @return {?}
     */
    subscribeToToolTipInfoEvent() {
        this.toolTipInfoEvent$ = this.toolTipService.toolTipInfoUpdated$.subscribe((toolTipInfo) => {
            // Ensure that the user hasn't moved onto a new graph with a different during the time that the call was made to the server
            if (this.isMouseOverPeraGraph && toolTipInfo.visitId === this.graph.visitId) {
                // If the service takes a second to respond and the popover is no longer there, don't try to open it
                if (this.tooltip) {
                    this.graphService.tooltip = this.tooltip;
                    this.tooltip.open();
                }
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        });
    }
    /**
     * This only fires when the user passes the mouse over the graph to get the tooltip.
     * For those graphs, force a change detection cycle so that the ToolTip component updates.
     * @param {?} po
     * @return {?}
     */
    mouseEnterHandler(po) {
        if (!this.isMouseOverPeraGraph && !po.isOpen()) {
            this.isMouseOverPeraGraph = true;
            this.tooltip = po;
            if (this.graph) {
                // Close any existing tooltip
                this.graphService.closeToolTip();
                this.toolTipService.updateToolTipInfo(this.graph);
            }
        }
    }
    /**
     * This fires when the user passes the mouse over the graph, and then moves the mouse off of the graph
     * For those graphs, close the tooltip
     *
     * @param {?} po
     * @return {?}
     */
    mouseLeaveHandler(po) {
        this.isMouseOverPeraGraph = false;
        if (po.isOpen()) {
            po.close();
        }
    }
    /**
     * @param {?} graph
     * @return {?}
     */
    graphClicked(graph) {
        if (this.tooltip && this.tooltip.isOpen()) {
            // console.log('Forcefully closing tooltip');
            this.tooltip.close();
            this.tooltip = null;
        }
        this.graphService.graphClickedEvent(graph);
        this.service.tokenRefresh$.next();
    }
    /**
     * @param {?} po
     * @return {?}
     */
    isShown(po) {
        if (!this.tooltip) {
            // Closing tooltip
            setTimeout(() => po.close(), 1);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // If the item size changed, update style
        if (changes && changes.peraGraphWidth && changes.peraGraphWidth.previousValue !== changes.peraGraphWidth.currentValue) {
            this.style = {
                width: this.peraGraphWidth - this.margin + 'px',
                height: this.peraGraphHeight - this.margin + 'px'
            };
        }
        // If the graph changed, update the related data so that we're showing the right information
        if (changes &&
            changes.graph &&
            changes.graph.currentValue !== changes.graph.previousValue &&
            !changes.graph.firstChange &&
            changes.graph.currentValue.visitId !== changes.graph.previousValue.visitId) {
            // console.log('ArrayView change: Adding usage data for ' + this.graph.vnm);
            this.usageService.addUsageData(this.graph, UsageType.Array);
            // The graph that we're displaying changed so get the new FSCs from the map
            /** @type {?} */
            const fscMap = this.flowsheetsApiService.getFlowSheetSubjectValue();
            this.getFlowSheetsForVisit(fscMap);
            // Get the prior warning for this graph instead of the stale graph
            /** @type {?} */
            const priorWarnings = this.priorWarningsApiService.getPriorWarningSubjectValue();
            this.getPriorWarningsForVisit(priorWarnings);
            // Push the changes
            if (this.ref) {
                this.ref.detectChanges();
            }
        }
    }
    /**
     * @param {?} fscMap
     * @return {?}
     */
    getFlowSheetsForVisit(fscMap) {
        if (fscMap) {
            /** @type {?} */
            const fsc = fscMap[this.graph.visitId];
            // Update the RI-related fields if necessary
            if (fsc && !(this.flowsheets === fsc) && JSON.stringify(this.flowsheets) !== JSON.stringify(fsc)) {
                // Note this may trigger extra changes based on how browsers handle JSON object order
                this.flowsheets = fsc;
                this.latestRi = fsc[this.flowsheets.length - 1].riScore;
            }
            else if (!fsc && this.flowsheets !== null) {
                // Clear the RI-related fields
                this.flowsheets = [];
                this.latestRi = null;
            }
        }
    }
    /**
     * @param {?} priorWarnings
     * @return {?}
     */
    getPriorWarningsForVisit(priorWarnings) {
        if (priorWarnings) {
            /** @type {?} */
            const pw = priorWarnings[this.graph.visitId];
            // TODO can we set this.priorWarning = pw without the logic below?
            // If we have a prior warning and it's not the same, trigger a change
            if (pw && pw !== this.priorWarning) {
                this.priorWarning = pw;
            }
            else if (!pw) {
                // No prior warning exists, update our prior warning to reflect this
                this.priorWarning = null;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
        // Unsubscribe when the component is destroyed
        if (this.flowSheetMap$ && !this.flowSheetMap$.closed) {
            this.flowSheetMap$.unsubscribe();
        }
        if (this.priorWarningMap$ && !this.priorWarningMap$.closed) {
            this.priorWarningMap$.unsubscribe();
        }
        if (this.toolTipInfoEvent$ && !this.toolTipInfoEvent$.closed) {
            this.toolTipInfoEvent$.unsubscribe();
        }
    }
}
PeraGraphComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-pera-graph',
                template: "<div class=\"ph-pera-graph\"\n     id=\"{{ graph.vnm }}\"\n     (click)=\"graphClicked(graph)\"\n     [ngStyle]=\"style\">\n\n    <phlib-pera-graph-tile *ngIf=\"service.isDisplayingTiles();else displayPeraGraph\" [graph]=\"graph\"\n                           [latestRi]=\"latestRi\" [priorWarning]=\"priorWarning\"\n                           (mouseenter)=\"mouseEnterHandler(po)\"\n                           (mouseleave)=\"mouseLeaveHandler(po)\"\n                           #po=\"ngbPopover\"\n                           class=\"width-adjustment\"\n                           [ngbPopover]=\"popTemplate\"\n                           [autoClose]=\"true\"\n                           popoverTitle=\"Visit Info\"\n                           placement=\"auto\"\n                           triggers=\"manual\"\n                           container='body'>\n              <ng-template #popTemplate>\n                <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n              </ng-template>\n    </phlib-pera-graph-tile>\n\n    <ng-template #displayPeraGraph>\n      <phlib-pera-graph-header class=\"peraGraphHeader\"\n                               [graph]=\"graph\"\n                               [latestRi]=\"latestRi\"\n                               [priorWarning]=\"priorWarning\"></phlib-pera-graph-header>\n      <phlib-chart\n          [graph]=\"graph\"\n          [flowsheets]=\"flowsheets\"\n          class=\"width-adjustment\"\n          (mouseenter)=\"mouseEnterHandler(po)\"\n          (mouseleave)=\"mouseLeaveHandler(po)\"\n          #po=\"ngbPopover\"\n          [ngbPopover]=\"popTemplate\"\n          [autoClose]=\"true\"\n          (shown)=\"isShown(po)\"\n          triggers=\"manual\"\n          popoverTitle=\"Visit Info\"\n          placement=\"auto\"\n          container='body'>\n        </phlib-chart>\n        <ng-template #popTemplate>\n          <phlib-chart-tooltip [graph]=\"graph\"></phlib-chart-tooltip>\n        </ng-template>\n    </ng-template>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ph-pera-graph{border:1px solid #000;padding-top:auto;margin-right:5px;background-color:#fff!important;display:inline-flex;position:relative}.width-adjustment{width:inherit}"]
            }] }
];
/** @nocollapse */
PeraGraphComponent.ctorParameters = () => [
    { type: ArrayViewService },
    { type: FlowsheetsApiService },
    { type: PriorWarningsApiService },
    { type: UsageApiService },
    { type: PeraGraphService },
    { type: TooltipService },
    { type: HttpClient },
    { type: ChangeDetectorRef }
];
PeraGraphComponent.propDecorators = {
    graph: [{ type: Input }],
    peraGraphWidth: [{ type: Input }],
    peraGraphHeight: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Highcharts = require('highcharts');
// The JavaScript compiler gives a weird "moment cannot be used as a namespace" type of error
// This is the workaround...
/** @type {?} */
const moment$2 = moment_;
class ChartComponent {
    /**
     * @param {?} dateService
     * @param {?} chartService
     * @param {?} arrayViewService
     * @param {?} ref
     */
    constructor(dateService, chartService, arrayViewService, ref) {
        this.dateService = dateService;
        this.chartService = chartService;
        this.arrayViewService = arrayViewService;
        this.ref = ref;
        this.Highcharts = Highcharts;
        this.X_AXIS_DAYS = 5;
        this.DAY_IN_MILLISECONDS = 86400000;
        this.minRiScore = 0;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Manage change detection explicitly
        this.ref.detach();
        // Get the series
        this.series = this.getChartSeries();
        // Build the chart options
        this.chartOptions = this.getChartOptions();
        // Trigger change detection
        this.ref.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        // Ensure that a chart already exists
        if (this.Highcharts && this.chartOptions) {
            // Fetch the series using the latest flowsheet information
            this.series = this.getChartSeries();
            // If the series is different
            if (this.series !== this.chartOptions.series) {
                this.updateChart();
                this.chartOptions = Object.assign({}, this.chartOptions);
                if (this.ref) {
                    this.ref.detectChanges();
                }
            }
        }
    }
    /**
     * Updates the chart
     * @return {?}
     */
    updateChart() {
        this.chartOptions.series = this.series;
        this.updateXAxis();
        this.updateYAxis();
    }
    /**
     * Updates the pieces of the Y axis that need updating
     * @return {?}
     */
    updateYAxis() {
        /** @type {?} */
        const minYAxisTick = this.chartService.getMinYAxisTick(this.minRiScore);
        // If the min Y axis value would change, update it
        if (this.chartOptions.yAxis[0].min !== minYAxisTick) {
            this.chartOptions.yAxis[0].min = minYAxisTick;
            this.chartOptions.yAxis[0].plotLines = this.chartService.createZeroAxisLine(this.minRiScore);
        }
    }
    /**
     * Updates the pieces of the X axis that need updating
     * @return {?}
     */
    updateXAxis() {
        this.chartOptions.xAxis = this.getXaxis();
    }
    /**
     * Returns the chart options
     * @return {?}
     */
    getChartOptions() {
        return {
            chart: {
                type: 'line',
                spacing: [2, 0, 0, 0],
                marginLeft: 18,
                marginRight: 2,
                plotBackgroundColor: 'white',
                reflow: false,
                animation: false,
                alignTicks: false
            },
            tooltip: {
                enabled: false,
                animation: false
            },
            plotOptions: {
                series: {
                    color: '#848484',
                    turboThreshold: 0,
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                },
                line: {
                    animation: false,
                    enableMouseTracking: false,
                    stickyTracking: false,
                    shadow: false,
                    dataLabels: {
                        style: {
                            textShadow: false
                        }
                    }
                }
            },
            credits: {
                enabled: false
            },
            legend: {
                enabled: false
            },
            title: {
                text: ''
            },
            xAxis: this.getXaxis(),
            yAxis: this.getYaxis(),
            series: this.series
        };
    }
    /**
     * @return {?}
     */
    getXaxis() {
        /** @type {?} */
        const xAxis = [];
        xAxis.push({
            type: 'datetime',
            startOnTick: false,
            endOnTick: false,
            tickInterval: this.graph.isDischarged ? null : this.DAY_IN_MILLISECONDS,
            gridLineWidth: 1,
            plotLines: this.chartService.updateAlertPlotLine(this.graph),
            title: {
                text: ' '
            },
            labels: {
                distance: 20,
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                formatter: function () {
                    return moment$2(this.value).utcOffset(0).format('MM/DD');
                },
                step: 1
            },
            min: this.getMinXAxisValue(),
            max: this.getMaxXAxisValue(),
        });
        return xAxis;
    }
    /**
     * @return {?}
     */
    getMaxXAxisValue() {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone);
    }
    /**
     * @return {?}
     */
    getMinXAxisValue() {
        return (this.graph.discharged) ? null : this.dateService.translateDate(this.arrayViewService.getCurrentTimestamp(), this.graph.timeZone) - this.X_AXIS_DAYS * this.DAY_IN_MILLISECONDS;
    }
    /**
     * @return {?}
     */
    getYaxis() {
        /** @type {?} */
        const yAxis = [];
        yAxis.push({
            title: {
                text: ' '
            },
            labels: {
                style: {
                    color: 'black',
                    'font-size': '.6em'
                },
                padding: 1,
                align: 'center'
            },
            offset: -12,
            //     gridLineColor : colorHealthScoreGridLine,
            gridLineWidth: 1,
            min: this.chartService.getMinYAxisTick(this.minRiScore),
            max: 100,
            plotLines: this.chartService.createZeroAxisLine(this.minRiScore),
            tickPositioner: function (min, max) {
                /** @type {?} */
                let tick = min;
                /** @type {?} */
                const ticks = [];
                while (tick <= max) {
                    ticks.push(tick);
                    tick += 20;
                }
                return ticks;
            }
        });
        return yAxis;
    }
    /**
     * @return {?}
     */
    getChartSeries() {
        /** @type {?} */
        const series = [];
        series.push({
            name: '',
            data: this.getDataPoints(this.flowsheets),
            showInLegend: false,
            turboThreshold: 0,
            color: {
                linearGradient: { x1: 0, x2: 1, y1: 0, y2: 0 },
                stops: this.getArrayOfLocationChanges(this.flowsheets)
            },
            marker: {
                enabled: (this.flowsheets && this.flowsheets.length === 1) ? true : false,
                color: (this.flowsheets && this.flowsheets.length === 1) ? this.chartService.getMarkerColor(this.flowsheets[0].unitType) : null,
                radius: 1.5
            }
        });
        return series;
    }
    /**
     * @param {?} fscList
     * @return {?}
     */
    getArrayOfLocationChanges(fscList) {
        /** @type {?} */
        const range = this.maxRecordedDt - this.minRecordedDt;
        /** @type {?} */
        const colors = [[0, 'black']];
        /** @type {?} */
        let color = 'black';
        /** @type {?} */
        let unitType = null;
        /** @type {?} */
        let xval = 0;
        if (fscList && range > 0) {
            fscList.forEach((fsc) => {
                // If the unit type changed
                if (fsc.unitType !== unitType) {
                    // Get the percentage across the X axis by recorded date
                    xval = (fsc.key.recordedDt - this.minRecordedDt) / range;
                    // add an entry just prior to this point to smooth the gradient
                    colors.push([xval - .0001, color]);
                    // The the appropriate color for this unitType
                    color = this.chartService.getMarkerColor(fsc.unitType);
                    // Push the change in color
                    colors.push([xval, color]);
                    // Remember the current unit type
                    unitType = fsc.unitType;
                }
            });
        }
        return colors;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getDataPoints(data) {
        /** @type {?} */
        const dataPoints = [];
        // Reset the variables
        this.minRiScore = 100;
        this.minRecordedDt = 999999999999999999999;
        this.maxRecordedDt = 0;
        // If we have data
        if (data) {
            data.forEach((fsc) => {
                dataPoints.push([this.dateService.translateDate(fsc.key.recordedDt, this.graph.timeZone), fsc.riScore + (Math.random() / 1000)]);
                // Keep track of the extreme values - they are used elsewhere
                this.minRecordedDt = (this.minRecordedDt > fsc.key.recordedDt) ? fsc.key.recordedDt : this.minRecordedDt;
                this.maxRecordedDt = (this.maxRecordedDt < fsc.key.recordedDt) ? fsc.key.recordedDt : this.maxRecordedDt;
                this.minRiScore = (this.minRiScore > fsc.riScore) ? fsc.riScore : this.minRiScore;
            });
        }
        return dataPoints;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ref) {
            this.ref.detach();
            this.ref = null;
        }
    }
}
ChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-chart',
                template: "<div class=\"ph-graph\" *ngIf=\"!flowsheets || flowsheets.length != 0\">\n  <highcharts-chart class=\"ph-hc\"\n                    [Highcharts]=\"Highcharts\"\n                    [options]=\"chartOptions\"\n  ></highcharts-chart>\n</div>\n\n<div class=\"insufficient-data ph-hc\" *ngIf=\"flowsheets && flowsheets.length == 0\">\n  <div class=\"insufficient-data-text\">Insufficient data received to generate RI graph\n    <div *ngIf=\"graph && graph.activeWarning\" class=\"insufficient-data-text\">\n      <br>\n      Warning state generated by prior visit\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ph-graph{width:99%;height:83%;position:absolute;top:17%;left:1px;cursor:pointer}.ph-hc{width:100%!important;position:absolute!important;height:100%!important}.insufficient-data{font-size:.7em;font-weight:700;color:#60606a;padding-left:5%;padding-right:5%;padding-top:13%;display:flex;margin:auto}.insufficient-data-text{margin:auto}"]
            }] }
];
/** @nocollapse */
ChartComponent.ctorParameters = () => [
    { type: DateService },
    { type: ChartService },
    { type: ArrayViewService },
    { type: ChangeDetectorRef }
];
ChartComponent.propDecorators = {
    flowsheets: [{ type: Input }],
    graph: [{ type: Input }],
    currentTimestamp: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeraGraphTileComponent {
    /**
     * @param {?} peraGraphService
     * @param {?} warningService
     * @param {?} arrayViewService
     * @param {?} ref
     */
    constructor(peraGraphService, warningService, arrayViewService, ref) {
        this.peraGraphService = peraGraphService;
        this.warningService = warningService;
        this.arrayViewService = arrayViewService;
        this.ref = ref;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Subscribe to the chart title subject and invoke change detection when new value is pushed.
        this.arrayViewService.chartTitleSubject$.subscribe(() => {
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updateBackgroundColor();
    }
    /**
     * @return {?}
     */
    updateBackgroundColor() {
        /** @type {?} */
        const warning = (this.graph) ? this.graph.activeWarning : null;
        this.style = {
            backgroundColor: this.peraGraphService.getBackgroundColorByWarningAndRi(warning, this.latestRi, this.graph.discharged)
        };
        this.priorWarningIndicator = this.warningService.getWarningClass(this.priorWarning);
    }
}
PeraGraphTileComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-pera-graph-tile',
                template: "<!-- Outer div establishes QA test lookup ID, other divs display over the top of each other -->\n<div id=\"{{ arrayViewService.chartTitleSubject$.value.returnFunc(this.graph) }}\" class=\"ph-tile\">\n    <div class=\"inner ph-tile {{ priorWarningIndicator }}\" [ngStyle]=\"style\">\n    </div>\n    <div class=\"inner ph-tile-score\" style=\"background-color: transparent\">\n        {{ this.peraGraphService.getRiScoreToDisplay(this.latestRi) }}\n    </div>\n</div>\n",
                styles: [".inner{position:absolute}.ph-tile{width:100%;height:100%;text-align:center;cursor:pointer}.ph-tile-score{font-size:1.3em;padding-top:25%;text-align:center;text-shadow:1px 1px 3px #3b3b3b;color:#fff;width:100%;height:100%}.vh-warning{width:0;height:0;border-style:solid;border-width:0 63px 63px 0;border-color:transparent #d51c19 transparent transparent}.h-warning{width:0;height:0;border-style:solid;border-width:0 63px 63px 0;border-color:transparent #fc7134 transparent transparent}.m-warning{width:0;height:0;border-style:solid;border-width:0 63px 63px 0;border-color:transparent #fdc43a transparent transparent}"]
            }] }
];
/** @nocollapse */
PeraGraphTileComponent.ctorParameters = () => [
    { type: PeraGraphService },
    { type: WarningService },
    { type: ArrayViewService },
    { type: ChangeDetectorRef }
];
PeraGraphTileComponent.propDecorators = {
    graph: [{ type: Input }],
    latestRi: [{ type: Input }],
    priorWarning: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
GroupHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-group-header',
                template: "<div class=\"group-header\">\n    <div class=\"info\">\n        <div id='{{name}}' class=\"dashboard-grouping-info\">{{name}}</div>\n        <div id='{{name}}-{{numberOfPatients}}' class=\"dashboard-grouping-info pull-right-info\">Patients: {{numberOfPatients}}</div>\n        <hr>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".group-header{margin:.7em 10px 0 3vw;display:block;cursor:pointer}.info{background-color:#f2f2f2;position:relative;z-index:6;height:2.4em}.group-header .dashboard-grouping-info.pull-right-info{font-size:.7em;color:#666;float:right;padding-right:0}.group-header .dashboard-grouping-info{display:inline-block;font-size:1.2em;color:#999;background-color:#f2f2f2;z-index:4;position:relative;padding-right:10px}hr{margin-top:.5em;margin-bottom:.5em;overflow:hidden;border-top:2px solid #898989;position:relative;top:-1.2em;z-index:0}"]
            }] }
];
/** @nocollapse */
GroupHeaderComponent.ctorParameters = () => [];
GroupHeaderComponent.propDecorators = {
    numberOfPatients: [{ type: Input }],
    name: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeraGraphHeaderComponent {
    /**
     * @param {?} peraGraphService
     * @param {?} warningService
     * @param {?} arrayViewService
     * @param {?} ref
     */
    constructor(peraGraphService, warningService, arrayViewService, ref) {
        this.peraGraphService = peraGraphService;
        this.warningService = warningService;
        this.arrayViewService = arrayViewService;
        this.ref = ref;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Subscribe to the chart title subject and invoke change detection when new value is pushed.
        this.arrayViewService.chartTitleSubject$.subscribe(() => {
            if (this.ref) {
                this.ref.detectChanges();
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // If the latest RI or graph changed, update the header color
        if (changes.latestRi || changes.graph) {
            this.updateHeaderColor();
        }
        this.priorWarningIndicator = this.warningService.getWarningClass(this.priorWarning);
        // This is so that QA can find the prior warning indicator and ensure that it has the correct color
        this.priorWarningIndicatorId = 'priorWarningIndicator-' + this.graph.vnm;
    }
    /**
     * @return {?}
     */
    updateHeaderColor() {
        /** @type {?} */
        const warning = (this.graph) ? this.graph.activeWarning : null;
        this.style = {
            backgroundColor: this.peraGraphService.getBackgroundColorByWarningAndRi(warning, this.latestRi, this.graph.discharged),
            width: '100%',
        };
    }
}
PeraGraphHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-pera-graph-header',
                template: "<div id=\"{{ arrayViewService.chartTitleSubject$.value.returnFunc(this.graph) }}\" class=\"ph-header\">\n    <!-- Match the background color to the warning level-->\n    <div id=\"headerbackground\" class=\"inner\" [ngStyle]=\"style\">&nbsp;</div>\n    <!-- Display the prior warning indicator on the right side of the header -->\n    <div id=\"{{priorWarningIndicatorId}}}\" class=\"inner {{priorWarningIndicator}}\" style=\"width: 100%; background-color: transparent\"></div>\n    <!-- Display the graph title... could be the Patient's Name, the MRN, the VNM, etc-->\n    <div class=\"inner ph-header-title\" style=\"background-color: transparent\">\n      {{ arrayViewService.chartTitleSubject$.value.returnFunc(this.graph) }}\n    </div>\n    <!-- Display the Rothman Index on the right side of the header -->\n    <div class=\"inner ph-header-score\" style=\"background-color: transparent\">\n        {{ this.peraGraphService.getRiScoreToDisplay(this.latestRi) }}\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".inner{position:absolute}.ph-header{color:#fff;width:100%;white-space:nowrap}.ph-header-title{text-shadow:1px 1px 3px #000;font-size:.8em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:table-cell;vertical-align:middle;padding-left:5px;padding-right:5px;padding-top:1px;width:90%}.ph-header-score{font-size:.8em;text-shadow:1px 1px 3px #000;padding-right:5px;width:100%;text-align:right;align-content:right;padding-top:1px}.hide-on-compact{display:none}div{float:left}#headerbackground{height:16%;border-bottom:1px solid #000}.m-warning{width:0;height:0;padding-left:12%;padding-top:12%;overflow:hidden;float:right}.m-warning:after{content:\"\";display:block;width:0;height:0;margin-left:-500px;margin-top:-500px;float:right;border-left:500px solid transparent;border-top:500px solid #f6cc5d}.h-warning{width:0;height:0;padding-left:12%;padding-top:12%;overflow:hidden;float:right}.h-warning:after{content:\"\";display:block;width:0;height:0;margin-left:-500px;margin-top:-500px;float:right;border-left:500px solid transparent;border-top:500px solid #ee834c}.vh-warning{width:0;height:0;padding-left:12%;padding-top:12%;overflow:hidden;float:right}.vh-warning:after{content:\"\";display:block;width:0;height:0;margin-left:-500px;margin-top:-500px;float:right;border-left:500px solid transparent;border-top:500px solid #d51c19}"]
            }] }
];
/** @nocollapse */
PeraGraphHeaderComponent.ctorParameters = () => [
    { type: PeraGraphService },
    { type: WarningService },
    { type: ArrayViewService },
    { type: ChangeDetectorRef }
];
PeraGraphHeaderComponent.propDecorators = {
    graph: [{ type: Input }],
    latestRi: [{ type: Input }],
    priorWarning: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipComponent {
    /**
     * @param {?} dateService
     */
    constructor(dateService) {
        this.dateService = dateService;
    }
    /**
     * @return {?}
     */
    getAdmitDate() {
        if (this.graph && this.graph.timeZone && this.graph.admitDate) {
            return this.dateService.getDateFormat(this.graph.timeZone, this.graph.admitDate, 'MM/DD/YY HH:mm z');
        }
        return '';
    }
    /**
     * @return {?}
     */
    getDischargeDate() {
        if (this.graph && this.graph.timeZone && this.graph.discharged && this.graph.dischargeDate) {
            return this.dateService.getDateFormat(this.graph.timeZone, this.graph.dischargeDate, 'MM/DD/YY HH:mm z');
        }
        return '';
    }
    /**
     * @return {?}
     */
    isDischarged() {
        return (this.graph && this.graph.isDischarged);
    }
}
TooltipComponent.decorators = [
    { type: Component, args: [{
                selector: 'phlib-chart-tooltip',
                template: "<span class=\"patientToolTip\">\n  <b>Patient: </b><span style=\"text-transform: capitalize;\">{{graph?.displayName.toLowerCase()}}</span><br>\n  <b>Facility: </b>{{graph?.facilityId}}<br>\n  <b>Unit Room Bed: </b>{{graph?.unitId}} {{graph?.room}} {{graph?.bed}}<br>\n  <b>DOB: </b>{{graph?.patient?.dob | date:'MM/dd/yy'}}<br>\n  <b>Visit: </b>{{graph?.vnm}}<br>\n  <b>MRN: </b>{{graph?.patient.medicalRecordNumber}}<br>\n  <b>Diagnosis: </b>{{graph?.diagnosis}}<br>\n  <b>Admit Date: </b>{{getAdmitDate()}}<br>\n  <span id=\"dischargeDate\" *ngIf=\"isDischarged()\"><b>Discharge Date: </b>{{getDischargeDate()}}<br></span>\n  <b>Provider: </b>{{ graph?.attendingProvider?.firstName}} {{graph?.attendingProvider?.lastName}}<br>\n  <b>Other Visits with RI Scores: </b>{{graph?.numberVisitsWithValidRI}}<br>\n  <span id=\"dischargeName\"*ngIf=\"isDischarged()\"><b>Discharge Disposition: </b>{{graph?.dischargeDispositionDisplayName}}</span>\n</span>\n",
                styles: [".patientToolTip{font-size:1em}"]
            }] }
];
/** @nocollapse */
TooltipComponent.ctorParameters = () => [
    { type: DateService }
];
TooltipComponent.propDecorators = {
    graph: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ArrayViewModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ArrayViewModule,
            providers: [FilterService, FilterQueryRestService, FilterQueryConfigService]
        };
    }
}
ArrayViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule,
                    HighchartsChartModule,
                    VirtualScrollModule,
                    ResizableModule,
                    NgbModule
                ],
                declarations: [
                    ArrayViewComponent,
                    GroupComponent,
                    GroupHeaderComponent,
                    PeraGraphComponent,
                    ChartComponent,
                    PeraGraphTileComponent,
                    TooltipComponent,
                    PeraGraphHeaderComponent
                ],
                exports: [ArrayViewComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ArrayViewService, ArrayViewConfigService, PeraGraphService, PriorWarningsApiService, PriorWarningsConfigService, ArrayViewComponent, ArrayViewModule, GroupHeaderComponent as b, GroupComponent as a, ChartComponent as e, PeraGraphHeaderComponent as h, PeraGraphTileComponent as f, PeraGraphComponent as c, TooltipService as d, TooltipComponent as g };

//# sourceMappingURL=ng-array-view-library.js.map