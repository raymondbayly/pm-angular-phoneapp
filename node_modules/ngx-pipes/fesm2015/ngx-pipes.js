import { Pipe, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DiffPipe {
    /**
     * @param {?} input
     * @param {...?} args
     * @return {?}
     */
    transform(input, ...args) {
        if (!Array.isArray(input)) {
            return input;
        }
        // tslint:disable-next-line no-bitwise
        return args.reduce((/**
         * @param {?} d
         * @param {?} c
         * @return {?}
         */
        (d, c) => d.filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => !~c.indexOf(e)))), input);
    }
}
DiffPipe.decorators = [
    { type: Pipe, args: [{ name: 'diff' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InitialPipe {
    /**
     * @param {?} input
     * @param {?=} num
     * @return {?}
     */
    transform(input, num = 0) {
        return Array.isArray(input) ? input.slice(0, input.length - num) : input;
    }
}
InitialPipe.decorators = [
    { type: Pipe, args: [{ name: 'initial' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FlattenPipe {
    /**
     * @param {?} input
     * @param {?=} shallow
     * @return {?}
     */
    transform(input, shallow = false) {
        if (!Array.isArray(input)) {
            return input;
        }
        return shallow ? [].concat.apply([], input) : this.flatten(input);
    }
    /**
     * @private
     * @param {?} array
     * @return {?}
     */
    flatten(array) {
        return array.reduce((/**
         * @param {?} arr
         * @param {?} elm
         * @return {?}
         */
        (arr, elm) => {
            if (Array.isArray(elm)) {
                return arr.concat(this.flatten(elm));
            }
            return arr.concat(elm);
        }), []);
    }
}
FlattenPipe.decorators = [
    { type: Pipe, args: [{ name: 'flatten' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionPipe {
    /**
     * @param {?} input
     * @param {...?} args
     * @return {?}
     */
    transform(input, ...args) {
        if (!Array.isArray(input)) {
            return input;
        }
        // tslint:disable-next-line no-bitwise
        return args.reduce((/**
         * @param {?} n
         * @param {?} c
         * @return {?}
         */
        (n, c) => n.filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => !!~c.indexOf(e)))), input);
    }
}
IntersectionPipe.decorators = [
    { type: Pipe, args: [{ name: 'intersection' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isUndefined(value) {
    return typeof value === 'undefined';
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} value
 * @return {?}
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return value !== null && typeof value === 'object';
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumberFinite(value) {
    return isNumber(value) && isFinite(value);
}
/**
 * @param {?} letter
 * @return {?}
 */
function isVowel(letter) {
    /** @type {?} */
    const vowels = ['a', 'e', 'i', 'o', 'u'];
    return vowels.indexOf(letter) !== -1;
}
/**
 * @param {?} text
 * @return {?}
 */
function ucFirst(text) {
    const [part, ...split] = text.split(/\s/g);
    /** @type {?} */
    const ucd = part
        .toLowerCase()
        .split(/(?=['|-])/g)
        .map((/**
     * @param {?} word
     * @return {?}
     */
    (word) => word.indexOf('-') + word.indexOf("'") > -2
        ? word.slice(0, 2).toUpperCase() + word.slice(2)
        : word.slice(0, 1).toUpperCase() + word.slice(1)))
        .join('');
    return [ucd, ...split].join(' ');
}
/**
 * @param {?} num
 * @param {?} precision
 * @return {?}
 */
function applyPrecision(num, precision) {
    if (precision <= 0) {
        return Math.round(num);
    }
    /** @type {?} */
    const tho = Math.pow(10, precision);
    return Math.round(num * tho) / tho;
}
/**
 * @param {?} obj
 * @param {?} map
 * @return {?}
 */
function extractDeepPropertyByMapKey(obj, map) {
    /** @type {?} */
    const keys = map.split('.');
    /** @type {?} */
    const head = keys.shift();
    return keys.reduce((/**
     * @param {?} prop
     * @param {?} key
     * @return {?}
     */
    (prop, key) => {
        return !isUndefined(prop) && !isUndefined(prop[key]) ? prop[key] : undefined;
    }), obj[head || '']);
}
/**
 * @param {?} obj
 * @param {?} map
 * @return {?}
 */
function extractDeepPropertyByParentMapKey(obj, map) {
    /** @type {?} */
    const keys = map.split('.');
    /** @type {?} */
    const tail = keys.pop();
    /** @type {?} */
    const props = extractDeepPropertyByMapKey(obj, keys.join('.'));
    return { props, tail };
}
/**
 * @param {?} obj
 * @param {?} other
 * @return {?}
 */
function getKeysTwoObjects(obj, other) {
    return [...Object.keys(obj), ...Object.keys(other)].filter((/**
     * @param {?} key
     * @param {?} index
     * @param {?} array
     * @return {?}
     */
    (key, index, array) => array.indexOf(key) === index));
}
/**
 * @param {?} obj
 * @param {?} other
 * @return {?}
 */
function isDeepEqual(obj, other) {
    if (!isObject(obj) || !isObject(other)) {
        return obj === other;
    }
    return getKeysTwoObjects(obj, other).every((/**
     * @param {?} key
     * @return {?}
     */
    (key) => {
        if (!isObject(obj[key]) && !isObject(other[key])) {
            return obj[key] === other[key];
        }
        if (!isObject(obj[key]) || !isObject(other[key])) {
            return false;
        }
        return isDeepEqual(obj[key], other[key]);
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ReversePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        if (isString(input)) {
            return input
                .split('')
                .reverse()
                .join('');
        }
        return Array.isArray(input) ? input.slice().reverse() : input;
    }
}
ReversePipe.decorators = [
    { type: Pipe, args: [{ name: 'reverse' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TailPipe {
    /**
     * @param {?} input
     * @param {?=} num
     * @return {?}
     */
    transform(input, num = 0) {
        return Array.isArray(input) ? input.slice(num) : input;
    }
}
TailPipe.decorators = [
    { type: Pipe, args: [{ name: 'tail' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrurthifyPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return Array.isArray(input) ? input.filter((/**
         * @param {?} e
         * @return {?}
         */
        e => !!e)) : input;
    }
}
TrurthifyPipe.decorators = [
    { type: Pipe, args: [{ name: 'truthify' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnionPipe {
    /**
     * @param {?} input
     * @param {?=} args
     * @return {?}
     */
    transform(input, args = []) {
        if (!Array.isArray(input) || !Array.isArray(args)) {
            return input;
        }
        return args.reduce((/**
         * @param {?} newArr
         * @param {?} currArr
         * @return {?}
         */
        (newArr, currArr) => {
            return newArr.concat(currArr.reduce((/**
             * @param {?} noDupArr
             * @param {?} curr
             * @return {?}
             */
            (noDupArr, curr) => {
                // tslint:disable-next-line:no-bitwise
                return !~noDupArr.indexOf(curr) && !~newArr.indexOf(curr) ? noDupArr.concat([curr]) : noDupArr;
            }), []));
        }), input);
    }
}
UnionPipe.decorators = [
    { type: Pipe, args: [{ name: 'union' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UniquePipe {
    /**
     * @param {?} input
     * @param {?=} propertyName
     * @return {?}
     */
    transform(input, propertyName) {
        /** @type {?} */
        const uniques = [];
        return Array.isArray(input)
            ? isUndefined(propertyName)
                ? input.filter((/**
                 * @param {?} e
                 * @param {?} i
                 * @return {?}
                 */
                (e, i) => input.indexOf(e) === i))
                : input.filter((/**
                 * @param {?} e
                 * @param {?} i
                 * @return {?}
                 */
                (e, i) => {
                    /** @type {?} */
                    let value = extractDeepPropertyByMapKey(e, propertyName);
                    value = isObject(value) ? JSON.stringify(value) : value;
                    if (isUndefined(value) || uniques[value]) {
                        return false;
                    }
                    uniques[value] = true;
                    return true;
                }))
            : input;
    }
}
UniquePipe.decorators = [
    { type: Pipe, args: [{ name: 'unique' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WithoutPipe {
    /**
     * @param {?} input
     * @param {?=} args
     * @return {?}
     */
    transform(input, args = []) {
        return Array.isArray(input)
            ? // tslint:disable-next-line:no-bitwise
                input.filter((/**
                 * @param {?} e
                 * @return {?}
                 */
                e => !~args.indexOf(e)))
            : input;
    }
}
WithoutPipe.decorators = [
    { type: Pipe, args: [{ name: 'without' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PluckPipe {
    /**
     * @param {?} input
     * @param {?} map
     * @return {?}
     */
    transform(input, map) {
        if (Array.isArray(input)) {
            return input.map((/**
             * @param {?} e
             * @return {?}
             */
            e => extractDeepPropertyByMapKey(e, map)));
        }
        return isObject(input) ? extractDeepPropertyByMapKey(input, map) : input;
    }
}
PluckPipe.decorators = [
    { type: Pipe, args: [{ name: 'pluck', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShufflePipe {
    // Using a version of the Fisher-Yates shuffle algorithm
    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        if (!Array.isArray(input)) {
            return input;
        }
        /** @type {?} */
        const shuffled = [...input];
        /** @type {?} */
        const n = input.length - 1;
        for (let i = 0; i < n; ++i) {
            /** @type {?} */
            const j = Math.floor(Math.random() * (n - i + 1)) + i;
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}
ShufflePipe.decorators = [
    { type: Pipe, args: [{ name: 'shuffle' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EveryPipe {
    /**
     * @param {?} input
     * @param {?} predicate
     * @return {?}
     */
    transform(input, predicate) {
        return Array.isArray(input) ? input.every(predicate) : false;
    }
}
EveryPipe.decorators = [
    { type: Pipe, args: [{ name: 'every' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SomePipe {
    /**
     * @param {?} input
     * @param {?} predicate
     * @return {?}
     */
    transform(input, predicate) {
        return Array.isArray(input) ? input.some(predicate) : input;
    }
}
SomePipe.decorators = [
    { type: Pipe, args: [{ name: 'some' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SamplePipe {
    /**
     * @param {?} input
     * @param {?=} len
     * @return {?}
     */
    transform(input, len = 1) {
        if (!Array.isArray(input)) {
            return input;
        }
        /** @type {?} */
        let sample = [];
        /** @type {?} */
        const tmp = [...input];
        /** @type {?} */
        const l = len < tmp.length ? len : tmp.length;
        for (let i = 0; i < l; ++i) {
            sample = sample.concat(tmp.splice(Math.floor(Math.random() * tmp.length), 1));
        }
        return sample;
    }
}
SamplePipe.decorators = [
    { type: Pipe, args: [{ name: 'sample' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupByPipe {
    /**
     * @param {?} input
     * @param {?=} discriminator
     * @param {?=} delimiter
     * @return {?}
     */
    transform(input, discriminator = [], delimiter = '|') {
        if (!Array.isArray(input)) {
            return input;
        }
        return this.groupBy(input, discriminator, delimiter);
    }
    /**
     * @private
     * @param {?} list
     * @param {?} discriminator
     * @param {?} delimiter
     * @return {?}
     */
    groupBy(list, discriminator, delimiter) {
        return list.reduce((/**
         * @param {?} acc
         * @param {?} payload
         * @return {?}
         */
        (acc, payload) => {
            /** @type {?} */
            const key = this.extractKeyByDiscriminator(discriminator, payload, delimiter);
            acc[key] = Array.isArray(acc[key]) ? acc[key].concat([payload]) : [payload];
            return acc;
        }), {});
    }
    /**
     * @private
     * @param {?} discriminator
     * @param {?} payload
     * @param {?} delimiter
     * @return {?}
     */
    extractKeyByDiscriminator(discriminator, payload, delimiter) {
        if (isFunction(discriminator)) {
            return ((/** @type {?} */ (discriminator)))(payload);
        }
        if (Array.isArray(discriminator)) {
            return discriminator.map((/**
             * @param {?} k
             * @return {?}
             */
            k => extractDeepPropertyByMapKey(payload, k))).join(delimiter);
        }
        return extractDeepPropertyByMapKey(payload, (/** @type {?} */ (discriminator)));
    }
}
GroupByPipe.decorators = [
    { type: Pipe, args: [{ name: 'groupBy' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable no-bitwise
class FilterByPipe {
    /**
     * @param {?} input
     * @param {?} props
     * @param {?=} search
     * @param {?=} strict
     * @return {?}
     */
    transform(input, props, search = '', strict = false) {
        if (!Array.isArray(input) ||
            (!Array.isArray(search) && !isString(search) && !isNumberFinite(search) && !isBoolean(search))) {
            return input;
        }
        /** @type {?} */
        const terms = String(search)
            .toLowerCase()
            .split(',');
        return input.filter((/**
         * @param {?} obj
         * @return {?}
         */
        obj => {
            return props.some((/**
             * @param {?} prop
             * @return {?}
             */
            prop => {
                return terms.some((/**
                 * @param {?} term
                 * @return {?}
                 */
                term => {
                    /** @type {?} */
                    const value = extractDeepPropertyByMapKey(obj, prop);
                    /* tslint:disable */
                    const { props, tail } = extractDeepPropertyByParentMapKey(obj, prop);
                    if (isUndefined(value) && !isUndefined(props) && Array.isArray(props)) {
                        return props.some((/**
                         * @param {?} parent
                         * @return {?}
                         */
                        parent => {
                            /** @type {?} */
                            const str = String(parent[tail]).toLowerCase();
                            return strict ? str === term : !!~str.indexOf(term);
                        }));
                    }
                    if (isUndefined(value)) {
                        return false;
                    }
                    /** @type {?} */
                    const strValue = String(value).toLowerCase();
                    return strict ? term === strValue : !!~strValue.indexOf(term);
                }));
            }));
        }));
    }
}
FilterByPipe.decorators = [
    { type: Pipe, args: [{ name: 'filterBy' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrderByPipe {
    /**
     * @param {?} input
     * @param {?=} config
     * @return {?}
     */
    transform(input, config) {
        if (!Array.isArray(input)) {
            return input;
        }
        /** @type {?} */
        const out = [...input];
        // sort by multiple properties
        if (Array.isArray(config)) {
            return out.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                /** @type {?} */
                const l = config.length;
                for (let i = 0; i < l; ++i) {
                    const [prop, asc] = OrderByPipe.extractFromConfig(config[i]);
                    /** @type {?} */
                    const pos = OrderByPipe.orderCompare(prop, asc, a, b);
                    if (pos !== 0) {
                        return pos;
                    }
                }
                return 0;
            }));
        }
        // sort by a single property value
        if (isString(config)) {
            const [prop, asc, sign] = OrderByPipe.extractFromConfig(config);
            if (config.length === 1) {
                // tslint:disable-next-line:switch-default
                switch (sign) {
                    case '+':
                        return out.sort(OrderByPipe.simpleSort.bind(this));
                    case '-':
                        return out.sort(OrderByPipe.simpleSort.bind(this)).reverse();
                }
            }
            return out.sort(OrderByPipe.orderCompare.bind(this, prop, asc));
        }
        // default sort by value
        return out.sort(OrderByPipe.simpleSort.bind(this));
    }
    /**
     * @private
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static simpleSort(a, b) {
        return isString(a) && isString(b) ? a.toLowerCase().localeCompare(b.toLowerCase()) : a - b;
    }
    /**
     * @private
     * @param {?} prop
     * @param {?} asc
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static orderCompare(prop, asc, a, b) {
        /** @type {?} */
        const first = extractDeepPropertyByMapKey(a, prop);
        /** @type {?} */
        const second = extractDeepPropertyByMapKey(b, prop);
        if (first === second) {
            return 0;
        }
        if (isUndefined(first) || first === '') {
            return 1;
        }
        if (isUndefined(second) || second === '') {
            return -1;
        }
        if (isString(first) && isString(second)) {
            /** @type {?} */
            const pos = first.toLowerCase().localeCompare(second.toLowerCase());
            return asc ? pos : -pos;
        }
        return asc ? first - second : second - first;
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    static extractFromConfig(config) {
        /** @type {?} */
        const sign = config.substr(0, 1);
        /** @type {?} */
        const prop = config.replace(/^[-+]/, '');
        /** @type {?} */
        const asc = sign !== '-';
        return [prop, asc, sign];
    }
}
OrderByPipe.decorators = [
    { type: Pipe, args: [{ name: 'orderBy' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable use-pipe-transform-interface
class GroupByImpurePipe extends GroupByPipe {
}
GroupByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'groupByImpure', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable use-pipe-transform-interface
class FilterByImpurePipe extends FilterByPipe {
}
FilterByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'filterByImpure', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable use-pipe-transform-interface
class OrderByImpurePipe extends OrderByPipe {
}
OrderByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'orderByImpure', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RangePipe {
    /**
     * @param {?=} start
     * @param {?=} count
     * @param {?=} step
     * @return {?}
     */
    transform(start = 1, count = 0, step = 1) {
        return Array(count)
            .fill('')
            .map((/**
         * @param {?} v
         * @param {?} i
         * @return {?}
         */
        (v, i) => step * i + start));
    }
}
RangePipe.decorators = [
    { type: Pipe, args: [{ name: 'range' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ARRAY_PIPES = [
    DiffPipe,
    FlattenPipe,
    InitialPipe,
    IntersectionPipe,
    ReversePipe,
    TailPipe,
    TrurthifyPipe,
    UnionPipe,
    UniquePipe,
    WithoutPipe,
    PluckPipe,
    ShufflePipe,
    EveryPipe,
    SomePipe,
    SamplePipe,
    GroupByPipe,
    GroupByImpurePipe,
    FilterByPipe,
    FilterByImpurePipe,
    OrderByPipe,
    OrderByImpurePipe,
    RangePipe,
];
class NgArrayPipesModule {
}
NgArrayPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: ARRAY_PIPES,
                imports: [],
                exports: ARRAY_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeysPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj);
    }
}
KeysPipe.decorators = [
    { type: Pipe, args: [{ name: 'keys' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValuesPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).map((/**
         * @param {?} k
         * @return {?}
         */
        k => obj[k]));
    }
}
ValuesPipe.decorators = [
    { type: Pipe, args: [{ name: 'values' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PairsPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).map((/**
         * @param {?} k
         * @return {?}
         */
        k => [k, obj[k]]));
    }
}
PairsPipe.decorators = [
    { type: Pipe, args: [{ name: 'pairs' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickPipe {
    /**
     * @param {?} obj
     * @param {...?} args
     * @return {?}
     */
    transform(obj, ...args) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return args.reduce((/**
         * @param {?} o
         * @param {?} k
         * @return {?}
         */
        (o, k) => {
            return Object.assign(o, { [k]: obj[k] });
        }), {});
    }
}
PickPipe.decorators = [
    { type: Pipe, args: [{ name: 'pick' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OmitPipe {
    /**
     * @param {?} obj
     * @param {...?} args
     * @return {?}
     */
    transform(obj, ...args) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return (Object.keys(obj)
            // tslint:disable-next-line:no-bitwise
            .filter((/**
         * @param {?} k
         * @return {?}
         */
        k => !~args.indexOf(k)))
            .reduce((/**
         * @param {?} o
         * @param {?} k
         * @return {?}
         */
        (o, k) => {
            return Object.assign(o, { [k]: obj[k] });
        }), {}));
    }
}
OmitPipe.decorators = [
    { type: Pipe, args: [{ name: 'omit' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InvertPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).reduce((/**
         * @param {?} o
         * @param {?} k
         * @return {?}
         */
        (o, k) => {
            return Object.assign(o, { [obj[k]]: k });
        }), {});
    }
}
InvertPipe.decorators = [
    { type: Pipe, args: [{ name: 'invert' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InvertByPipe {
    /**
     * @param {?} obj
     * @param {?=} cb
     * @return {?}
     */
    transform(obj, cb) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).reduce((/**
         * @param {?} o
         * @param {?} k
         * @return {?}
         */
        (o, k) => {
            /** @type {?} */
            const key = cb ? cb(obj[k]) : obj[k];
            return Array.isArray(o[key]) ? (o[key].push(k), o) : Object.assign(o, { [key]: [k] });
        }), {});
    }
}
InvertByPipe.decorators = [
    { type: Pipe, args: [{ name: 'invertBy' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DiffObjPipe {
    /**
     * @param {?} obj
     * @param {?=} original
     * @return {?}
     */
    transform(obj, original = {}) {
        if (Array.isArray(obj) || Array.isArray(original) || !isObject(obj) || !isObject(original)) {
            return {};
        }
        return getKeysTwoObjects(obj, original).reduce((/**
         * @param {?} diff
         * @param {?} key
         * @return {?}
         */
        (diff, key) => {
            if (!isDeepEqual(original[key], obj[key])) {
                diff[key] = obj[key];
            }
            return diff;
        }), {});
    }
}
DiffObjPipe.decorators = [
    { type: Pipe, args: [{ name: 'diffObj' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OBJECT_PIPES = [KeysPipe, ValuesPipe, PairsPipe, PickPipe, InvertPipe, InvertByPipe, OmitPipe, DiffObjPipe];
class NgObjectPipesModule {
}
NgObjectPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: OBJECT_PIPES,
                imports: [],
                exports: OBJECT_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Takes a string and returns the string prepended by 'a' or 'an'.
 * Uses both naive and holdout-list approaches.
 * @constructor
 * @param {string} stringEntity - Entity to prepend 'a' or 'an' to.
 */
class AorAnPipe {
    constructor() {
        this.irregularMap = {
            herb: 'an',
            honor: 'an',
            honorable: 'an',
            hour: 'an',
            mba: 'an',
            msc: 'an',
            'm.sc.': 'an',
            unicorn: 'a',
        };
    }
    /**
     * @param {?} stringEntity
     * @return {?}
     */
    transform(stringEntity) {
        if (!stringEntity || stringEntity === '') {
            return '';
        }
        else {
            /** @type {?} */
            const firstWord = stringEntity.trim().split(' ')[0];
            if (this.irregularMap[firstWord.toLocaleLowerCase()]) {
                return `${this.irregularMap[firstWord.toLocaleLowerCase()]} ${stringEntity}`;
            }
            else {
                return isVowel(stringEntity[0]) ? `an ${stringEntity}` : `a ${stringEntity}`;
            }
        }
    }
}
AorAnPipe.decorators = [
    { type: Pipe, args: [{
                name: 'aOrAn',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UcWordsPipe {
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        if (isString(text)) {
            return text
                .split(' ')
                .map((/**
             * @param {?} sub
             * @return {?}
             */
            (sub) => ucFirst(sub)))
                .join(' ');
        }
        return text;
    }
}
UcWordsPipe.decorators = [
    { type: Pipe, args: [{ name: 'ucwords' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LeftTrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text) ? text.replace(new RegExp(`^[${chars}]+`), '') : text;
    }
}
LeftTrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'ltrim' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RepeatPipe {
    /**
     * @param {?} str
     * @param {?=} n
     * @param {?=} separator
     * @return {?}
     */
    transform(str, n = 1, separator = '') {
        if (n <= 0) {
            throw new RangeError();
        }
        return n === 1 ? str : this.repeat(str, n - 1, separator);
    }
    /**
     * @private
     * @param {?} str
     * @param {?} n
     * @param {?} separator
     * @return {?}
     */
    repeat(str, n, separator) {
        return isString(str) ? (n === 0 ? str : str + separator + this.repeat(str, n - 1, separator)) : str;
    }
}
RepeatPipe.decorators = [
    { type: Pipe, args: [{ name: 'repeat' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RightTrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text) ? text.replace(new RegExp(`[${chars}]+$`), '') : text;
    }
}
RightTrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'rtrim' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScanPipe {
    /**
     * @param {?} text
     * @param {?=} args
     * @return {?}
     */
    transform(text, args = []) {
        return isString(text)
            ? text.replace(/\{(\d+)}/g, (/**
             * @param {?} match
             * @param {?} index
             * @return {?}
             */
            (match, index) => (!isUndefined(args[index]) ? args[index] : match)))
            : text;
    }
}
ScanPipe.decorators = [
    { type: Pipe, args: [{ name: 'scan' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShortenPipe {
    /**
     * @param {?} text
     * @param {?=} length
     * @param {?=} suffix
     * @param {?=} wordBreak
     * @return {?}
     */
    transform(text, length = 0, suffix = '', wordBreak = true) {
        if (!isString(text)) {
            return text;
        }
        if (text.length > length) {
            if (wordBreak) {
                return text.slice(0, length) + suffix;
            }
            // tslint:disable-next-line:no-bitwise
            if (!!~text.indexOf(' ', length)) {
                return text.slice(0, text.indexOf(' ', length)) + suffix;
            }
        }
        return text;
    }
}
ShortenPipe.decorators = [
    { type: Pipe, args: [{ name: 'shorten' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StripTagsPipe {
    /**
     * @param {?} text
     * @param {...?} allowedTags
     * @return {?}
     */
    transform(text, ...allowedTags) {
        return allowedTags.length > 0
            ? text.replace(new RegExp(`<(?!\/?(${allowedTags.join('|')})\s*\/?)[^>]+>`, 'g'), '')
            : text.replace(/<(?:.|\s)*?>/g, '');
    }
}
StripTagsPipe.decorators = [
    { type: Pipe, args: [{ name: 'stripTags' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text) ? text.replace(new RegExp(`^[${chars}]+|[${chars}]+$`, 'g'), '') : text;
    }
}
TrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'trim' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UcFirstPipe {
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        return isString(text) ? ucFirst(text) : text;
    }
}
UcFirstPipe.decorators = [
    { type: Pipe, args: [{ name: 'ucfirst' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SlugifyPipe {
    /**
     * @param {?} str
     * @return {?}
     */
    transform(str) {
        return isString(str)
            ? str
                .toLowerCase()
                .trim()
                .replace(/[^\w\-]+/g, ' ')
                .replace(/\s+/g, '-')
            : str;
    }
}
SlugifyPipe.decorators = [
    { type: Pipe, args: [{ name: 'slugify' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CamelizePipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        if (!isString(text)) {
            return text;
        }
        return text
            .toLowerCase()
            .split(/[-_\s]/g)
            .filter((/**
         * @param {?} v
         * @return {?}
         */
        (v) => !!v))
            .map((/**
         * @param {?} word
         * @param {?} key
         * @return {?}
         */
        (word, key) => {
            return !key ? word : word.slice(0, 1).toUpperCase() + word.slice(1);
        }))
            .join('');
    }
}
CamelizePipe.decorators = [
    { type: Pipe, args: [{ name: 'camelize' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LatinisePipe {
    constructor() {
        // Source: http://semplicewebsites.com/removing-accents-javascript
        // tslint:disable-next-line whitespace max-line-length object-literal-key-quotes
        this.latinMap = {
            Á: 'A',
            Ă: 'A',
            Ắ: 'A',
            Ặ: 'A',
            Ằ: 'A',
            Ẳ: 'A',
            Ẵ: 'A',
            Ǎ: 'A',
            Â: 'A',
            Ấ: 'A',
            Ậ: 'A',
            Ầ: 'A',
            Ẩ: 'A',
            Ẫ: 'A',
            Ä: 'A',
            Ǟ: 'A',
            Ȧ: 'A',
            Ǡ: 'A',
            Ạ: 'A',
            Ȁ: 'A',
            À: 'A',
            Ả: 'A',
            Ȃ: 'A',
            Ā: 'A',
            Ą: 'A',
            Å: 'A',
            Ǻ: 'A',
            Ḁ: 'A',
            Ⱥ: 'A',
            Ã: 'A',
            Ꜳ: 'AA',
            Æ: 'AE',
            Ǽ: 'AE',
            Ǣ: 'AE',
            Ꜵ: 'AO',
            Ꜷ: 'AU',
            Ꜹ: 'AV',
            Ꜻ: 'AV',
            Ꜽ: 'AY',
            Ḃ: 'B',
            Ḅ: 'B',
            Ɓ: 'B',
            Ḇ: 'B',
            Ƀ: 'B',
            Ƃ: 'B',
            Ć: 'C',
            Č: 'C',
            Ç: 'C',
            Ḉ: 'C',
            Ĉ: 'C',
            Ċ: 'C',
            Ƈ: 'C',
            Ȼ: 'C',
            Ď: 'D',
            Ḑ: 'D',
            Ḓ: 'D',
            Ḋ: 'D',
            Ḍ: 'D',
            Ɗ: 'D',
            Ḏ: 'D',
            ǲ: 'D',
            ǅ: 'D',
            Đ: 'D',
            Ƌ: 'D',
            Ǳ: 'DZ',
            Ǆ: 'DZ',
            É: 'E',
            Ĕ: 'E',
            Ě: 'E',
            Ȩ: 'E',
            Ḝ: 'E',
            Ê: 'E',
            Ế: 'E',
            Ệ: 'E',
            Ề: 'E',
            Ể: 'E',
            Ễ: 'E',
            Ḙ: 'E',
            Ë: 'E',
            Ė: 'E',
            Ẹ: 'E',
            Ȅ: 'E',
            È: 'E',
            Ẻ: 'E',
            Ȇ: 'E',
            Ē: 'E',
            Ḗ: 'E',
            Ḕ: 'E',
            Ę: 'E',
            Ɇ: 'E',
            Ẽ: 'E',
            Ḛ: 'E',
            Ꝫ: 'ET',
            Ḟ: 'F',
            Ƒ: 'F',
            Ǵ: 'G',
            Ğ: 'G',
            Ǧ: 'G',
            Ģ: 'G',
            Ĝ: 'G',
            Ġ: 'G',
            Ɠ: 'G',
            Ḡ: 'G',
            Ǥ: 'G',
            Ḫ: 'H',
            Ȟ: 'H',
            Ḩ: 'H',
            Ĥ: 'H',
            Ⱨ: 'H',
            Ḧ: 'H',
            Ḣ: 'H',
            Ḥ: 'H',
            Ħ: 'H',
            Í: 'I',
            Ĭ: 'I',
            Ǐ: 'I',
            Î: 'I',
            Ï: 'I',
            Ḯ: 'I',
            İ: 'I',
            Ị: 'I',
            Ȉ: 'I',
            Ì: 'I',
            Ỉ: 'I',
            Ȋ: 'I',
            Ī: 'I',
            Į: 'I',
            Ɨ: 'I',
            Ĩ: 'I',
            Ḭ: 'I',
            Ꝺ: 'D',
            Ꝼ: 'F',
            Ᵹ: 'G',
            Ꞃ: 'R',
            Ꞅ: 'S',
            Ꞇ: 'T',
            Ꝭ: 'IS',
            Ĵ: 'J',
            Ɉ: 'J',
            Ḱ: 'K',
            Ǩ: 'K',
            Ķ: 'K',
            Ⱪ: 'K',
            Ꝃ: 'K',
            Ḳ: 'K',
            Ƙ: 'K',
            Ḵ: 'K',
            Ꝁ: 'K',
            Ꝅ: 'K',
            Ĺ: 'L',
            Ƚ: 'L',
            Ľ: 'L',
            Ļ: 'L',
            Ḽ: 'L',
            Ḷ: 'L',
            Ḹ: 'L',
            Ⱡ: 'L',
            Ꝉ: 'L',
            Ḻ: 'L',
            Ŀ: 'L',
            Ɫ: 'L',
            ǈ: 'L',
            Ł: 'L',
            Ǉ: 'LJ',
            Ḿ: 'M',
            Ṁ: 'M',
            Ṃ: 'M',
            Ɱ: 'M',
            Ń: 'N',
            Ň: 'N',
            Ņ: 'N',
            Ṋ: 'N',
            Ṅ: 'N',
            Ṇ: 'N',
            Ǹ: 'N',
            Ɲ: 'N',
            Ṉ: 'N',
            Ƞ: 'N',
            ǋ: 'N',
            Ñ: 'N',
            Ǌ: 'NJ',
            Ó: 'O',
            Ŏ: 'O',
            Ǒ: 'O',
            Ô: 'O',
            Ố: 'O',
            Ộ: 'O',
            Ồ: 'O',
            Ổ: 'O',
            Ỗ: 'O',
            Ö: 'O',
            Ȫ: 'O',
            Ȯ: 'O',
            Ȱ: 'O',
            Ọ: 'O',
            Ő: 'O',
            Ȍ: 'O',
            Ò: 'O',
            Ỏ: 'O',
            Ơ: 'O',
            Ớ: 'O',
            Ợ: 'O',
            Ờ: 'O',
            Ở: 'O',
            Ỡ: 'O',
            Ȏ: 'O',
            Ꝋ: 'O',
            Ꝍ: 'O',
            Ō: 'O',
            Ṓ: 'O',
            Ṑ: 'O',
            Ɵ: 'O',
            Ǫ: 'O',
            Ǭ: 'O',
            Ø: 'O',
            Ǿ: 'O',
            Õ: 'O',
            Ṍ: 'O',
            Ṏ: 'O',
            Ȭ: 'O',
            Ƣ: 'OI',
            Ꝏ: 'OO',
            Ɛ: 'E',
            Ɔ: 'O',
            Ȣ: 'OU',
            Ṕ: 'P',
            Ṗ: 'P',
            Ꝓ: 'P',
            Ƥ: 'P',
            Ꝕ: 'P',
            Ᵽ: 'P',
            Ꝑ: 'P',
            Ꝙ: 'Q',
            Ꝗ: 'Q',
            Ŕ: 'R',
            Ř: 'R',
            Ŗ: 'R',
            Ṙ: 'R',
            Ṛ: 'R',
            Ṝ: 'R',
            Ȑ: 'R',
            Ȓ: 'R',
            Ṟ: 'R',
            Ɍ: 'R',
            Ɽ: 'R',
            Ꜿ: 'C',
            Ǝ: 'E',
            Ś: 'S',
            Ṥ: 'S',
            Š: 'S',
            Ṧ: 'S',
            Ş: 'S',
            Ŝ: 'S',
            Ș: 'S',
            Ṡ: 'S',
            Ṣ: 'S',
            Ṩ: 'S',
            ẞ: 'SS',
            Ť: 'T',
            Ţ: 'T',
            Ṱ: 'T',
            Ț: 'T',
            Ⱦ: 'T',
            Ṫ: 'T',
            Ṭ: 'T',
            Ƭ: 'T',
            Ṯ: 'T',
            Ʈ: 'T',
            Ŧ: 'T',
            Ɐ: 'A',
            Ꞁ: 'L',
            Ɯ: 'M',
            Ʌ: 'V',
            Ꜩ: 'TZ',
            Ú: 'U',
            Ŭ: 'U',
            Ǔ: 'U',
            Û: 'U',
            Ṷ: 'U',
            Ü: 'U',
            Ǘ: 'U',
            Ǚ: 'U',
            Ǜ: 'U',
            Ǖ: 'U',
            Ṳ: 'U',
            Ụ: 'U',
            Ű: 'U',
            Ȕ: 'U',
            Ù: 'U',
            Ủ: 'U',
            Ư: 'U',
            Ứ: 'U',
            Ự: 'U',
            Ừ: 'U',
            Ử: 'U',
            Ữ: 'U',
            Ȗ: 'U',
            Ū: 'U',
            Ṻ: 'U',
            Ų: 'U',
            Ů: 'U',
            Ũ: 'U',
            Ṹ: 'U',
            Ṵ: 'U',
            Ꝟ: 'V',
            Ṿ: 'V',
            Ʋ: 'V',
            Ṽ: 'V',
            Ꝡ: 'VY',
            Ẃ: 'W',
            Ŵ: 'W',
            Ẅ: 'W',
            Ẇ: 'W',
            Ẉ: 'W',
            Ẁ: 'W',
            Ⱳ: 'W',
            Ẍ: 'X',
            Ẋ: 'X',
            Ý: 'Y',
            Ŷ: 'Y',
            Ÿ: 'Y',
            Ẏ: 'Y',
            Ỵ: 'Y',
            Ỳ: 'Y',
            Ƴ: 'Y',
            Ỷ: 'Y',
            Ỿ: 'Y',
            Ȳ: 'Y',
            Ɏ: 'Y',
            Ỹ: 'Y',
            Ź: 'Z',
            Ž: 'Z',
            Ẑ: 'Z',
            Ⱬ: 'Z',
            Ż: 'Z',
            Ẓ: 'Z',
            Ȥ: 'Z',
            Ẕ: 'Z',
            Ƶ: 'Z',
            Ĳ: 'IJ',
            Œ: 'OE',
            ᴀ: 'A',
            ᴁ: 'AE',
            ʙ: 'B',
            ᴃ: 'B',
            ᴄ: 'C',
            ᴅ: 'D',
            ᴇ: 'E',
            ꜰ: 'F',
            ɢ: 'G',
            ʛ: 'G',
            ʜ: 'H',
            ɪ: 'I',
            ʁ: 'R',
            ᴊ: 'J',
            ᴋ: 'K',
            ʟ: 'L',
            ᴌ: 'L',
            ᴍ: 'M',
            ɴ: 'N',
            ᴏ: 'O',
            ɶ: 'OE',
            ᴐ: 'O',
            ᴕ: 'OU',
            ᴘ: 'P',
            ʀ: 'R',
            ᴎ: 'N',
            ᴙ: 'R',
            ꜱ: 'S',
            ᴛ: 'T',
            ⱻ: 'E',
            ᴚ: 'R',
            ᴜ: 'U',
            ᴠ: 'V',
            ᴡ: 'W',
            ʏ: 'Y',
            ᴢ: 'Z',
            á: 'a',
            ă: 'a',
            ắ: 'a',
            ặ: 'a',
            ằ: 'a',
            ẳ: 'a',
            ẵ: 'a',
            ǎ: 'a',
            â: 'a',
            ấ: 'a',
            ậ: 'a',
            ầ: 'a',
            ẩ: 'a',
            ẫ: 'a',
            ä: 'a',
            ǟ: 'a',
            ȧ: 'a',
            ǡ: 'a',
            ạ: 'a',
            ȁ: 'a',
            à: 'a',
            ả: 'a',
            ȃ: 'a',
            ā: 'a',
            ą: 'a',
            ᶏ: 'a',
            ẚ: 'a',
            å: 'a',
            ǻ: 'a',
            ḁ: 'a',
            ⱥ: 'a',
            ã: 'a',
            ꜳ: 'aa',
            æ: 'ae',
            ǽ: 'ae',
            ǣ: 'ae',
            ꜵ: 'ao',
            ꜷ: 'au',
            ꜹ: 'av',
            ꜻ: 'av',
            ꜽ: 'ay',
            ḃ: 'b',
            ḅ: 'b',
            ɓ: 'b',
            ḇ: 'b',
            ᵬ: 'b',
            ᶀ: 'b',
            ƀ: 'b',
            ƃ: 'b',
            ɵ: 'o',
            ć: 'c',
            č: 'c',
            ç: 'c',
            ḉ: 'c',
            ĉ: 'c',
            ɕ: 'c',
            ċ: 'c',
            ƈ: 'c',
            ȼ: 'c',
            ď: 'd',
            ḑ: 'd',
            ḓ: 'd',
            ȡ: 'd',
            ḋ: 'd',
            ḍ: 'd',
            ɗ: 'd',
            ᶑ: 'd',
            ḏ: 'd',
            ᵭ: 'd',
            ᶁ: 'd',
            đ: 'd',
            ɖ: 'd',
            ƌ: 'd',
            ı: 'i',
            ȷ: 'j',
            ɟ: 'j',
            ʄ: 'j',
            ǳ: 'dz',
            ǆ: 'dz',
            é: 'e',
            ĕ: 'e',
            ě: 'e',
            ȩ: 'e',
            ḝ: 'e',
            ê: 'e',
            ế: 'e',
            ệ: 'e',
            ề: 'e',
            ể: 'e',
            ễ: 'e',
            ḙ: 'e',
            ë: 'e',
            ė: 'e',
            ẹ: 'e',
            ȅ: 'e',
            è: 'e',
            ẻ: 'e',
            ȇ: 'e',
            ē: 'e',
            ḗ: 'e',
            ḕ: 'e',
            ⱸ: 'e',
            ę: 'e',
            ᶒ: 'e',
            ɇ: 'e',
            ẽ: 'e',
            ḛ: 'e',
            ꝫ: 'et',
            ḟ: 'f',
            ƒ: 'f',
            ᵮ: 'f',
            ᶂ: 'f',
            ǵ: 'g',
            ğ: 'g',
            ǧ: 'g',
            ģ: 'g',
            ĝ: 'g',
            ġ: 'g',
            ɠ: 'g',
            ḡ: 'g',
            ᶃ: 'g',
            ǥ: 'g',
            ḫ: 'h',
            ȟ: 'h',
            ḩ: 'h',
            ĥ: 'h',
            ⱨ: 'h',
            ḧ: 'h',
            ḣ: 'h',
            ḥ: 'h',
            ɦ: 'h',
            ẖ: 'h',
            ħ: 'h',
            ƕ: 'hv',
            í: 'i',
            ĭ: 'i',
            ǐ: 'i',
            î: 'i',
            ï: 'i',
            ḯ: 'i',
            ị: 'i',
            ȉ: 'i',
            ì: 'i',
            ỉ: 'i',
            ȋ: 'i',
            ī: 'i',
            į: 'i',
            ᶖ: 'i',
            ɨ: 'i',
            ĩ: 'i',
            ḭ: 'i',
            ꝺ: 'd',
            ꝼ: 'f',
            ᵹ: 'g',
            ꞃ: 'r',
            ꞅ: 's',
            ꞇ: 't',
            ꝭ: 'is',
            ǰ: 'j',
            ĵ: 'j',
            ʝ: 'j',
            ɉ: 'j',
            ḱ: 'k',
            ǩ: 'k',
            ķ: 'k',
            ⱪ: 'k',
            ꝃ: 'k',
            ḳ: 'k',
            ƙ: 'k',
            ḵ: 'k',
            ᶄ: 'k',
            ꝁ: 'k',
            ꝅ: 'k',
            ĺ: 'l',
            ƚ: 'l',
            ɬ: 'l',
            ľ: 'l',
            ļ: 'l',
            ḽ: 'l',
            ȴ: 'l',
            ḷ: 'l',
            ḹ: 'l',
            ⱡ: 'l',
            ꝉ: 'l',
            ḻ: 'l',
            ŀ: 'l',
            ɫ: 'l',
            ᶅ: 'l',
            ɭ: 'l',
            ł: 'l',
            ǉ: 'lj',
            ſ: 's',
            ẜ: 's',
            ẛ: 's',
            ẝ: 's',
            ḿ: 'm',
            ṁ: 'm',
            ṃ: 'm',
            ɱ: 'm',
            ᵯ: 'm',
            ᶆ: 'm',
            ń: 'n',
            ň: 'n',
            ņ: 'n',
            ṋ: 'n',
            ȵ: 'n',
            ṅ: 'n',
            ṇ: 'n',
            ǹ: 'n',
            ɲ: 'n',
            ṉ: 'n',
            ƞ: 'n',
            ᵰ: 'n',
            ᶇ: 'n',
            ɳ: 'n',
            ñ: 'n',
            ǌ: 'nj',
            ó: 'o',
            ŏ: 'o',
            ǒ: 'o',
            ô: 'o',
            ố: 'o',
            ộ: 'o',
            ồ: 'o',
            ổ: 'o',
            ỗ: 'o',
            ö: 'o',
            ȫ: 'o',
            ȯ: 'o',
            ȱ: 'o',
            ọ: 'o',
            ő: 'o',
            ȍ: 'o',
            ò: 'o',
            ỏ: 'o',
            ơ: 'o',
            ớ: 'o',
            ợ: 'o',
            ờ: 'o',
            ở: 'o',
            ỡ: 'o',
            ȏ: 'o',
            ꝋ: 'o',
            ꝍ: 'o',
            ⱺ: 'o',
            ō: 'o',
            ṓ: 'o',
            ṑ: 'o',
            ǫ: 'o',
            ǭ: 'o',
            ø: 'o',
            ǿ: 'o',
            õ: 'o',
            ṍ: 'o',
            ṏ: 'o',
            ȭ: 'o',
            ƣ: 'oi',
            ꝏ: 'oo',
            ɛ: 'e',
            ᶓ: 'e',
            ɔ: 'o',
            ᶗ: 'o',
            ȣ: 'ou',
            ṕ: 'p',
            ṗ: 'p',
            ꝓ: 'p',
            ƥ: 'p',
            ᵱ: 'p',
            ᶈ: 'p',
            ꝕ: 'p',
            ᵽ: 'p',
            ꝑ: 'p',
            ꝙ: 'q',
            ʠ: 'q',
            ɋ: 'q',
            ꝗ: 'q',
            ŕ: 'r',
            ř: 'r',
            ŗ: 'r',
            ṙ: 'r',
            ṛ: 'r',
            ṝ: 'r',
            ȑ: 'r',
            ɾ: 'r',
            ᵳ: 'r',
            ȓ: 'r',
            ṟ: 'r',
            ɼ: 'r',
            ᵲ: 'r',
            ᶉ: 'r',
            ɍ: 'r',
            ɽ: 'r',
            ↄ: 'c',
            ꜿ: 'c',
            ɘ: 'e',
            ɿ: 'r',
            ś: 's',
            ṥ: 's',
            š: 's',
            ṧ: 's',
            ş: 's',
            ŝ: 's',
            ș: 's',
            ṡ: 's',
            ṣ: 's',
            ṩ: 's',
            ʂ: 's',
            ᵴ: 's',
            ᶊ: 's',
            ȿ: 's',
            ɡ: 'g',
            ß: 'ss',
            ᴑ: 'o',
            ᴓ: 'o',
            ᴝ: 'u',
            ť: 't',
            ţ: 't',
            ṱ: 't',
            ț: 't',
            ȶ: 't',
            ẗ: 't',
            ⱦ: 't',
            ṫ: 't',
            ṭ: 't',
            ƭ: 't',
            ṯ: 't',
            ᵵ: 't',
            ƫ: 't',
            ʈ: 't',
            ŧ: 't',
            ᵺ: 'th',
            ɐ: 'a',
            ᴂ: 'ae',
            ǝ: 'e',
            ᵷ: 'g',
            ɥ: 'h',
            ʮ: 'h',
            ʯ: 'h',
            ᴉ: 'i',
            ʞ: 'k',
            ꞁ: 'l',
            ɯ: 'm',
            ɰ: 'm',
            ᴔ: 'oe',
            ɹ: 'r',
            ɻ: 'r',
            ɺ: 'r',
            ⱹ: 'r',
            ʇ: 't',
            ʌ: 'v',
            ʍ: 'w',
            ʎ: 'y',
            ꜩ: 'tz',
            ú: 'u',
            ŭ: 'u',
            ǔ: 'u',
            û: 'u',
            ṷ: 'u',
            ü: 'u',
            ǘ: 'u',
            ǚ: 'u',
            ǜ: 'u',
            ǖ: 'u',
            ṳ: 'u',
            ụ: 'u',
            ű: 'u',
            ȕ: 'u',
            ù: 'u',
            ủ: 'u',
            ư: 'u',
            ứ: 'u',
            ự: 'u',
            ừ: 'u',
            ử: 'u',
            ữ: 'u',
            ȗ: 'u',
            ū: 'u',
            ṻ: 'u',
            ų: 'u',
            ᶙ: 'u',
            ů: 'u',
            ũ: 'u',
            ṹ: 'u',
            ṵ: 'u',
            ᵫ: 'ue',
            ꝸ: 'um',
            ⱴ: 'v',
            ꝟ: 'v',
            ṿ: 'v',
            ʋ: 'v',
            ᶌ: 'v',
            ⱱ: 'v',
            ṽ: 'v',
            ꝡ: 'vy',
            ẃ: 'w',
            ŵ: 'w',
            ẅ: 'w',
            ẇ: 'w',
            ẉ: 'w',
            ẁ: 'w',
            ⱳ: 'w',
            ẘ: 'w',
            ẍ: 'x',
            ẋ: 'x',
            ᶍ: 'x',
            ý: 'y',
            ŷ: 'y',
            ÿ: 'y',
            ẏ: 'y',
            ỵ: 'y',
            ỳ: 'y',
            ƴ: 'y',
            ỷ: 'y',
            ỿ: 'y',
            ȳ: 'y',
            ẙ: 'y',
            ɏ: 'y',
            ỹ: 'y',
            ź: 'z',
            ž: 'z',
            ẑ: 'z',
            ʑ: 'z',
            ⱬ: 'z',
            ż: 'z',
            ẓ: 'z',
            ȥ: 'z',
            ẕ: 'z',
            ᵶ: 'z',
            ᶎ: 'z',
            ʐ: 'z',
            ƶ: 'z',
            ɀ: 'z',
            ﬀ: 'ff',
            ﬃ: 'ffi',
            ﬄ: 'ffl',
            ﬁ: 'fi',
            ﬂ: 'fl',
            ĳ: 'ij',
            œ: 'oe',
            ﬆ: 'st',
            ₐ: 'a',
            ₑ: 'e',
            ᵢ: 'i',
            ⱼ: 'j',
            ₒ: 'o',
            ᵣ: 'r',
            ᵤ: 'u',
            ᵥ: 'v',
            ₓ: 'x',
        };
    }
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.replace(/[^A-Za-z0-9]/g, (/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                return this.latinMap[key] || key;
            }))
            : text;
    }
}
LatinisePipe.decorators = [
    { type: Pipe, args: [{ name: 'latinise' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LinesPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text) ? text.replace(/\r\n/g, '\n').split('\n') : text;
    }
}
LinesPipe.decorators = [
    { type: Pipe, args: [{ name: 'lines' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnderscorePipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text
                .trim()
                .replace(/\s+/g, '')
                .replace(/[A-Z]/g, (/**
             * @param {?} c
             * @param {?} k
             * @return {?}
             */
            (c, k) => {
                return k ? `_${c.toLowerCase()}` : c.toLowerCase();
            }))
            : text;
    }
}
UnderscorePipe.decorators = [
    { type: Pipe, args: [{ name: 'underscore' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatchPipe {
    /**
     * @param {?} text
     * @param {?} pattern
     * @param {?=} flags
     * @return {?}
     */
    transform(text, pattern, flags) {
        if (!isString(text)) {
            return text;
        }
        return text.match(new RegExp(pattern, flags));
    }
}
MatchPipe.decorators = [
    { type: Pipe, args: [{ name: 'match' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TestPipe {
    /**
     * @param {?} text
     * @param {?} pattern
     * @param {?=} flags
     * @return {?}
     */
    transform(text, pattern, flags) {
        if (!isString(text)) {
            return text;
        }
        return new RegExp(pattern, flags).test(text);
    }
}
TestPipe.decorators = [
    { type: Pipe, args: [{ name: 'test' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LeftPadPipe {
    /**
     * @param {?} str
     * @param {?} length
     * @param {?=} padCharacter
     * @return {?}
     */
    transform(str, length, padCharacter = ' ') {
        if (!isString(str) || str.length >= length) {
            return str;
        }
        while (str.length < length) {
            str = padCharacter + str;
        }
        return str;
    }
}
LeftPadPipe.decorators = [
    { type: Pipe, args: [{ name: 'lpad' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RightPadPipe {
    /**
     * @param {?} str
     * @param {?=} length
     * @param {?=} padCharacter
     * @return {?}
     */
    transform(str, length = 1, padCharacter = ' ') {
        if (!isString(str) || str.length >= length) {
            return str;
        }
        while (str.length < length) {
            str = str + padCharacter;
        }
        return str;
    }
}
RightPadPipe.decorators = [
    { type: Pipe, args: [{ name: 'rpad' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Takes a singular entity string and pluralizes it.
 * Uses both naive and holdout-list approaches.
 * If several words appear in the string, only the last word is pluralized -- this
 * means that if "your story" was passed in, "your stories" would be passed out.
 *
 * @param {string} singularEntity - Entity to pluralize. Pass as a singular ('story' or 'house').
 *          NOTE: The last word is examined. So you can pass in e.g. 'my story'.
 * @param {number} [quantity=0] quantity - How many of the entity are there? If left blank, this will
 *          pluralize the string (e.g. 'story' -> 'stories', 'house' -> 'houses'). If given a value,
 *          this will pluralize appropriately (e.g. ('story', 1) -> 'story', ('story', 2) -> 'stories').
 */
class MakePluralStringPipe {
    constructor() {
        this.irregularMap = {
            addendum: 'addenda',
            alga: 'algae',
            alumna: 'alumnae',
            alumnus: 'alumni',
            analysis: 'analyses',
            antenna: 'antennae',
            appendix: 'appendices',
            aquarium: 'aquaria',
            arch: 'arches',
            axe: 'axes',
            axis: 'axes',
            bacillus: 'bacilli',
            bacterium: 'bacteria',
            basis: 'bases',
            batch: 'batches',
            beach: 'beaches',
            beau: 'beaux',
            bison: 'bison',
            brush: 'brushes',
            buffalo: 'buffaloes',
            bureau: 'bureaus',
            bus: 'busses',
            cactus: 'cacti',
            calf: 'calves',
            chateau: 'chateaux',
            cherry: 'cherries',
            child: 'children',
            church: 'churches',
            circus: 'circuses',
            cod: 'cod',
            corps: 'corps',
            corpus: 'corpora',
            crisis: 'crises',
            criterion: 'criteria',
            curriculum: 'curricula',
            datum: 'data',
            deer: 'deer',
            diagnosis: 'diagnoses',
            die: 'dice',
            domino: 'dominoes',
            dwarf: 'dwarves',
            echo: 'echoes',
            elf: 'elves',
            ellipsis: 'ellipses',
            embargo: 'embargoes',
            emphasis: 'emphases',
            erratum: 'errata',
            fax: 'faxes',
            fireman: 'firemen',
            fish: 'fish',
            flush: 'flushes',
            focus: 'foci',
            foot: 'feet',
            formula: 'formulas',
            fungus: 'fungi',
            genus: 'genera',
            goose: 'geese',
            grafito: 'grafiti',
            half: 'halves',
            hero: 'heroes',
            hoax: 'hoaxes',
            hoof: 'hooves',
            hypothesis: 'hypotheses',
            index: 'indices',
            kiss: 'kisses',
            knife: 'knives',
            leaf: 'leaves',
            life: 'lives',
            loaf: 'loaves',
            louse: 'lice',
            man: 'men',
            mango: 'mangoes',
            matrix: 'matrices',
            means: 'means',
            medium: 'media',
            memorandum: 'memoranda',
            millennium: 'milennia',
            moose: 'moose',
            mosquito: 'mosquitoes',
            motto: 'mottoes',
            mouse: 'mice',
            nebula: 'nebulae',
            neurosis: 'neuroses',
            nucleus: 'nuclei',
            oasis: 'oases',
            octopus: 'octopodes',
            ovum: 'ova',
            ox: 'oxen',
            paralysis: 'paralyses',
            parenthesis: 'parentheses',
            person: 'people',
            phenomenon: 'phenomena',
            plateau: 'plateaux',
            potato: 'potatoes',
            quiz: 'quizzes',
            radius: 'radii',
            reflex: 'reflexes',
            'runner-up': 'runners-up',
            scampo: 'scampi',
            scarf: 'scarves',
            scissors: 'scissors',
            scratch: 'scratches',
            self: 'selves',
            series: 'series',
            sheaf: 'sheaves',
            sheep: 'sheep',
            shelf: 'shelves',
            'son-in-law': 'sons-in-law',
            species: 'species',
            splash: 'splashes',
            stimulus: 'stimuli',
            stitch: 'stitches',
            stratum: 'strata',
            syllabus: 'syllabi',
            symposium: 'symposia',
            synopsis: 'synopses',
            synthesis: 'syntheses',
            tableau: 'tableaux',
            tax: 'taxes',
            that: 'those',
            thesis: 'theses',
            thief: 'thieves',
            this: 'these',
            tomato: 'tomatoes',
            tooth: 'teeth',
            tornado: 'tornadoes',
            torpedo: 'torpedoes',
            vertebra: 'vertebrae',
            veto: 'vetoes',
            vita: 'vitae',
            volcano: 'volcanoes',
            waltz: 'waltzes',
            wash: 'washes',
            watch: 'watches',
            wharf: 'wharves',
            wife: 'wives',
            wolf: 'wolves',
            woman: 'women',
            zero: 'zeroes',
        };
    }
    /**
     * @param {?} singularEntity
     * @param {?=} quantity
     * @return {?}
     */
    transform(singularEntity, quantity = 0) {
        if (!singularEntity || singularEntity === '') {
            return '';
        }
        if (quantity === 1) {
            return singularEntity;
        }
        else {
            /** @type {?} */
            const lastWord = singularEntity.trim().split(' ')[singularEntity.trim().split(' ').length - 1];
            if (this.irregularMap[lastWord.toLocaleLowerCase()]) {
                if (lastWord[0] === lastWord[0].toLocaleUpperCase()) {
                    return singularEntity.replace(lastWord, this.irregularMap[lastWord.toLocaleLowerCase()].replace(this.irregularMap[lastWord.toLocaleLowerCase()][0], this.irregularMap[lastWord.toLocaleLowerCase()][0].toLocaleUpperCase()));
                }
                return singularEntity.replace(lastWord, this.irregularMap[lastWord.toLocaleLowerCase()]);
            }
            else if (lastWord[lastWord.length - 1] === 'y') {
                // Naive approach:
                // consonant+y = word - 'y' +'ies'
                // vowel+y = word + 's'
                return isVowel(lastWord[lastWord.length - 2])
                    ? singularEntity + 's'
                    : singularEntity.replace(lastWord, lastWord.slice(0, -1) + 'ies');
            }
            else if (lastWord[lastWord.length - 1] === 's') {
                return singularEntity + 'es';
            }
            else {
                return singularEntity + 's';
            }
        }
    }
}
MakePluralStringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'makePluralString',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WrapPipe {
    /**
     * @param {?} str
     * @param {?=} prefix
     * @param {?=} suffix
     * @return {?}
     */
    transform(str, prefix = '', suffix = '') {
        if (!isString(str)) {
            return str;
        }
        return (!!prefix && isString(prefix) ? prefix : '') + str + (!!suffix && isString(suffix) ? suffix : '');
    }
}
WrapPipe.decorators = [
    { type: Pipe, args: [{ name: 'wrap' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const STRING_PIPES = [
    AorAnPipe,
    LeftTrimPipe,
    RepeatPipe,
    RightTrimPipe,
    ScanPipe,
    ShortenPipe,
    StripTagsPipe,
    TrimPipe,
    UcFirstPipe,
    UcWordsPipe,
    SlugifyPipe,
    CamelizePipe,
    LatinisePipe,
    LinesPipe,
    UnderscorePipe,
    MatchPipe,
    TestPipe,
    LeftPadPipe,
    RightPadPipe,
    MakePluralStringPipe,
    WrapPipe,
];
class NgStringPipesModule {
}
NgStringPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: STRING_PIPES,
                imports: [],
                exports: STRING_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MaxPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr) ? Math.max(...arr) : arr;
    }
}
MaxPipe.decorators = [
    { type: Pipe, args: [{ name: 'max' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MinPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr) ? Math.min(...arr) : arr;
    }
}
MinPipe.decorators = [
    { type: Pipe, args: [{ name: 'min' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PercentagePipe {
    /**
     * @param {?} num
     * @param {?=} total
     * @param {?=} floor
     * @return {?}
     */
    transform(num, total = 100, floor = false) {
        if (isNaN(num)) {
            return num;
        }
        /** @type {?} */
        const percent = (num * 100) / total;
        return floor ? Math.floor(percent) : percent;
    }
}
PercentagePipe.decorators = [
    { type: Pipe, args: [{ name: 'percentage' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SumPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr) ? arr.reduce((/**
         * @param {?} sum
         * @param {?} curr
         * @return {?}
         */
        (sum, curr) => sum + curr), 0) : arr;
    }
}
SumPipe.decorators = [
    { type: Pipe, args: [{ name: 'sum' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FloorPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        if (precision <= 0) {
            return Math.floor(num);
        }
        /** @type {?} */
        const tho = Math.pow(10, precision);
        return Math.floor(num * tho) / tho;
    }
}
FloorPipe.decorators = [
    { type: Pipe, args: [{ name: 'floor' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoundPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        return applyPrecision(num, precision);
    }
}
RoundPipe.decorators = [
    { type: Pipe, args: [{ name: 'round' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SqrtPipe {
    /**
     * @param {?} num
     * @return {?}
     */
    transform(num) {
        return !isNaN(num) ? Math.sqrt(num) : num;
    }
}
SqrtPipe.decorators = [
    { type: Pipe, args: [{ name: 'sqrt' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PowerPipe {
    /**
     * @param {?} num
     * @param {?=} power
     * @return {?}
     */
    transform(num, power = 2) {
        return !isNaN(num) ? Math.pow(num, power) : num;
    }
}
PowerPipe.decorators = [
    { type: Pipe, args: [{ name: 'pow' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CeilPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        if (precision <= 0) {
            return Math.ceil(num);
        }
        /** @type {?} */
        const tho = Math.pow(10, precision);
        return Math.ceil(num * tho) / tho;
    }
}
CeilPipe.decorators = [
    { type: Pipe, args: [{ name: 'ceil' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DegreesPipe {
    /**
     * @param {?} radians
     * @return {?}
     */
    transform(radians) {
        if (!isNumberFinite(radians)) {
            return NaN;
        }
        return (radians * 180) / Math.PI;
    }
}
DegreesPipe.decorators = [
    { type: Pipe, args: [{ name: 'degrees' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BytesPipe {
    constructor() {
        this.dictionary = [
            { max: 1024, type: 'B' },
            { max: 1048576, type: 'KB' },
            { max: 1073741824, type: 'MB' },
            { max: 1.0995116e12, type: 'GB' },
        ];
    }
    /**
     * @param {?} value
     * @param {?=} precision
     * @return {?}
     */
    transform(value, precision) {
        if (!isNumberFinite(value)) {
            return NaN;
        }
        /** @type {?} */
        const format = this.dictionary.find((/**
         * @param {?} d
         * @return {?}
         */
        d => value < d.max)) || this.dictionary[this.dictionary.length - 1];
        /** @type {?} */
        const calc = value / (format.max / 1024);
        /** @type {?} */
        const num = isUndefined(precision) ? calc : applyPrecision(calc, precision);
        return `${num} ${format.type}`;
    }
}
BytesPipe.decorators = [
    { type: Pipe, args: [{ name: 'bytes' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadiansPipe {
    /**
     * @param {?} degrees
     * @return {?}
     */
    transform(degrees) {
        if (!isNumberFinite(degrees)) {
            return NaN;
        }
        return (degrees * Math.PI) / 180;
    }
}
RadiansPipe.decorators = [
    { type: Pipe, args: [{ name: 'radians' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MATH_PIPES = [
    MaxPipe,
    MinPipe,
    PercentagePipe,
    SumPipe,
    FloorPipe,
    RoundPipe,
    SqrtPipe,
    PowerPipe,
    CeilPipe,
    DegreesPipe,
    BytesPipe,
    RadiansPipe,
];
class NgMathPipesModule {
}
NgMathPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: MATH_PIPES,
                imports: [],
                exports: MATH_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsDefinedPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return !isUndefined(input);
    }
}
IsDefinedPipe.decorators = [
    { type: Pipe, args: [{ name: 'isDefined' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsNullPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return input === null;
    }
}
IsNullPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNull' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsUndefinedPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isUndefined(input);
    }
}
IsUndefinedPipe.decorators = [
    { type: Pipe, args: [{ name: 'isUndefined' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsStringPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isString(input);
    }
}
IsStringPipe.decorators = [
    { type: Pipe, args: [{ name: 'isString' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsFunctionPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isFunction(input);
    }
}
IsFunctionPipe.decorators = [
    { type: Pipe, args: [{ name: 'isFunction' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsNumberPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isNumber(input);
    }
}
IsNumberPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNumber' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsArrayPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return Array.isArray(input);
    }
}
IsArrayPipe.decorators = [
    { type: Pipe, args: [{ name: 'isArray' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsObjectPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isObject(input);
    }
}
IsObjectPipe.decorators = [
    { type: Pipe, args: [{ name: 'isObject' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsGreaterEqualThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input >= other;
    }
}
IsGreaterEqualThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isGreaterEqualThan' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsGreaterThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input > other;
    }
}
IsGreaterThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isGreaterThan' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLessEqualThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input <= other;
    }
}
IsLessEqualThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isLessEqualThan' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsEqualToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        // tslint:disable-next-line:triple-equals
        return input == other;
    }
}
IsEqualToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isEqualTo' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsNotEqualToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        // tslint:disable-next-line:triple-equals
        return input != other;
    }
}
IsNotEqualToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNotEqualTo' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsIdenticalToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input === other;
    }
}
IsIdenticalToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isIdenticalTo' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsNotIdenticalToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input !== other;
    }
}
IsNotIdenticalToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNotIdenticalTo' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IsLessThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input < other;
    }
}
IsLessThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isLessThan' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const BOOLEAN_PIPES = [
    IsDefinedPipe,
    IsNullPipe,
    IsUndefinedPipe,
    IsStringPipe,
    IsFunctionPipe,
    IsNumberPipe,
    IsArrayPipe,
    IsObjectPipe,
    IsGreaterEqualThanPipe,
    IsGreaterThanPipe,
    IsLessEqualThanPipe,
    IsLessEqualThanPipe,
    IsEqualToPipe,
    IsNotEqualToPipe,
    IsIdenticalToPipe,
    IsNotIdenticalToPipe,
    IsLessThanPipe,
];
class NgBooleanPipesModule {
}
NgBooleanPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: BOOLEAN_PIPES,
                imports: [],
                exports: BOOLEAN_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimeAgoPipe {
    /**
     * @param {?} inputDate
     * @return {?}
     */
    transform(inputDate) {
        if (!inputDate || (!inputDate.getTime && !inputDate.toDate)) {
            return 'Invalid date';
        }
        /** @type {?} */
        const past = inputDate.toDate ? inputDate.toDate() : inputDate.getTime();
        /** @type {?} */
        const now = +new Date();
        if (past > now) {
            return 'in the future';
        }
        for (let i = 0, l = TimeAgoPipe.MAPPER.length, ms = now - past, div = TimeAgoPipe.YEAR_MS; i < l; ++i) {
            /** @type {?} */
            const elm = TimeAgoPipe.MAPPER[i];
            /** @type {?} */
            const unit = Math.floor(ms / (div /= elm.div));
            if (unit >= 1) {
                return unit === 1 ? elm.single : `${unit} ${elm.many} ago`;
            }
        }
        return 'just now';
    }
}
TimeAgoPipe.YEAR_MS = 1000 * 60 * 60 * 24 * 7 * 4 * 12;
TimeAgoPipe.MAPPER = [
    { single: 'last year', many: 'years', div: 1 },
    { single: 'last month', many: 'months', div: 12 },
    { single: 'last week', many: 'weeks', div: 4 },
    { single: 'yesterday', many: 'days', div: 7 },
    { single: 'an hour ago', many: 'hours', div: 24 },
    { single: 'just now', many: 'minutes', div: 60 },
];
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{ name: 'timeAgo' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DATE_PIPES = [TimeAgoPipe];
class NgDatePipesModule {
}
NgDatePipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: DATE_PIPES,
                imports: [],
                exports: DATE_PIPES,
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgPipesModule {
}
NgPipesModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    NgArrayPipesModule,
                    NgStringPipesModule,
                    NgMathPipesModule,
                    NgBooleanPipesModule,
                    NgObjectPipesModule,
                    NgDatePipesModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgPipesModule, NgArrayPipesModule, DiffPipe, InitialPipe, FlattenPipe, IntersectionPipe, ReversePipe, TailPipe, TrurthifyPipe, UnionPipe, UniquePipe, WithoutPipe, PluckPipe, ShufflePipe, EveryPipe, SomePipe, SamplePipe, GroupByPipe, FilterByPipe, OrderByPipe, GroupByImpurePipe, FilterByImpurePipe, OrderByImpurePipe, RangePipe, NgObjectPipesModule, KeysPipe, ValuesPipe, PairsPipe, PickPipe, OmitPipe, InvertPipe, InvertByPipe, DiffObjPipe, STRING_PIPES, NgStringPipesModule, AorAnPipe, UcWordsPipe, LeftTrimPipe, RepeatPipe, RightTrimPipe, ScanPipe, ShortenPipe, StripTagsPipe, TrimPipe, UcFirstPipe, SlugifyPipe, CamelizePipe, LatinisePipe, LinesPipe, UnderscorePipe, MatchPipe, TestPipe, LeftPadPipe, RightPadPipe, MakePluralStringPipe, WrapPipe, MATH_PIPES, NgMathPipesModule, MaxPipe, MinPipe, PercentagePipe, SumPipe, FloorPipe, RoundPipe, SqrtPipe, PowerPipe, CeilPipe, DegreesPipe, BytesPipe, BOOLEAN_PIPES, NgBooleanPipesModule, IsDefinedPipe, IsNullPipe, IsUndefinedPipe, IsStringPipe, IsFunctionPipe, IsNumberPipe, IsArrayPipe, IsObjectPipe, IsGreaterEqualThanPipe, IsGreaterThanPipe, IsLessEqualThanPipe, IsEqualToPipe, IsNotEqualToPipe, IsIdenticalToPipe, IsNotIdenticalToPipe, IsLessThanPipe, DATE_PIPES, NgDatePipesModule, TimeAgoPipe, isString as ɵa, RadiansPipe as ɵb };

//# sourceMappingURL=ngx-pipes.js.map