/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { EventEmitter, Injectable } from '@angular/core';
import * as i0 from "@angular/core";
export class ProviderFilterService {
    constructor() {
        // all providers
        this.providers = [];
        // dictionary of providers currently selected in sidebar
        this.selectedProviders = {};
        // event for letting provider filter know providers are ready
        this.providersLoaded = new EventEmitter();
        // event for changing all checkbox values
        // true for select
        // false for deselect
        this.toggleAll = new EventEmitter();
    }
    /**
     * closure which returns filter function
     * had to use a closure to be able to pass in selectedProviders list into filter
     * @return {?}
     */
    getFilterfunction() {
        /** @type {?} */
        const selectedProviders = {};
        for (const prov in this.selectedProviders) {
            if (prov) {
                selectedProviders[prov] = this.selectedProviders[prov];
            }
        }
        return function (peragraph) {
            return peragraph.attendingProvider && selectedProviders[peragraph.attendingProvider.firstName + peragraph.attendingProvider.lastName];
        };
    }
}
ProviderFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProviderFilterService.ctorParameters = () => [];
/** @nocollapse */ ProviderFilterService.ngInjectableDef = i0.defineInjectable({ factory: function ProviderFilterService_Factory() { return new ProviderFilterService(); }, token: ProviderFilterService, providedIn: "root" });
if (false) {
    /** @type {?} */
    ProviderFilterService.prototype.providers;
    /** @type {?} */
    ProviderFilterService.prototype.selectedProviders;
    /** @type {?} */
    ProviderFilterService.prototype.providersLoaded;
    /** @type {?} */
    ProviderFilterService.prototype.toggleAll;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZXItZmlsdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1maWx0ZXJzLWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvZmlsdGVyL3Byb3ZpZGVycy9wcm92aWRlci1maWx0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFDLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7O0FBT3ZELE1BQU07SUFnQkY7O3lCQWJpQyxFQUFFOztpQ0FHZixFQUFFOzsrQkFHSixJQUFJLFlBQVksRUFBUTs7Ozt5QkFLOUIsSUFBSSxZQUFZLEVBQVc7S0FHdEM7Ozs7OztJQU1ELGlCQUFpQjs7UUFDYixNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztRQUM3QixHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1lBQzFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3hEO1NBQ0Y7UUFDRCxNQUFNLENBQUMsVUFBUyxTQUFvQjtZQUNoQyxNQUFNLENBQUMsU0FBUyxDQUFDLGlCQUFpQixJQUFJLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3pJLENBQUM7S0FDTDs7O1lBcENKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7UGVyYUdyYXBofSBmcm9tICduZy1jb21tb24tbGlicmFyeSc7XG5pbXBvcnQge0F0dGVuZGluZ1Byb3ZpZGVyfSBmcm9tICduZy1jb21tb24tbGlicmFyeS9saWIvbW9kZWwvQXR0ZW5kaW5nUHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFByb3ZpZGVyRmlsdGVyU2VydmljZSB7XG5cbiAgICAvLyBhbGwgcHJvdmlkZXJzXG4gICAgcHJvdmlkZXJzOiBBdHRlbmRpbmdQcm92aWRlcltdID0gW107XG5cbiAgICAvLyBkaWN0aW9uYXJ5IG9mIHByb3ZpZGVycyBjdXJyZW50bHkgc2VsZWN0ZWQgaW4gc2lkZWJhclxuICAgIHNlbGVjdGVkUHJvdmlkZXJzID0ge307XG5cbiAgICAvLyBldmVudCBmb3IgbGV0dGluZyBwcm92aWRlciBmaWx0ZXIga25vdyBwcm92aWRlcnMgYXJlIHJlYWR5XG4gICAgcHJvdmlkZXJzTG9hZGVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLy8gZXZlbnQgZm9yIGNoYW5naW5nIGFsbCBjaGVja2JveCB2YWx1ZXNcbiAgICAvLyB0cnVlIGZvciBzZWxlY3RcbiAgICAvLyBmYWxzZSBmb3IgZGVzZWxlY3RcbiAgICB0b2dnbGVBbGwgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zdXJlIHdoaWNoIHJldHVybnMgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICogaGFkIHRvIHVzZSBhIGNsb3N1cmUgdG8gYmUgYWJsZSB0byBwYXNzIGluIHNlbGVjdGVkUHJvdmlkZXJzIGxpc3QgaW50byBmaWx0ZXJcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRQcm92aWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwcm92IGluIHRoaXMuc2VsZWN0ZWRQcm92aWRlcnMpIHtcbiAgICAgICAgICBpZiAocHJvdikge1xuICAgICAgICAgICAgc2VsZWN0ZWRQcm92aWRlcnNbcHJvdl0gPSB0aGlzLnNlbGVjdGVkUHJvdmlkZXJzW3Byb3ZdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGVyYWdyYXBoOiBQZXJhR3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJhZ3JhcGguYXR0ZW5kaW5nUHJvdmlkZXIgJiYgc2VsZWN0ZWRQcm92aWRlcnNbcGVyYWdyYXBoLmF0dGVuZGluZ1Byb3ZpZGVyLmZpcnN0TmFtZSArIHBlcmFncmFwaC5hdHRlbmRpbmdQcm92aWRlci5sYXN0TmFtZV07XG4gICAgICAgIH07XG4gICAgfVxufVxuIl19