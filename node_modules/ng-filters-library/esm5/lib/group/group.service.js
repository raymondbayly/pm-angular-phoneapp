/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject, combineLatest, Subject } from 'rxjs';
import { WarningCategoryGroupService } from './warning-category-group.service';
import { HospitalLosGroupService } from './hospital-los-group.service';
import { ProviderGroupService } from './provider-group.service';
import { UnitGroupService } from './unit-group.service';
import { FacilityGroupService } from './facility-group.service';
import * as i0 from "@angular/core";
import * as i1 from "./warning-category-group.service";
import * as i2 from "./hospital-los-group.service";
import * as i3 from "./provider-group.service";
import * as i4 from "./facility-group.service";
import * as i5 from "./unit-group.service";
var GroupService = /** @class */ (function () {
    function GroupService(warningGroupService, hospitalLosGroupService, providerGroupService, facilityGroupService, unitGroupService) {
        var _this = this;
        this.warningGroupService = warningGroupService;
        this.hospitalLosGroupService = hospitalLosGroupService;
        this.providerGroupService = providerGroupService;
        this.facilityGroupService = facilityGroupService;
        this.unitGroupService = unitGroupService;
        /**
         * subject used to change how many groups to be open initially after applying filtering, grouping and/or sorting
         */
        this.changeNumberOfGroupsToShow$ = new BehaviorSubject(4);
        /**
         * subject to expand groups if necessary
         */
        this.expandGroups$ = new BehaviorSubject(false);
        /**
         * switch to decide if it is necessary to recalculate how many groups should be closed
         */
        this.changeGroupsClosed = false;
        /**
         * emits when it is okay to display group options
         */
        this.groupsLoaded$ = new Subject();
        /**
         * different options to group by and corresponding logic to divide graphs into groups
         */
        this.groupOptions = [];
        /** @type {?} */
        var groupOptions = [warningGroupService, hospitalLosGroupService, providerGroupService, facilityGroupService, unitGroupService];
        /** @type {?} */
        var dependencies = this.compileDependencies(groupOptions);
        // set default value of group by
        this.setDefaults();
        // wait for dependencies to load and then
        combineLatest(dependencies).subscribe(function () { return _this.generateGroupByOptions(groupOptions); });
    }
    /**
     * compiles a list of dependencies from all the Group Option classes
     * @param options - list of Services to compile dependencies from
     */
    /**
     * compiles a list of dependencies from all the Group Option classes
     * @param {?} options - list of Services to compile dependencies from
     * @return {?}
     */
    GroupService.prototype.compileDependencies = /**
     * compiles a list of dependencies from all the Group Option classes
     * @param {?} options - list of Services to compile dependencies from
     * @return {?}
     */
    function (options) {
        /** @type {?} */
        var dependencies = [];
        try {
            for (var options_1 = tslib_1.__values(options), options_1_1 = options_1.next(); !options_1_1.done; options_1_1 = options_1.next()) {
                var option = options_1_1.value;
                if (option.dependency && dependencies.indexOf(option.dependency) < 0) {
                    dependencies.push(option.dependency);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (options_1_1 && !options_1_1.done && (_a = options_1.return)) _a.call(options_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return dependencies;
        var e_1, _a;
    };
    /**
     * generate filter functions and titles for all the group by options and add them to the options list
     */
    /**
     * generate filter functions and titles for all the group by options and add them to the options list
     * @param {?} options
     * @return {?}
     */
    GroupService.prototype.generateGroupByOptions = /**
     * generate filter functions and titles for all the group by options and add them to the options list
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.groupOptions = [];
        try {
            for (var options_2 = tslib_1.__values(options), options_2_1 = options_2.next(); !options_2_1.done; options_2_1 = options_2.next()) {
                var option = options_2_1.value;
                this.groupOptions.push(option.generateLanes());
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (options_2_1 && !options_2_1.done && (_a = options_2.return)) _a.call(options_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.groupsLoaded$.next();
        var e_2, _a;
    };
    /**
     * set default value of group by
     */
    /**
     * set default value of group by
     * @return {?}
     */
    GroupService.prototype.setDefaults = /**
     * set default value of group by
     * @return {?}
     */
    function () {
        this.activeGroup = this.warningGroupService.generateLanes();
        this.stagedGroup = this.warningGroupService.generateLanes();
        this.groupSubject$ = new BehaviorSubject(this.warningGroupService.generateLanes().lanes);
    };
    /**
     * what to do if sidebar is destroyed
     */
    /**
     * what to do if sidebar is destroyed
     * @return {?}
     */
    GroupService.prototype.clearGroupBy = /**
     * what to do if sidebar is destroyed
     * @return {?}
     */
    function () {
        this.activeGroup = this.warningGroupService.generateLanes();
        this.stagedGroup = this.warningGroupService.generateLanes();
        this.groupSubject$.next(this.warningGroupService.generateLanes().lanes);
    };
    GroupService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    GroupService.ctorParameters = function () { return [
        { type: WarningCategoryGroupService },
        { type: HospitalLosGroupService },
        { type: ProviderGroupService },
        { type: FacilityGroupService },
        { type: UnitGroupService }
    ]; };
    /** @nocollapse */ GroupService.ngInjectableDef = i0.defineInjectable({ factory: function GroupService_Factory() { return new GroupService(i0.inject(i1.WarningCategoryGroupService), i0.inject(i2.HospitalLosGroupService), i0.inject(i3.ProviderGroupService), i0.inject(i4.FacilityGroupService), i0.inject(i5.UnitGroupService)); }, token: GroupService, providedIn: "root" });
    return GroupService;
}());
export { GroupService };
if (false) {
    /**
     * subject used to change how many groups to be open initially after applying filtering, grouping and/or sorting
     * @type {?}
     */
    GroupService.prototype.changeNumberOfGroupsToShow$;
    /**
     * subject to expand groups if necessary
     * @type {?}
     */
    GroupService.prototype.expandGroups$;
    /**
     * switch to decide if it is necessary to recalculate how many groups should be closed
     * @type {?}
     */
    GroupService.prototype.changeGroupsClosed;
    /**
     * emits when it is okay to display group options
     * @type {?}
     */
    GroupService.prototype.groupsLoaded$;
    /**
     * different options to group by and corresponding logic to divide graphs into groups
     * @type {?}
     */
    GroupService.prototype.groupOptions;
    /**
     * tells the groups to update themselves
     * @type {?}
     */
    GroupService.prototype.groupSubject$;
    /**
     * groups active in the array view
     * @type {?}
     */
    GroupService.prototype.activeGroup;
    /**
     * groups currently selected in sidebar
     * @type {?}
     */
    GroupService.prototype.stagedGroup;
    /** @type {?} */
    GroupService.prototype.warningGroupService;
    /** @type {?} */
    GroupService.prototype.hospitalLosGroupService;
    /** @type {?} */
    GroupService.prototype.providerGroupService;
    /** @type {?} */
    GroupService.prototype.facilityGroupService;
    /** @type {?} */
    GroupService.prototype.unitGroupService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWZpbHRlcnMtbGlicmFyeS8iLCJzb3VyY2VzIjpbImxpYi9ncm91cC9ncm91cC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUV6QyxPQUFPLEVBQUMsZUFBZSxFQUFFLGFBQWEsRUFBYyxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDekUsT0FBTyxFQUFDLDJCQUEyQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFDN0UsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDckUsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDOUQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDdEQsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7Ozs7Ozs7O0lBZ0Q1RCxzQkFBb0IsbUJBQWdELEVBQ2hELHlCQUNBLHNCQUNBLHNCQUNBO1FBSnBCLGlCQVdDO1FBWG1CLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBNkI7UUFDaEQsNEJBQXVCLEdBQXZCLHVCQUF1QjtRQUN2Qix5QkFBb0IsR0FBcEIsb0JBQW9CO1FBQ3BCLHlCQUFvQixHQUFwQixvQkFBb0I7UUFDcEIscUJBQWdCLEdBQWhCLGdCQUFnQjs7OzsyQ0F6Q0MsSUFBSSxlQUFlLENBQVMsQ0FBQyxDQUFDOzs7OzZCQUs1QyxJQUFJLGVBQWUsQ0FBVSxLQUFLLENBQUM7Ozs7a0NBSzlCLEtBQUs7Ozs7NkJBS1YsSUFBSSxPQUFPLEVBQVE7Ozs7NEJBSytFLEVBQUU7O1FBc0J6SCxJQUFNLFlBQVksR0FBa0IsQ0FBQyxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxvQkFBb0IsRUFBRSxvQkFBb0IsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDOztRQUNqSixJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7O1FBRTVELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7UUFFbkIsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxFQUF6QyxDQUF5QyxDQUFDLENBQUM7S0FDeEY7SUFFRDs7O09BR0c7Ozs7OztJQUNILDBDQUFtQjs7Ozs7SUFBbkIsVUFBb0IsT0FBc0I7O1FBQ3hDLElBQU0sWUFBWSxHQUFzQixFQUFFLENBQUM7O1lBQzNDLEdBQUcsQ0FBQyxDQUFpQixJQUFBLFlBQUEsaUJBQUEsT0FBTyxDQUFBLGdDQUFBO2dCQUF2QixJQUFNLE1BQU0sb0JBQUE7Z0JBQ2IsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNyRSxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDdEM7YUFDSjs7Ozs7Ozs7O1FBQ0QsTUFBTSxDQUFDLFlBQVksQ0FBQzs7S0FDckI7SUFFRDs7T0FFRzs7Ozs7O0lBQ0gsNkNBQXNCOzs7OztJQUF0QixVQUF1QixPQUFzQjtRQUMzQyxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzs7WUFDdkIsR0FBRyxDQUFDLENBQWlCLElBQUEsWUFBQSxpQkFBQSxPQUFPLENBQUEsZ0NBQUE7Z0JBQXZCLElBQU0sTUFBTSxvQkFBQTtnQkFDZixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQzthQUNoRDs7Ozs7Ozs7O1FBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7S0FDM0I7SUFFRDs7T0FFRzs7Ozs7SUFDSCxrQ0FBVzs7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDNUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDNUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGVBQWUsQ0FBeUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ2xLO0lBRUQ7O09BRUc7Ozs7O0lBQ0gsbUNBQVk7Ozs7SUFBWjtRQUNFLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzVELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzVELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN6RTs7Z0JBbkdGLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7Z0JBVE8sMkJBQTJCO2dCQUMzQix1QkFBdUI7Z0JBQ3ZCLG9CQUFvQjtnQkFFcEIsb0JBQW9CO2dCQURwQixnQkFBZ0I7Ozt1QkFOeEI7O1NBYWEsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BlcmFHcmFwaH0gZnJvbSAnbmctY29tbW9uLWxpYnJhcnknO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtXYXJuaW5nQ2F0ZWdvcnlHcm91cFNlcnZpY2V9IGZyb20gJy4vd2FybmluZy1jYXRlZ29yeS1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7SG9zcGl0YWxMb3NHcm91cFNlcnZpY2V9IGZyb20gJy4vaG9zcGl0YWwtbG9zLWdyb3VwLnNlcnZpY2UnO1xuaW1wb3J0IHtQcm92aWRlckdyb3VwU2VydmljZX0gZnJvbSAnLi9wcm92aWRlci1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7VW5pdEdyb3VwU2VydmljZX0gZnJvbSAnLi91bml0LWdyb3VwLnNlcnZpY2UnO1xuaW1wb3J0IHtGYWNpbGl0eUdyb3VwU2VydmljZX0gZnJvbSAnLi9mYWNpbGl0eS1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7R3JvdXBPcHRpb259IGZyb20gJy4vR3JvdXBPcHRpb24nO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBHcm91cFNlcnZpY2Uge1xuXG4gIC8qKlxuICAgKiBzdWJqZWN0IHVzZWQgdG8gY2hhbmdlIGhvdyBtYW55IGdyb3VwcyB0byBiZSBvcGVuIGluaXRpYWxseSBhZnRlciBhcHBseWluZyBmaWx0ZXJpbmcsIGdyb3VwaW5nIGFuZC9vciBzb3J0aW5nXG4gICAqL1xuICBwdWJsaWMgY2hhbmdlTnVtYmVyT2ZHcm91cHNUb1Nob3ckID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KDQpO1xuXG4gIC8qKlxuICAgKiBzdWJqZWN0IHRvIGV4cGFuZCBncm91cHMgaWYgbmVjZXNzYXJ5XG4gICAqL1xuICBwdWJsaWMgZXhwYW5kR3JvdXBzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBzd2l0Y2ggdG8gZGVjaWRlIGlmIGl0IGlzIG5lY2Vzc2FyeSB0byByZWNhbGN1bGF0ZSBob3cgbWFueSBncm91cHMgc2hvdWxkIGJlIGNsb3NlZFxuICAgKi9cbiAgcHVibGljIGNoYW5nZUdyb3Vwc0Nsb3NlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBlbWl0cyB3aGVuIGl0IGlzIG9rYXkgdG8gZGlzcGxheSBncm91cCBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgZ3JvdXBzTG9hZGVkJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqXG4gICAqIGRpZmZlcmVudCBvcHRpb25zIHRvIGdyb3VwIGJ5IGFuZCBjb3JyZXNwb25kaW5nIGxvZ2ljIHRvIGRpdmlkZSBncmFwaHMgaW50byBncm91cHNcbiAgICovXG4gIGdyb3VwT3B0aW9uczogeyBncm91cE5hbWU6IHN0cmluZywgbGFuZXM6IHsgbGFuZUZ1bmN0aW9uOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IGJvb2xlYW4sIGxhbmVUaXRsZTogc3RyaW5nIH1bXSB9W10gPSBbXTtcblxuICAvKipcbiAgICogdGVsbHMgdGhlIGdyb3VwcyB0byB1cGRhdGUgdGhlbXNlbHZlc1xuICAgKi9cbiAgcHVibGljIGdyb3VwU3ViamVjdCQ6IEJlaGF2aW9yU3ViamVjdDx7IGxhbmVGdW5jdGlvbjogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiBib29sZWFuLCBsYW5lVGl0bGU6IHN0cmluZyB9W10gPjtcblxuICAvKipcbiAgICogZ3JvdXBzIGFjdGl2ZSBpbiB0aGUgYXJyYXkgdmlld1xuICAgKi9cbiAgYWN0aXZlR3JvdXA6IHsgZ3JvdXBOYW1lOiBzdHJpbmcsIGxhbmVzOiB7IGxhbmVGdW5jdGlvbjogKHBlcmFHcmFwaDogUGVyYUdyYXBoKSA9PiBib29sZWFuLCBsYW5lVGl0bGU6IHN0cmluZyB9W10gfTtcblxuICAvKipcbiAgICogZ3JvdXBzIGN1cnJlbnRseSBzZWxlY3RlZCBpbiBzaWRlYmFyXG4gICAqL1xuICBzdGFnZWRHcm91cDogeyBncm91cE5hbWU6IHN0cmluZywgbGFuZXM6IHsgbGFuZUZ1bmN0aW9uOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IGJvb2xlYW4sIGxhbmVUaXRsZTogc3RyaW5nIH1bXSB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgd2FybmluZ0dyb3VwU2VydmljZTogV2FybmluZ0NhdGVnb3J5R3JvdXBTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIGhvc3BpdGFsTG9zR3JvdXBTZXJ2aWNlOiBIb3NwaXRhbExvc0dyb3VwU2VydmljZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcm92aWRlckdyb3VwU2VydmljZTogUHJvdmlkZXJHcm91cFNlcnZpY2UsXG4gICAgICAgICAgICAgIHByaXZhdGUgZmFjaWxpdHlHcm91cFNlcnZpY2U6IEZhY2lsaXR5R3JvdXBTZXJ2aWNlLFxuICAgICAgICAgICAgICBwcml2YXRlIHVuaXRHcm91cFNlcnZpY2U6IFVuaXRHcm91cFNlcnZpY2UpIHtcbiAgICBjb25zdCBncm91cE9wdGlvbnM6IEdyb3VwT3B0aW9uW10gPSBbd2FybmluZ0dyb3VwU2VydmljZSwgaG9zcGl0YWxMb3NHcm91cFNlcnZpY2UsIHByb3ZpZGVyR3JvdXBTZXJ2aWNlLCBmYWNpbGl0eUdyb3VwU2VydmljZSwgdW5pdEdyb3VwU2VydmljZV07XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5jb21waWxlRGVwZW5kZW5jaWVzKGdyb3VwT3B0aW9ucyk7XG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWUgb2YgZ3JvdXAgYnlcbiAgICB0aGlzLnNldERlZmF1bHRzKCk7XG4gICAgLy8gd2FpdCBmb3IgZGVwZW5kZW5jaWVzIHRvIGxvYWQgYW5kIHRoZW5cbiAgICBjb21iaW5lTGF0ZXN0KGRlcGVuZGVuY2llcykuc3Vic2NyaWJlKCgpID0+IHRoaXMuZ2VuZXJhdGVHcm91cEJ5T3B0aW9ucyhncm91cE9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb21waWxlcyBhIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIGZyb20gYWxsIHRoZSBHcm91cCBPcHRpb24gY2xhc3Nlc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGxpc3Qgb2YgU2VydmljZXMgdG8gY29tcGlsZSBkZXBlbmRlbmNpZXMgZnJvbVxuICAgKi9cbiAgY29tcGlsZURlcGVuZGVuY2llcyhvcHRpb25zOiBHcm91cE9wdGlvbltdKTogT2JzZXJ2YWJsZTxhbnk+W10ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llczogT2JzZXJ2YWJsZTxhbnk+W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb24uZGVwZW5kZW5jeSAmJiBkZXBlbmRlbmNpZXMuaW5kZXhPZihvcHRpb24uZGVwZW5kZW5jeSkgPCAwKSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gob3B0aW9uLmRlcGVuZGVuY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICAvKipcbiAgICogZ2VuZXJhdGUgZmlsdGVyIGZ1bmN0aW9ucyBhbmQgdGl0bGVzIGZvciBhbGwgdGhlIGdyb3VwIGJ5IG9wdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBvcHRpb25zIGxpc3RcbiAgICovXG4gIGdlbmVyYXRlR3JvdXBCeU9wdGlvbnMob3B0aW9uczogR3JvdXBPcHRpb25bXSkge1xuICAgIHRoaXMuZ3JvdXBPcHRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgdGhpcy5ncm91cE9wdGlvbnMucHVzaChvcHRpb24uZ2VuZXJhdGVMYW5lcygpKTtcbiAgICB9XG4gICAgdGhpcy5ncm91cHNMb2FkZWQkLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgZGVmYXVsdCB2YWx1ZSBvZiBncm91cCBieVxuICAgKi9cbiAgc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5hY3RpdmVHcm91cCA9IHRoaXMud2FybmluZ0dyb3VwU2VydmljZS5nZW5lcmF0ZUxhbmVzKCk7XG4gICAgdGhpcy5zdGFnZWRHcm91cCA9IHRoaXMud2FybmluZ0dyb3VwU2VydmljZS5nZW5lcmF0ZUxhbmVzKCk7XG4gICAgdGhpcy5ncm91cFN1YmplY3QkID0gbmV3IEJlaGF2aW9yU3ViamVjdDx7bGFuZUZ1bmN0aW9uOiAocGVyYUdyYXBoOiBQZXJhR3JhcGgpID0+IGJvb2xlYW4sIGxhbmVUaXRsZTogc3RyaW5nfVtdPih0aGlzLndhcm5pbmdHcm91cFNlcnZpY2UuZ2VuZXJhdGVMYW5lcygpLmxhbmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3aGF0IHRvIGRvIGlmIHNpZGViYXIgaXMgZGVzdHJveWVkXG4gICAqL1xuICBjbGVhckdyb3VwQnkoKSB7XG4gICAgdGhpcy5hY3RpdmVHcm91cCA9IHRoaXMud2FybmluZ0dyb3VwU2VydmljZS5nZW5lcmF0ZUxhbmVzKCk7XG4gICAgdGhpcy5zdGFnZWRHcm91cCA9IHRoaXMud2FybmluZ0dyb3VwU2VydmljZS5nZW5lcmF0ZUxhbmVzKCk7XG4gICAgdGhpcy5ncm91cFN1YmplY3QkLm5leHQodGhpcy53YXJuaW5nR3JvdXBTZXJ2aWNlLmdlbmVyYXRlTGFuZXMoKS5sYW5lcyk7XG4gIH1cbn1cbiJdfQ==