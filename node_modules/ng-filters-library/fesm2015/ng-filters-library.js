import { BrowserModule } from '@angular/platform-browser';
import { MatCheckboxModule } from '@angular/material';
import { FormsModule } from '@angular/forms';
import { NgPipesModule } from 'ngx-pipes';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Subject, timer, BehaviorSubject, combineLatest } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { NgModule, EventEmitter, Injectable, defineInjectable, inject } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FiltersModule {
}
FiltersModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MatCheckboxModule,
                    BrowserModule,
                    FormsModule,
                    NgPipesModule
                ],
                declarations: [],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class LocationSelectorService {
    constructor() {
        this.loadedLocations = new Subject();
        this.selectAll = new EventEmitter();
        this.deselectAll = new EventEmitter();
        this.checkForIndeterminate = new EventEmitter();
        this.expandUnitsList = new EventEmitter();
        this.collapseUnitsList = new EventEmitter();
        this.selectedUnits = [];
        this.previousUnits = [];
    }
    /**
     * @param {?} unitID
     * @return {?}
     */
    checkUnitSelection(unitID) {
        for (const unit of this.selectedUnits) {
            if (unitID === unit.key.unitID) {
                return true;
            }
        }
        return false;
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    selectUnit(unit) {
        if (this.selectedUnits.indexOf(unit) < 0) {
            this.selectedUnits.push(unit);
        }
        this.checkForIndeterminate.emit(unit.key.facilityID);
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    deselectUnit(unit) {
        /** @type {?} */
        const index = this.selectedUnits.indexOf(unit);
        if (index !== -1) {
            this.selectedUnits.splice(index, 1);
        }
        this.checkForIndeterminate.emit(unit.key.facilityID);
    }
    /**
     * @param {?} facility
     * @return {?}
     */
    selectAllUnitsFromAFacility(facility) {
        for (const unit of this.units) {
            if (unit.key.facilityID === facility.facilityID && this.selectedUnits.indexOf(unit) < 0) {
                this.selectedUnits.push(unit);
            }
        }
    }
    /**
     * @param {?} facility
     * @return {?}
     */
    deselectAllUnitsFromAFacility(facility) {
        for (const unit of this.units) {
            if (unit.key.facilityID === facility.facilityID) {
                /** @type {?} */
                const index = this.selectedUnits.indexOf(unit);
                if (index !== -1) {
                    this.selectedUnits.splice(index, 1);
                }
            }
        }
    }
    /**
     * Check if previous units and selected units are the same
     * @return {?}
     */
    isLocationSelectionTheSame() {
        // quickest way to decide
        if (this.selectedUnits.length !== this.previousUnits.length) {
            return false;
        }
        // check if every unit from selected units exists in previous units
        for (const unit of this.selectedUnits) {
            /** @type {?} */
            let found = false;
            for (const u of this.previousUnits) {
                // match on facility id and unit id
                if (u.key.facilityID === unit.key.facilityID && u.key.unitID === unit.key.unitID) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        // check if every unit from previous units exists in selected units
        for (const unit of this.previousUnits) {
            /** @type {?} */
            let found = false;
            for (const u of this.selectedUnits) {
                // match on facility id and unit id
                if (u.key.facilityID === unit.key.facilityID && u.key.unitID === unit.key.unitID) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {?} facilityId
     * @return {?}
     */
    getUnitCountForFacility(facilityId) {
        /** @type {?} */
        let unitCount = 0;
        for (const u of this.units) {
            if (u.key.facilityID === facilityId) {
                unitCount++;
            }
        }
        return unitCount;
    }
    /**
     * Builds string []s for change of peragraph and FLC REST calls when filtering
     * @return {?}
     */
    getLocationsToFilter() {
        /** @type {?} */
        const selectedLocations = { facilities: [], units: [] };
        for (const u of this.selectedUnits) {
            selectedLocations.units.push(u.key.unitID);
            if (selectedLocations.facilities.indexOf(u.key.facilityID) < 0) {
                selectedLocations.facilities.push(u.key.facilityID);
            }
        }
        /** *
         * If any of the facilities in the selectedLocations are "indeterminate"
         *  then we must supply the list of units. Otherwise we can specify "*"
         *  for the units which makes the rest / sql calls run faster.
          @type {?} */
        let foundIndeterminateFacility = false;
        for (const fId of selectedLocations.facilities) {
            if (this.indeterminateFacilities.indexOf(fId) >= 0) {
                foundIndeterminateFacility = true;
                // It only takes one...
                break;
            }
        }
        if (!foundIndeterminateFacility) {
            selectedLocations.units = ['*'];
        }
        return selectedLocations;
    }
    /**
     * @param {?} facilityID
     * @param {?} isIndeterminate
     * @return {?}
     */
    setFacilityIndeterminateState(facilityID, isIndeterminate) {
        if (isIndeterminate) {
            this.indeterminateFacilities.push(facilityID);
        }
        else {
            if (this.indeterminateFacilities.indexOf(facilityID) >= 0) {
                this.indeterminateFacilities.splice(this.indeterminateFacilities.indexOf(facilityID), 1);
            }
        }
    }
    /**
     * @return {?}
     */
    clearIndeterminateFacilities() {
        this.indeterminateFacilities = [];
    }
}
LocationSelectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LocationSelectorService.ctorParameters = () => [];
/** @nocollapse */ LocationSelectorService.ngInjectableDef = defineInjectable({ factory: function LocationSelectorService_Factory() { return new LocationSelectorService(); }, token: LocationSelectorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Locations {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FilterQueryConfigService {
    constructor() {
        this.filterQueryEndPoint = null;
    }
    /**
     * @return {?}
     */
    getFilterQueryEndPoint() {
        if (!this.filterQueryEndPoint) {
            console.warn('Filter query endpoint is not set!');
        }
        return this.filterQueryEndPoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setFilterQueryEndPoint(value) {
        this.filterQueryEndPoint = value;
    }
}
FilterQueryConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ FilterQueryConfigService.ngInjectableDef = defineInjectable({ factory: function FilterQueryConfigService_Factory() { return new FilterQueryConfigService(); }, token: FilterQueryConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FilterQueryRestService {
    /**
     * @param {?} http
     * @param {?} filterQueryConfig
     */
    constructor(http, filterQueryConfig) {
        this.http = http;
        this.filterQueryConfig = filterQueryConfig;
        this.pollInstance$ = timer(0, 900000);
    }
    /**
     * Rest call for getting filtered visits according to current criteria
     * @param {?} queryParamsGetter
     * @return {?}
     */
    getFilteredVisits(queryParamsGetter) {
        /** @type {?} */
        const serverFilterCriteria = queryParamsGetter();
        return this.http.get(this.filterQueryConfig.getFilterQueryEndPoint(), { params: this.getQueryParams(serverFilterCriteria) });
    }
    /**
     * get updated filter criteria on an interval
     * @param {?} queryParamsGetter
     * @return {?}
     */
    getFilteredVisitsInterval(queryParamsGetter) {
        return this.pollInstance$.pipe(switchMap((() => this.getFilteredVisits(queryParamsGetter))));
    }
    /**
     * returns the filter criteria in the form of a HttpParams object
     * @param {?} serverFilterCriteria
     * @return {?}
     */
    getQueryParams(serverFilterCriteria) {
        // check if object is empty
        if (Object.keys(serverFilterCriteria).length === 0) {
            return null;
        }
        else {
            /** @type {?} */
            let params = new HttpParams();
            // for every key in the object attach a list of params
            for (const key in serverFilterCriteria) {
                if (serverFilterCriteria.hasOwnProperty(key)) {
                    // traverse the list of params for same key and add each one
                    for (let criteria of serverFilterCriteria[key]) {
                        criteria = criteria.replace(/,/g, '|');
                        params = params.append(key, criteria);
                    }
                }
            }
            return params;
        }
    }
}
FilterQueryRestService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FilterQueryRestService.ctorParameters = () => [
    { type: HttpClient },
    { type: FilterQueryConfigService }
];
/** @nocollapse */ FilterQueryRestService.ngInjectableDef = defineInjectable({ factory: function FilterQueryRestService_Factory() { return new FilterQueryRestService(inject(HttpClient), inject(FilterQueryConfigService)); }, token: FilterQueryRestService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
const SortChoices = {
    RIScore: 'latestRi',
    DisplayName: 'displayName',
    MedicalRecordNumber: 'medicalRecordNumber',
    VisitNumber: 'visitNumber',
    HospitalLOS: 'hospitalLos',
    WarningSeverity: 'warningSeverity',
    WarningDuration: 'warningDuration',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SortService {
    constructor() {
        this.activeSortFunction = null;
        this._stagedSortFunction = null;
        this.activeSortName = null;
        this.stagedSortName = null;
        this.nonStandardSortFunctionActive = false;
        this.nonStandardSortFunction = null;
        // options of dropdown
        this.choices = [
            {
                value: {
                    sortName: SortChoices.DisplayName, transformer: (peragraph) => {
                        return peragraph.displayName;
                    }
                }, description: 'Patient Name', tooltip: 'Alphabetical sort by patient last name'
            },
            {
                value: {
                    sortName: SortChoices.MedicalRecordNumber, transformer: (peragraph) => {
                        return peragraph.patient.medicalRecordNumber;
                    }
                }, description: 'MRN', tooltip: 'Sort graphs by the medical record number of the patient'
            },
            {
                value: {
                    sortName: SortChoices.VisitNumber, transformer: (peragraph) => {
                        return peragraph.vnm;
                    }
                }, description: 'Visit Number', tooltip: 'Sort graphs by the visit number of the patient'
            },
            {
                value: {
                    sortName: SortChoices.RIScore, transformer: (peragraph) => {
                        return peragraph.latestRi;
                    }
                }, description: 'RI Score', tooltip: 'Sort by Rothman Index score value'
            },
            {
                value: {
                    sortName: SortChoices.HospitalLOS, transformer: (peragraph) => {
                        return peragraph.admitDate;
                    }
                }, description: 'Hospital LOS', tooltip: 'Sort by hospital length of stay'
            },
            {
                value: {
                    sortName: SortChoices.WarningSeverity, transformer: (peragraph) => {
                        if (peragraph.activeWarning) {
                            /** @type {?} */
                            const category = peragraph.activeWarning.category;
                            if (category === 'V') {
                                return 4;
                            }
                            else if (category === 'H') {
                                return 3;
                            }
                            else if (category === 'M') {
                                return 2;
                            }
                            else {
                                return 1;
                            }
                        }
                        return null;
                    }
                }, description: 'Warning Severity', tooltip: 'Sort by the severity of patient warnings'
            },
            {
                value: {
                    sortName: SortChoices.WarningDuration, transformer: (peragraph) => {
                        if (peragraph.activeWarning) {
                            return peragraph.activeWarning.createdDate;
                        }
                        return null;
                    }
                }, description: 'Warning Created Time', tooltip: 'Sort by warning created time'
            }
        ];
        this.stageSortFunction(this.choices[0].value.transformer, 1, this.choices[0].value.sortName);
        // set staged sort to active
        this.activeSortFunction = this.getStagedSortFunction();
        this.activeSortName = this.stagedSortName;
    }
    /**
     * @return {?}
     */
    getStagedSortFunction() {
        return this._stagedSortFunction;
    }
    /**
     * what to do if sidebar is destroyed
     * @return {?}
     */
    clearSort() {
        this.activeSortName = null;
        this.activeSortFunction = null;
        this.stagedSortName = null;
        this._stagedSortFunction = null;
    }
    /**
     * stage sort function for application
     * @param {?} transformer
     * @param {?} direction
     * @param {?} sortName
     * @return {?}
     */
    stageSortFunction(transformer, direction, sortName) {
        this.stagedSortName = sortName;
        this._stagedSortFunction = this.createSortFunction(transformer, direction);
    }
    /**
     * generates sort function from transformer function, direction, and sortName
     * @param {?} transformer - function to take peraGraph and return primitive value for sorting
     * @param {?} direction - direction of sort
     * @return {?}
     */
    createSortFunction(transformer, direction) {
        return function (peraGraphA, peraGraphB) {
            /** @type {?} */
            const valueA = transformer(peraGraphA);
            /** @type {?} */
            const valueB = transformer(peraGraphB);
            /** @type {?} */
            let comparison = 0;
            // compare values and return
            if (valueA && valueB) {
                if (valueA > valueB) {
                    comparison = 1;
                }
                if (valueA < valueB) {
                    comparison = -1;
                }
            }
            else {
                if (valueA && !valueB) {
                    comparison = 1;
                }
                else if (valueB && !valueA) {
                    comparison = -1;
                }
            }
            return comparison * direction;
        };
    }
}
SortService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SortService.ctorParameters = () => [];
/** @nocollapse */ SortService.ngInjectableDef = defineInjectable({ factory: function SortService_Factory() { return new SortService(); }, token: SortService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WarningCategoryGroupService {
    constructor() {
        /**
         * things that need to emit before generating the warning lanes
         */
        this.dependency = null;
    }
    /**
     * generate group choice object for facilities
     * @return {?}
     */
    generateLanes() {
        return {
            groupName: 'Warning Category',
            lanes: [{
                    laneFunction: (peraGraph) => peraGraph.activeWarning != null && peraGraph.activeWarning.category === 'V',
                    laneTitle: 'Very High Warning'
                },
                {
                    laneFunction: (peraGraph) => peraGraph.activeWarning != null && peraGraph.activeWarning.category === 'H',
                    laneTitle: 'High Warning'
                },
                {
                    laneFunction: (peraGraph) => peraGraph.activeWarning != null && peraGraph.activeWarning.category === 'M',
                    laneTitle: 'Medium Warning'
                },
                { laneFunction: (peraGraph) => peraGraph.activeWarning == null, laneTitle: 'No Warning' }]
        };
    }
}
WarningCategoryGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
WarningCategoryGroupService.ctorParameters = () => [];
/** @nocollapse */ WarningCategoryGroupService.ngInjectableDef = defineInjectable({ factory: function WarningCategoryGroupService_Factory() { return new WarningCategoryGroupService(); }, token: WarningCategoryGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class HospitalLosGroupService {
    constructor() {
        /**
         * size of LOS lane ranges
         */
        this.losIncrement = 1;
        /**
         * number of lanes LOS group by can have
         */
        this.losLaneMax = 5;
        /**
         * things that need to emit before generating the Hospital Los lanes
         */
        this.dependency = null;
    }
    /**
     * generate group choice object for facilities
     * @return {?}
     */
    generateLanes() {
        /** @type {?} */
        const option = {
            groupName: 'Hospital LOS',
            lanes: []
        };
        for (let i = 0; i < this.losLaneMax * this.losIncrement; i += this.losIncrement) {
            /** @type {?} */
            const losLaneInfo = this.generateLosLaneFilterFunctionAndTitle(i, i + this.losIncrement);
            option.lanes.push({ laneFunction: losLaneInfo.filterFunction, laneTitle: losLaneInfo.title });
        }
        /** @type {?} */
        const losLaneInfoFinal = this.generateLosLaneFilterFunctionAndTitle(this.losLaneMax * this.losIncrement);
        option.lanes.push({ laneFunction: losLaneInfoFinal.filterFunction, laneTitle: losLaneInfoFinal.title });
        return option;
    }
    /**
     * generate filter function and label for Hospital LOS group by
     * @param {?} minIndex - number of days before current time to start including graphs in this lane (inclusive)
     * @param {?=} maxIndex - number of days before current time to stop including graphs (exclusive)
     * @return {?}
     */
    generateLosLaneFilterFunctionAndTitle(minIndex, maxIndex = -1) {
        /** @type {?} */
        const minVolume = minIndex * 86400000;
        if (maxIndex !== -1) {
            /** @type {?} */
            const maxVolume = maxIndex * 86400000;
            return {
                filterFunction: function (peraGraph) {
                    /** @type {?} */
                    const current = ((new Date()).getTime());
                    /** @type {?} */
                    const min = current - minVolume;
                    /** @type {?} */
                    const max = current - maxVolume;
                    return peraGraph.admitDate <= min && peraGraph.admitDate > max;
                }, title: minIndex.toString() + ' - ' + maxIndex.toString() + ' days'
            };
        }
        else {
            // create catch all if max is not included in function call
            return {
                filterFunction: function (peraGraph) {
                    /** @type {?} */
                    const current = ((new Date()).getTime());
                    /** @type {?} */
                    const min = current - minVolume;
                    return peraGraph.admitDate <= min;
                }, title: minIndex.toString() + '+ days'
            };
        }
    }
}
HospitalLosGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
HospitalLosGroupService.ctorParameters = () => [];
/** @nocollapse */ HospitalLosGroupService.ngInjectableDef = defineInjectable({ factory: function HospitalLosGroupService_Factory() { return new HospitalLosGroupService(); }, token: HospitalLosGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ProviderFilterService {
    constructor() {
        // all providers
        this.providers = [];
        // dictionary of providers currently selected in sidebar
        this.selectedProviders = {};
        // event for letting provider filter know providers are ready
        this.providersLoaded = new EventEmitter();
        // event for changing all checkbox values
        // true for select
        // false for deselect
        this.toggleAll = new EventEmitter();
    }
    /**
     * closure which returns filter function
     * had to use a closure to be able to pass in selectedProviders list into filter
     * @return {?}
     */
    getFilterfunction() {
        /** @type {?} */
        const selectedProviders = {};
        for (const prov in this.selectedProviders) {
            if (prov) {
                selectedProviders[prov] = this.selectedProviders[prov];
            }
        }
        return function (peragraph) {
            return peragraph.attendingProvider && selectedProviders[peragraph.attendingProvider.firstName + peragraph.attendingProvider.lastName];
        };
    }
}
ProviderFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProviderFilterService.ctorParameters = () => [];
/** @nocollapse */ ProviderFilterService.ngInjectableDef = defineInjectable({ factory: function ProviderFilterService_Factory() { return new ProviderFilterService(); }, token: ProviderFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ProviderGroupService {
    /**
     * @param {?} providerService
     */
    constructor(providerService) {
        this.providerService = providerService;
        /**
         * things that need to emit before generating the provider lanes
         */
        this.dependency = new Subject();
        this.providerService.providersLoaded.subscribe(() => {
            this.dependency.next();
        });
    }
    /**
     * generate group choice object for facilities
     * @return {?}
     */
    generateLanes() {
        /** @type {?} */
        const option = {
            groupName: 'Provider',
            lanes: []
        };
        for (const provider of this.providerService.providers) {
            option.lanes.push({
                laneFunction: this.generateProviderLaneFilterFunction(provider),
                laneTitle: provider.lastName + ', ' + provider.firstName
            });
        }
        return option;
    }
    /**
     * helper function for generating a filter function for provider groups given a provider
     * @param {?} provider - provider to filter for
     * @return {?}
     */
    generateProviderLaneFilterFunction(provider) {
        /** @type {?} */
        const firstName = provider.firstName;
        /** @type {?} */
        const lastName = provider.lastName;
        return function (peraGraph) {
            return peraGraph.attendingProvider.firstName === firstName && peraGraph.attendingProvider.lastName === lastName;
        };
    }
}
ProviderGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProviderGroupService.ctorParameters = () => [
    { type: ProviderFilterService }
];
/** @nocollapse */ ProviderGroupService.ngInjectableDef = defineInjectable({ factory: function ProviderGroupService_Factory() { return new ProviderGroupService(inject(ProviderFilterService)); }, token: ProviderGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UnitGroupService {
    /**
     * @param {?} locationSelectorService
     */
    constructor(locationSelectorService) {
        this.locationSelectorService = locationSelectorService;
        /**
         * things that need to emit before generating the unit lanes
         */
        this.dependency = new Subject();
        this.locationSelectorService.loadedLocations.subscribe(() => {
            this.dependency.next();
        });
    }
    /**
     * generate group choice object for facilities
     * @return {?}
     */
    generateLanes() {
        /** @type {?} */
        const option = {
            groupName: 'Unit',
            lanes: []
        };
        for (const unit of this.locationSelectorService.units) {
            option.lanes.push({ laneFunction: this.generateUnitLaneFilterFunction(unit), laneTitle: unit.displayName });
        }
        return option;
    }
    /**
     * generate filter function for filtering out a group for a specific unit
     * @param {?} unit - unit to filter on
     * @return {?}
     */
    generateUnitLaneFilterFunction(unit) {
        /** @type {?} */
        const unitName = unit.displayName;
        return function (peraGraph) {
            return peraGraph.unitId === unitName;
        };
    }
}
UnitGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UnitGroupService.ctorParameters = () => [
    { type: LocationSelectorService }
];
/** @nocollapse */ UnitGroupService.ngInjectableDef = defineInjectable({ factory: function UnitGroupService_Factory() { return new UnitGroupService(inject(LocationSelectorService)); }, token: UnitGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FacilityGroupService {
    /**
     * @param {?} locationSelectorService
     */
    constructor(locationSelectorService) {
        this.locationSelectorService = locationSelectorService;
        /**
         * things that need to emit before generating the facility lanes
         */
        this.dependency = new Subject();
        this.locationSelectorService.loadedLocations.subscribe(() => {
            this.dependency.next();
        });
    }
    /**
     * generate group choice object for facilities
     * @return {?}
     */
    generateLanes() {
        /** @type {?} */
        const option = {
            groupName: 'Facility',
            lanes: []
        };
        for (const facility of this.locationSelectorService.facilities) {
            option.lanes.push({ laneFunction: this.generateFacilitiyLaneFilterFunction(facility), laneTitle: facility.displayName });
        }
        return option;
    }
    /**
     * generate filter function for grouping by facility
     * @param {?} facility - facility to filter for
     * @return {?}
     */
    generateFacilitiyLaneFilterFunction(facility) {
        /** @type {?} */
        const facilityName = facility.displayName;
        return function (peraGraph) {
            return peraGraph.facilityId === facilityName;
        };
    }
}
FacilityGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FacilityGroupService.ctorParameters = () => [
    { type: LocationSelectorService }
];
/** @nocollapse */ FacilityGroupService.ngInjectableDef = defineInjectable({ factory: function FacilityGroupService_Factory() { return new FacilityGroupService(inject(LocationSelectorService)); }, token: FacilityGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class GroupService {
    /**
     * @param {?} warningGroupService
     * @param {?} hospitalLosGroupService
     * @param {?} providerGroupService
     * @param {?} facilityGroupService
     * @param {?} unitGroupService
     */
    constructor(warningGroupService, hospitalLosGroupService, providerGroupService, facilityGroupService, unitGroupService) {
        this.warningGroupService = warningGroupService;
        this.hospitalLosGroupService = hospitalLosGroupService;
        this.providerGroupService = providerGroupService;
        this.facilityGroupService = facilityGroupService;
        this.unitGroupService = unitGroupService;
        /**
         * subject used to change how many groups to be open initially after applying filtering, grouping and/or sorting
         */
        this.changeNumberOfGroupsToShow$ = new BehaviorSubject(4);
        /**
         * subject to expand groups if necessary
         */
        this.expandGroups$ = new BehaviorSubject(false);
        /**
         * switch to decide if it is necessary to recalculate how many groups should be closed
         */
        this.changeGroupsClosed = false;
        /**
         * emits when it is okay to display group options
         */
        this.groupsLoaded$ = new Subject();
        /**
         * different options to group by and corresponding logic to divide graphs into groups
         */
        this.groupOptions = [];
        /** @type {?} */
        const groupOptions = [warningGroupService, hospitalLosGroupService, providerGroupService, facilityGroupService, unitGroupService];
        /** @type {?} */
        const dependencies = this.compileDependencies(groupOptions);
        // set default value of group by
        this.setDefaults();
        // wait for dependencies to load and then
        combineLatest(dependencies).subscribe(() => this.generateGroupByOptions(groupOptions));
    }
    /**
     * compiles a list of dependencies from all the Group Option classes
     * @param {?} options - list of Services to compile dependencies from
     * @return {?}
     */
    compileDependencies(options) {
        /** @type {?} */
        const dependencies = [];
        for (const option of options) {
            if (option.dependency && dependencies.indexOf(option.dependency) < 0) {
                dependencies.push(option.dependency);
            }
        }
        return dependencies;
    }
    /**
     * generate filter functions and titles for all the group by options and add them to the options list
     * @param {?} options
     * @return {?}
     */
    generateGroupByOptions(options) {
        this.groupOptions = [];
        for (const option of options) {
            this.groupOptions.push(option.generateLanes());
        }
        this.groupsLoaded$.next();
    }
    /**
     * set default value of group by
     * @return {?}
     */
    setDefaults() {
        this.activeGroup = this.warningGroupService.generateLanes();
        this.stagedGroup = this.warningGroupService.generateLanes();
        this.groupSubject$ = new BehaviorSubject(this.warningGroupService.generateLanes().lanes);
    }
    /**
     * what to do if sidebar is destroyed
     * @return {?}
     */
    clearGroupBy() {
        this.activeGroup = this.warningGroupService.generateLanes();
        this.stagedGroup = this.warningGroupService.generateLanes();
        this.groupSubject$.next(this.warningGroupService.generateLanes().lanes);
    }
}
GroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GroupService.ctorParameters = () => [
    { type: WarningCategoryGroupService },
    { type: HospitalLosGroupService },
    { type: ProviderGroupService },
    { type: FacilityGroupService },
    { type: UnitGroupService }
];
/** @nocollapse */ GroupService.ngInjectableDef = defineInjectable({ factory: function GroupService_Factory() { return new GroupService(inject(WarningCategoryGroupService), inject(HospitalLosGroupService), inject(ProviderGroupService), inject(FacilityGroupService), inject(UnitGroupService)); }, token: GroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Manages the staging filters object -> the current status of the sidebar,
 * the active filters object -> the filters currently being applied to the array view,
 * and the subject which is used to update the array view when filters are applied.
 */
class FilterService {
    /**
     * @param {?} locationSelectorService
     * @param {?} filterRestService
     * @param {?} sortService
     * @param {?} groupService
     */
    constructor(locationSelectorService, filterRestService, sortService, groupService) {
        this.locationSelectorService = locationSelectorService;
        this.filterRestService = filterRestService;
        this.sortService = sortService;
        this.groupService = groupService;
        /**
         * BehaviorSubject for when selected locations change.
         */
        this.locationsChanged = new BehaviorSubject({
            locations: new Locations(),
            executeFilterQuery: false,
        });
        /**
         * Filters actively applied to the array view.
         */
        this.activeFilters = {};
        /**
         * Filters currently selected in the sidebar but NOT applied.
         */
        this.stagingFilters = {};
        /**
         * visit numbers of patients filtered out by server side filters
         */
        this.serverFilteredVisits = [];
        /**
         * name of filter for server side filters
         */
        this.serverFilterName = 'query-filter';
        /**
         * criteria to build filter query from as currently represented in sidebar
         */
        this.stagedServerFilterCriteria = {};
        /**
         * criteria for server side filtering currently ACTIVE in array view
         */
        this._activeServerFilterCriteria = {};
        /**
         * Subject which is updated when filters are applied.
         */
        this.filterSubject$ = new BehaviorSubject(this.activeFilters);
    }
    /**
     * Adds a staged filter (prior to activating the filters)
     * @param {?} filterName Name of the filter to stage.
     * @param {?} filterFunction The filter function to stage.
     * @return {?}
     */
    stageFilter(filterName, filterFunction) {
        this.stagingFilters[filterName] = filterFunction;
    }
    /**
     * Removes a staged filter.
     * @param {?} filterName Name of filter to unstage.
     * @return {?}
     */
    unstageFilter(filterName) {
        delete this.stagingFilters[filterName];
    }
    /**
     * gets filter function that filters out patients based on criteria from conglomerated filter query
     * @return {?}
     */
    getServerSideFilterFunction() {
        /** @type {?} */
        const thisRef = this;
        return function (peragraph) {
            for (const vnm of thisRef.serverFilteredVisits) {
                if (vnm === peragraph.vnm) {
                    return true;
                }
            }
            return false;
        };
    }
    /**
     * add filter criteria to criteria object
     * @param {?} criteria - array of criteria to add to filter
     * @param {?} title - property name of criteria on the filterCriteria object -> MUST match a
     * QueryParam in the REST call located in common.FilterController or it won't be applied
     * @return {?}
     */
    stageServerFilterCriteria(criteria, title) {
        this.stagedServerFilterCriteria[title] = criteria;
        this.stageFilter(this.serverFilterName, this.getServerSideFilterFunction());
    }
    /**
     * removes a criteria object from the filter criteria object
     * if no criterion remain, the filter is removed from the staged filters
     * @param {?} title - name of the criteria to be removed
     * @return {?}
     */
    removeStagedServerCriteria(title) {
        delete this.stagedServerFilterCriteria[title];
        if (Object.keys(this.stagedServerFilterCriteria).length === 0) {
            this.unstageFilter(this.serverFilterName);
        }
    }
    /**
     * return staged server side filter parameters
     * @return {?}
     */
    getStagedServerSideFilterCriteria() {
        return this.stagedServerFilterCriteria;
    }
    /**
     * returns a function which returns the current active filters at the given time
     * @return {?}
     */
    getActiveServerFilterCriteria() {
        /** @type {?} */
        const filterServiceRef = this;
        return function () {
            return filterServiceRef._activeServerFilterCriteria;
        };
    }
    /**
     * what to do if sidebar is destroyed
     * @return {?}
     */
    clearAllFilters() {
        this.activeFilters = {};
        this.stagingFilters = {};
        this.serverFilteredVisits = [];
        this.stagedServerFilterCriteria = {};
        this._activeServerFilterCriteria = {};
        this.filterSubject$.next({});
        this.groupService.clearGroupBy();
        this.sortService.clearSort();
    }
    /**
     * Activate the staged filters
     *
     * 2 seperate paths:
     *      A. Location changes -> refresh graphs is called after changing the endpoint parameters and a variable is passed in
     *                              to let refresh changes know if the server side filter needs to be refreshed
     *      B. No location changes -> If the server side filtering needs to be refreshed, its REST call is initiated before client side filtering occurs,
     *                              otherwise client side filtering occurs immediatley on existing graphs
     * @return {?}
     */
    activateFilters() {
        // close appropriate groups if changing, filters, group by, or sort
        this.groupService.changeGroupsClosed = true;
        // set staged sort to active
        this.sortService.activeSortFunction = this.sortService.getStagedSortFunction();
        this.sortService.activeSortName = this.sortService.stagedSortName;
        // set staged filters to active filters
        this.activeFilters = {};
        for (const filter in this.stagingFilters) {
            if (this.stagingFilters.hasOwnProperty(filter)) {
                this.activeFilters[filter] = this.stagingFilters[filter];
            }
        }
        // set staged server side filtering query parameters to active
        this._activeServerFilterCriteria = {};
        for (const criteria in this.stagedServerFilterCriteria) {
            if (this.stagedServerFilterCriteria.hasOwnProperty(criteria)) {
                this._activeServerFilterCriteria[criteria] = this.stagedServerFilterCriteria[criteria];
            }
        }
        /** @type {?} */
        const executeQuery = this.activeFilters.hasOwnProperty(this.serverFilterName);
        // Check if unit selection has changed
        if (!this.locationSelectorService.isLocationSelectionTheSame() || this.sortService.activeSortName === SortChoices.RIScore || this.groupService.stagedGroup.groupName !== this.groupService.activeGroup.groupName) {
            this.groupService.activeGroup = this.groupService.stagedGroup;
            this.groupService.groupSubject$.next(this.groupService.activeGroup.lanes);
            /** @type {?} */
            const selectedLocations = this.locationSelectorService.getLocationsToFilter();
            // Signal that location selections have changed and whether or not to execute the filter query
            this.locationsChanged.next({ locations: selectedLocations, executeFilterQuery: executeQuery });
        }
        else {
            // if filter query needs to be executed, wait for it to return before filtering the graphs in the client
            if (executeQuery) {
                this.filterRestService.getFilteredVisits(this.getActiveServerFilterCriteria()).subscribe((visits) => {
                    this.serverFilteredVisits = visits;
                    this.filterSubject$.next(this.activeFilters);
                });
            }
            else {
                // pass the filter subject with the updated filters
                setTimeout(() => this.filterSubject$.next(this.activeFilters), 500);
            }
        }
    }
}
FilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FilterService.ctorParameters = () => [
    { type: LocationSelectorService },
    { type: FilterQueryRestService },
    { type: SortService },
    { type: GroupService }
];
/** @nocollapse */ FilterService.ngInjectableDef = defineInjectable({ factory: function FilterService_Factory() { return new FilterService(inject(LocationSelectorService), inject(FilterQueryRestService), inject(SortService), inject(GroupService)); }, token: FilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ServiceLineConfigService {
    constructor() {
        this.serviceLineDescriptionsEndpoint = null;
    }
    /**
     * @return {?}
     */
    getServiceLineDescriptionsEndpoint() {
        if (!this.serviceLineDescriptionsEndpoint) {
            console.warn('Service Line Descriptions endpoint is not set!');
        }
        return this.serviceLineDescriptionsEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setServiceLineDescriptionsEndpoint(value) {
        this.serviceLineDescriptionsEndpoint = value;
    }
}
ServiceLineConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ServiceLineConfigService.ngInjectableDef = defineInjectable({ factory: function ServiceLineConfigService_Factory() { return new ServiceLineConfigService(); }, token: ServiceLineConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ServiceLineRestService {
    /**
     * @param {?} http
     * @param {?} serviceLineConfig
     */
    constructor(http, serviceLineConfig) {
        this.http = http;
        this.serviceLineConfig = serviceLineConfig;
    }
    /**
     * return all service line descriptions
     * @return {?}
     */
    getAllServiceLineDescriptions() {
        return this.http.get(this.serviceLineConfig.getServiceLineDescriptionsEndpoint());
    }
}
ServiceLineRestService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ServiceLineRestService.ctorParameters = () => [
    { type: HttpClient },
    { type: ServiceLineConfigService }
];
/** @nocollapse */ ServiceLineRestService.ngInjectableDef = defineInjectable({ factory: function ServiceLineRestService_Factory() { return new ServiceLineRestService(inject(HttpClient), inject(ServiceLineConfigService)); }, token: ServiceLineRestService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ServiceLineFilterService {
    constructor() {
        this.toggleAll = new EventEmitter();
    }
}
ServiceLineFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ServiceLineFilterService.ctorParameters = () => [];
/** @nocollapse */ ServiceLineFilterService.ngInjectableDef = defineInjectable({ factory: function ServiceLineFilterService_Factory() { return new ServiceLineFilterService(); }, token: ServiceLineFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ProvidersConfigService {
    constructor() {
        this.allProvidersEndpoint = null;
    }
    /**
     * @return {?}
     */
    getAllProvidersEndpoint() {
        if (!this.allProvidersEndpoint) {
            console.warn('All Providers Endpoint is not set!');
        }
        return this.allProvidersEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setAllProvidersEndpoint(value) {
        this.allProvidersEndpoint = value;
    }
}
ProvidersConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ProvidersConfigService.ngInjectableDef = defineInjectable({ factory: function ProvidersConfigService_Factory() { return new ProvidersConfigService(); }, token: ProvidersConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ProvidersApiService {
    /**
     * @param {?} http
     * @param {?} providersConfigService
     */
    constructor(http, providersConfigService) {
        this.http = http;
        this.providersConfigService = providersConfigService;
    }
    /**
     * @return {?}
     */
    getAllProviders() {
        return this.http.get(this.providersConfigService.getAllProvidersEndpoint());
    }
}
ProvidersApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProvidersApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: ProvidersConfigService }
];
/** @nocollapse */ ProvidersApiService.ngInjectableDef = defineInjectable({ factory: function ProvidersApiService_Factory() { return new ProvidersApiService(inject(HttpClient), inject(ProvidersConfigService)); }, token: ProvidersApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AgeGroupsService {
    /**
     * @param {?} filterService
     */
    constructor(filterService) {
        this.filterService = filterService;
        this.PEDIATRIC_GROUP = 'Pediatric';
        this.ADULT_GROUP = 'Adult';
        this.ALL_GROUP = 'All';
    }
    /**
     * @return {?}
     */
    unstageAgeGroups() {
        this.filterService.unstageFilter(this.PEDIATRIC_GROUP);
        this.filterService.unstageFilter(this.ADULT_GROUP);
        this.filterService.unstageFilter(this.ALL_GROUP);
    }
    /**
     * Always returns true because we want all the patients
     * @param {?} peragraph - peragraph to filter
     * @return {?}
     */
    allFilterFunction(peragraph) {
        return true;
    }
    /**
     * Filter out any peragraphs with patients younger than 18
     * @param {?} peragraph - peragraph to be filtered
     * @return {?}
     */
    adultFilterFunction(peragraph) {
        /** @type {?} */
        const birthDate = new Date();
        birthDate.setMilliseconds(peragraph.patient.dob);
        /** @type {?} */
        const currentDate = new Date();
        currentDate.setMilliseconds(Date.now());
        /** @type {?} */
        const age = currentDate.getFullYear() - birthDate.getFullYear();
        return age >= 18;
    }
    /**
     * Filter out any peragraphs with patients older than 18
     * @param {?} peragraph - peragraph to be filtered
     * @return {?}
     */
    pediatricFilterFunction(peragraph) {
        /** @type {?} */
        const birthDate = new Date();
        birthDate.setMilliseconds(peragraph.patient.dob);
        /** @type {?} */
        const currentDate = new Date();
        currentDate.setMilliseconds(Date.now());
        /** @type {?} */
        const age = currentDate.getFullYear() - birthDate.getFullYear();
        return age < 18;
    }
}
AgeGroupsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AgeGroupsService.ctorParameters = () => [
    { type: FilterService }
];
/** @nocollapse */ AgeGroupsService.ngInjectableDef = defineInjectable({ factory: function AgeGroupsService_Factory() { return new AgeGroupsService(inject(FilterService)); }, token: AgeGroupsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WarningsFilterService {
    constructor() {
        /**
         * Warning levels that are selected. Start with all of them.
         */
        this.selectedWarnings = ['warning_v', 'warning_h', 'warning_m', 'warning_none', 'warning_no_ri'];
        /**
         * Configurations for warning level filter options.
         *
         * Contains a filter id, the color of the warning level and a filter function for filtering out
         * the warning if NOT selected.
         */
        this.filterOptions = [
            {
                filterID: 'warning_v', color: '#D51C19',
                filterFunction: function (peragraph) {
                    return !(peragraph.activeWarning && peragraph.activeWarning.category === 'V');
                }
            },
            {
                filterID: 'warning_h', color: '#EE834C',
                filterFunction: function (peragraph) {
                    return !(peragraph.activeWarning && peragraph.activeWarning.category === 'H');
                }
            },
            {
                filterID: 'warning_m', color: '#F6CC5D',
                filterFunction: function (peragraph) {
                    return !(peragraph.activeWarning && peragraph.activeWarning.category === 'M');
                }
            },
            {
                filterID: 'warning_none', color: '#3185B8',
                filterFunction: function (peragraph) {
                    return !(!peragraph.activeWarning && !peragraph.discharged);
                }
            }
        ];
    }
}
WarningsFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ WarningsFilterService.ngInjectableDef = defineInjectable({ factory: function WarningsFilterService_Factory() { return new WarningsFilterService(); }, token: WarningsFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DiagnosisConfigService {
    constructor() {
        /**
         * class for configuring the endpoint for retrieving all diagnoses
         */
        this.diagnosesEndpoint = null;
    }
    /**
     * @return {?}
     */
    getDiagnosesEndpoint() {
        if (!this.diagnosesEndpoint) {
            console.warn('Diagnoses endpoint is not set!');
        }
        return this.diagnosesEndpoint;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDiagnosesEndpoint(value) {
        this.diagnosesEndpoint = value;
    }
}
DiagnosisConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DiagnosisConfigService.ngInjectableDef = defineInjectable({ factory: function DiagnosisConfigService_Factory() { return new DiagnosisConfigService(); }, token: DiagnosisConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DiagnosisFilterService {
    constructor() {
        this.selectedDiagnoses = {};
        this.diagnoses = [];
        this.diagnosesLoaded$ = new EventEmitter();
        this.toggleAll = new EventEmitter();
    }
}
DiagnosisFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DiagnosisFilterService.ctorParameters = () => [];
/** @nocollapse */ DiagnosisFilterService.ngInjectableDef = defineInjectable({ factory: function DiagnosisFilterService_Factory() { return new DiagnosisFilterService(); }, token: DiagnosisFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DiagnosisRestService {
    /**
     * @param {?} http
     * @param {?} diagnosisConfigService
     */
    constructor(http, diagnosisConfigService) {
        this.http = http;
        this.diagnosisConfigService = diagnosisConfigService;
        this.pollInstanceDiagnoses$ = timer(0, 90000);
    }
    /**
     * returns an observable with all diagnoses
     * @return {?}
     */
    getAllDiagnoses() {
        return this.http.get(this.diagnosisConfigService.getDiagnosesEndpoint() + '/all');
    }
    /**
     * returns an observable that broadcasts all active diagnoses on an interval
     * @return {?}
     */
    getAllDiagnosisInterval() {
        return this.pollInstanceDiagnoses$.pipe(switchMap(() => this.getAllDiagnoses()));
    }
}
DiagnosisRestService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DiagnosisRestService.ctorParameters = () => [
    { type: HttpClient },
    { type: DiagnosisConfigService }
];
/** @nocollapse */ DiagnosisRestService.ngInjectableDef = defineInjectable({ factory: function DiagnosisRestService_Factory() { return new DiagnosisRestService(inject(HttpClient), inject(DiagnosisConfigService)); }, token: DiagnosisRestService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WarningTimeFrameFilterService {
    constructor() { }
    /**
     * filters out graphs with warnings older than warning timeframe limit
     * @param {?} warningTimeFrame - # of hours to check back for warning activity
     * @return {?}
     */
    getFilterFunction(warningTimeFrame) {
        /** @type {?} */
        const warningTimeFrameLocal = warningTimeFrame;
        return function (peraGraph) {
            if (peraGraph.activeWarning && peraGraph.activeWarning.createdDate) {
                // check if date warning was created is older then the warning time frame limit
                if (peraGraph.activeWarning.createdDate >= ((new Date()).getTime()) - (warningTimeFrameLocal * 3600000)) {
                    return true;
                }
            }
            else {
                return false;
            }
        };
    }
}
WarningTimeFrameFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
WarningTimeFrameFilterService.ctorParameters = () => [];
/** @nocollapse */ WarningTimeFrameFilterService.ngInjectableDef = defineInjectable({ factory: function WarningTimeFrameFilterService_Factory() { return new WarningTimeFrameFilterService(); }, token: WarningTimeFrameFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Diagnosis {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { FiltersModule, FilterService, ServiceLineConfigService, ServiceLineRestService, ServiceLineFilterService, FilterQueryRestService, FilterQueryConfigService, ProvidersConfigService, ProviderFilterService, ProvidersApiService, LocationSelectorService, AgeGroupsService, WarningsFilterService, DiagnosisConfigService, DiagnosisFilterService, DiagnosisRestService, WarningTimeFrameFilterService, Diagnosis, Locations, SortService, SortChoices, GroupService, FacilityGroupService as ɵd, HospitalLosGroupService as ɵb, ProviderGroupService as ɵc, UnitGroupService as ɵe, WarningCategoryGroupService as ɵa };

//# sourceMappingURL=ng-filters-library.js.map